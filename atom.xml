<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客</title>
  <subtitle>菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-06T07:45:42.282Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS逆向之动态调试</title>
    <link href="http://yoursite.com/2018/06/06/iOS-hacking-lldb/"/>
    <id>http://yoursite.com/2018/06/06/iOS-hacking-lldb/</id>
    <published>2018-06-06T04:02:04.000Z</published>
    <updated>2018-06-06T07:45:42.282Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。</p>
<h2 id="Xcode的动态调试原理"><a href="#Xcode的动态调试原理" class="headerlink" title="Xcode的动态调试原理"></a>Xcode的动态调试原理</h2><p>首先了解一下 <code>Xcode</code> 编译和调试器的发展。<code>Xcode</code> 中的编译器发展历程：<code>GCC</code> -&gt; <code>LLVM</code>,调试器的发展历程：<code>GDB</code> -&gt; <code>LLDB</code> 。</p>
<p><code>Xcode</code> 调试安装到手机上的应用的原理：<code>Xcode</code> 通过 <code>LLDB</code> 调试器把调试指令发送到手机上的 <code>debugserver</code>, <code>debugserver</code> 再与相应的 <code>APP</code> 进行交互，达到调试的效果。</p>
<p><code>debugserver</code> 一开始是存放在Mac的Xcode里面,路径： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms</span><br><span class="line">/iPhoneOS.platform/DeviceSupport</span><br><span class="line">/<span class="number">9.1</span>/DeveloperDiskImage.dmg</span><br><span class="line">/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
<p>当 <code>Xcode</code> 识别到手机设备时，<code>Xcode</code> 会自动将 <code>debugserver</code> 安装到手机上。</p>
<p><code>Xcode</code> 调试的局限性：一般情况下，只能调试通过 <code>Xcode</code> 安装的APP，无法调试其它APP。</p>
<h3 id="给debugserver赋予权限"><a href="#给debugserver赋予权限" class="headerlink" title="给debugserver赋予权限"></a>给debugserver赋予权限</h3><p>默认情况下 <code>/Developer/usr/bin/debugserver</code> 缺少一定的权限，只能调试通过Xcode安装的App，如果希望调试其它App，需要对 <code>debugserver</code> 重新签名，签上可以调试其它App的权限。</p>
<p>需要的两个权限为：<code>get-task-allow</code> 和 <code>task_for_pid-allow</code></p>
<p>iPhone上的 <code>/Developer</code> 目录是只读的，无法直接对 <code>/Developer/usr/bin/debugserver</code> 文件签名，需要先把 <code>debugserver</code> 复制到Mac。</p>
<p>通过 <code>ldid</code> 命令导出文件以前的签名权限:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -e debugserver &gt; debugserver.entitlements</span><br></pre></td></tr></table></figure>
<p><code>debugserver.entitlements</code> 这个文件其实是个 <code>plist</code> 文件，在这个文件中加上上面提到的两个权限后，再通过 <code>ldid</code> 命令对文件重新签名。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -Sdebugserver.entitlements debugserver</span><br></pre></td></tr></table></figure>
<p>然后将已经签好权限的 <code>debugserver</code> 放到 <code>/usr/bin</code> 目录，便于找到 <code>debugserver</code> 指令。</p>
<h3 id="debugserver附加到某个APP进程"><a href="#debugserver附加到某个APP进程" class="headerlink" title="debugserver附加到某个APP进程"></a>debugserver附加到某个APP进程</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ debugserver *:端口号 -a 进程</span><br></pre></td></tr></table></figure>
<ul>
<li>*:端口号：使用iPhone的某个端口启动debugserver服务（不是保留端口）</li>
<li>-a进程：输入APP的进程信息（进程ID或者进程名称）</li>
</ul>
<h3 id="Mac远程连接iPhone上的debugserver服务"><a href="#Mac远程连接iPhone上的debugserver服务" class="headerlink" title="Mac远程连接iPhone上的debugserver服务"></a>Mac远程连接iPhone上的debugserver服务</h3><p>启动LLDB：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端输入</span></span><br><span class="line">$ lldb</span><br></pre></td></tr></table></figure>
<p>连接debugserver服务</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process connect connect:<span class="comment">//手机IP地址:debugserver服务端口号</span></span><br></pre></td></tr></table></figure>
<p>使用LLDB的c命令让程序先继续运行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<p>到此，就可以远程调试别人的App了。</p>
<h3 id="常用的LLDB指令"><a href="#常用的LLDB指令" class="headerlink" title="常用的LLDB指令"></a>常用的LLDB指令</h3><ul>
<li>给ViewController的test方法设置断点</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -n <span class="string">"-[ViewController test]"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看指令用户使用 <code>help</code> 指令： <code>help breakpoint</code> 等。</li>
<li>打印线程的堆栈信息： <code>thread backtrace</code></li>
</ul>
<p>很多命令不在这里赘述，请参考：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">http://lldb.llvm.org/lldb-gdb.html</a></p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>获取 <code>ASLR</code> 的偏移量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure>
<p>打印结果的第二列前面的地址就是我们需要的 <code>ASLR</code> 的偏移量offset。</p>
<p>假如我们想给某个类中的test方法添加断点，那么通过 <code>Hooper</code> 工具找到该方法的第一个内存地址,假如为0x010101，然后地址加上我们得到的 <code>ASLR</code> 的偏移量就是该方法的实际地址。然后通过该地址给方法下断点。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -o <span class="number">0x010101</span>+offset</span><br></pre></td></tr></table></figure>
<p>到此就给该方法添加了断点，之后当程序调用该方法的时候，会停在该断点出。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>练习 <code>lldb</code> 的各种指令时，推荐先在 <code>Xcode</code> 上练习各种用法，因为会有提示和直观的输出结果，更容易我们理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。&lt;/p&gt;
&lt;h2 id=&quot;Xcode的动态调试原理&quot;&gt;&lt;a href=&quot;#Xcode的动态调试原理&quot; class
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向之logify跟踪方法调用</title>
    <link href="http://yoursite.com/2018/06/05/iOS-logify/"/>
    <id>http://yoursite.com/2018/06/05/iOS-logify/</id>
    <published>2018-06-05T04:02:04.000Z</published>
    <updated>2018-06-05T09:04:23.505Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章的介绍，我们将App的头文件使用 <code>class-dump</code> 导出后，然后利用 <code>theos</code> 创建逆向的工程，编写 <code>hook</code> 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪个方法我们不好定位，这时候就用到了 <code>logify</code> 来跟踪函数调用，从而定位到我们需要的函数。</p>
<p><code>logify</code> 是 <code>theos</code> 的一个组件，<code>logify</code> 可以将一个头文件快速转换成已经包含打印信息的xm文件。当然如果某个类中的方法很少，你完全可以自己手动添加 <code>NSLog</code> 的打印信息，但是某个文件中的方法很多的时候，收到给每个方法添加日志信息，会浪费很多很多时间，<code>logify</code> 便是一个不错的工具。</p>
<p>我们以微信的聊天界面为例，假如在当前界面我收到红包消息的时候，我想确定是响应了哪个方法，方便分析抢红包的后续操作。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>我们利用 <code>Reveal</code> 确定出了群聊界面的控制器名称为 <code>BaseMsgContentViewController</code> 并且利用 <code>class-dump</code> 将头文件导出，这个类中的方法特别多，接下来我们利用 <code>logify</code> 把该文件快速转换成已经包含打印信息的xm文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出已添加日志信息的xm文件</span></span><br><span class="line">logify.pl BaseMsgContentViewController.h &gt; Tweak.xm</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>theos</code>工程，用我们刚才生成的 <code>Tweak</code> 替换刚才创建的 <code>theos</code> 项目的<code>Tweak.xm</code>。然后重新编译打包安装。</p>
<h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p><code>logify.pl</code> 生产的xm文件，有很多时候是编译不通过的，需要进行一些处理。</p>
<ul>
<li>删除 <code>__weak</code></li>
<li>删除 <code>inout</code></li>
<li>删除协议 ,或者在头部声明一下协议，<code>@protocol XXXDelegate</code></li>
<li>删除 <code>HBLogDebug(@&quot; = 0x%x&quot;, (unsigned int)r)</code></li>
<li>替换类名为 <code>void *</code> ，比如将 <code>XXPerson *</code> 替换为 <code>void *</code> 因为都是指针类型。或者在头部声明一下，<code>@class XXPerson</code></li>
</ul>
<p>根据自己编译的时候报的具体错误，进行适当的修改即可。</p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><code>theos</code> 工程重新打包安装成功后，重新打开微信的聊天界面，然后打开 <code>Xcode -&gt; Window -&gt; Devices and Simulators</code> 即可跟踪方法的调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据上一篇文章的介绍，我们将App的头文件使用 &lt;code&gt;class-dump&lt;/code&gt; 导出后，然后利用 &lt;code&gt;theos&lt;/code&gt; 创建逆向的工程，编写 &lt;code&gt;hook&lt;/code&gt; 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向解密</title>
    <link href="http://yoursite.com/2018/06/04/iOS-hacking/"/>
    <id>http://yoursite.com/2018/06/04/iOS-hacking/</id>
    <published>2018-06-04T04:02:04.000Z</published>
    <updated>2018-06-06T06:31:58.350Z</updated>
    
    <content type="html"><![CDATA[<p>学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。</p>
<h2 id="Mac远程登录iPhone"><a href="#Mac远程登录iPhone" class="headerlink" title="Mac远程登录iPhone"></a>Mac远程登录iPhone</h2><p>iOS和Mac OS X都是基于Darwin（苹果的一个基于Unix的开源系统内核），所以iOS中同样支持终端的命令行操作。    </p>
<p>在逆向工程中，我们经常会通过命令行来操纵iPhone。为了能够让Mac终端中的命令行能作用在iPhone上，我们得让Mac和iPhone建立连接。连接有两种方式：<code>wifi连接</code>和<code>usb连接</code>。</p>
<blockquote>
<p>先在越狱软件上安装ssh插件OpenSSH ,命令行下和应用交互的插件Cycript        </p>
<p>让越狱手机和mac电脑在同一个局域网下(为了能够通过ssh服务从mac电脑访问手机)</p>
<p>在mac的命令行终端 通过ssh服务登录手机 输入<code>ssh root@手机ip</code>。默认情况下的root密码是alpine。root密码可以自己修改。        </p>
<p>然后在手机上运行程序，在mac终端上利用ps -A 查看手机当前运行的进程，找到进程id后便可以利用cycript进行一些列操作。例如：进入当前运行着的微信进程的cycript状态<code>cycript -p WeChat</code></p>
</blockquote>
<p>采用<code>wifi连接</code>有时候会出现卡顿延迟的现象，所以我通常采用<code>usb连接</code>。</p>
<blockquote>
<p>Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone        </p>
<p> 我使用了两个脚本进行登录：    </p>
<ul>
<li><p><code>python ~/iOS/tcprelay.py -t 22:10010</code>进行端口的映射</p>
</li>
<li><p><code>ssh -p 10010 root@localhost</code> usb的登录</p>
</li>
</ul>
</blockquote>
<h2 id="Cycript的使用"><a href="#Cycript的使用" class="headerlink" title="Cycript的使用"></a>Cycript的使用</h2><p>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物，可以用来探索、修改、调试正在运行的Mac\iOS APP。官网：<a href="http://www.cycript.org/" target="_blank" rel="external">http://www.cycript.org</a></p>
<p>比如一些简单的使用：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信进程</span></span><br><span class="line">cycript -p WeChat</span><br><span class="line"><span class="comment">// 获得沙盒路径</span></span><br><span class="line"><span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 打印当前页面view的层级</span></span><br><span class="line"><span class="built_in">UIApp</span>.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure>
<p>主要搭配<code>Reveal</code>使用，从<code>Reveal</code>中获得某个界面或者<code>view</code>所属的类或控制器，然后拿到该类或控制器利用cycript进行调试。比如，知道了一个<code>view</code>对应的类为<code>testView</code>,想把该<code>view</code>从当前界面移除，达到不显示的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[testView removeFromSuperview];</span><br></pre></td></tr></table></figure>
<h2 id="代码Hook分析"><a href="#代码Hook分析" class="headerlink" title="代码Hook分析"></a>代码Hook分析</h2><p>如果要逆向App的某个功能少不了代码的分析。</p>
<ol>
<li><p>通过上面的分析，找到某个<code>view</code>对应的类后，就需要导出该类对应的头文件进行具体的分析了。        </p>
</li>
<li><p>首先找到App的二进制文件（Mach-O类型），（使用iFunBox把该文件导出到Mac上）然后使用class-dump工具导出其中的所有头文件，这些头文件中可以看到其中的属性和方法。<code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></p>
</li>
<li><p>如果要查看<code>Mach-O</code>文件完整信息，建议用<code>MachOView</code>。<code>otool -l</code>打印所有的 <code>Load Commands</code>，建议搭配<code>grep</code>进行正则过滤。<code>otool -L</code> 可以查看使用的库文件。</p>
</li>
<li><p>头文件分析完毕后，就可以利用<code>theos</code>进行越越代码的开发了，编译生成Tweak插件(<code>deb</code>格式)。</p>
<blockquote>
<p>利用<code>nic.pl</code>指令，选择<code>iphone/tweak</code>，创建一个tweak工程。</p>
<p>在这个tweak工程中编辑<code>Tweak.xm</code>文件，编写自己的越狱代码。</p>
<p>开发完成后利用<code>make package</code>打包和<code>make install</code>安装到手机。重启应用，你会发现对应的功能已经根据hook的代码改变了。</p>
<p>原理：iOS在越狱后，会默认安装一个名叫<code>mobilesubstrate</code>的动态库，它的作用是提供一个系统级的入侵管道，所有的<code>tweak</code>都可以依赖它来进行开发。在目标程序启动时根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序，从而达到修改内存中代码逻辑的目的。</p>
</blockquote>
</li>
<li><p>有时候想看某个类中的某个方法的实现以及调用逻辑，就需要用到<code>Hopper Disassembler</code>工具。</p>
</li>
</ol>
<h3 id="theos的常用语法"><a href="#theos的常用语法" class="headerlink" title="theos的常用语法"></a>theos的常用语法</h3><ul>
<li><p>%hook ,%end : hook一个类的开始和结束</p>
</li>
<li><p>%log：打印方法调用详情</p>
</li>
<li><p>HBDebugLog：跟NSLog类似</p>
</li>
<li><p>%new：添加一个新的方法的时候使用</p>
</li>
<li><p>%orig：函数原来的代码逻辑</p>
</li>
<li><p>%ctor：在加载动态库时调用</p>
</li>
<li><p>logify.pl：可以将一个头文件快速转换成已经包含打印信息的xm文件</p>
</li>
<li><p>如果有额外的资源文件（比如图片），放到项目的layout文件夹中，对应着手机的根路径/</p>
</li>
</ul>
<h2 id="砸壳-脱壳"><a href="#砸壳-脱壳" class="headerlink" title="砸壳(脱壳)"></a>砸壳(脱壳)</h2><p>如果使用越狱手机直接从<code>pp助手</code>下载下来的部分应用免去了我们自己脱壳的过程。但是如果是从App Store下载下来的应用，App Store已经为该应用进行了加密，再使用<code>class-dump</code>是无法导出头文件的，这是时候就需要对APP进行脱壳操作了。</p>
<p>脱壳工具有两种，<code>Clutch</code> 和 <code>dumpdecrypted</code></p>
<p><code>Clutch</code> :     </p>
<blockquote>
<p>在Mac终端登陆到iPhone后，利用Clutch脱壳</p>
<p><code>Clutch -i</code>    列举手机中已安装的应用中加密的应用。</p>
<p><code>Clutch -d  应用bundleid</code> 对加密的应用脱壳，脱壳成功后会生产新的<code>Match-O</code>文件。对这个新的文件进行<code>class-dump</code>操作即可。</p>
</blockquote>
<p>有时候使用<code>Clutch</code>脱壳，会出现失败的情况，比如脱壳微信的时候就会出现错误。这个时候就需要使用<code>dumpdecrypted</code>：    </p>
<blockquote>
<p>终端进入<code>dumpdecrypted.dylib</code>所在的目录 <code>var/root</code></p>
<p>使用环境变量 <code>DYLD_INSERT_LIBRARIES</code> 将 <code>dylib</code> 注入到需要脱壳的可执行文件（可执行文件路径可以通过<code>ps -A</code>查看获取）</p>
<p>执行命令 <code>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 可执行文件路径</code> 即可完成脱壳操作。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解以上逆向的流程后，你可以实现一些有趣的功能，比如:视频客户端去广告，修改微信运动步数，防止微信消息测回，微信自动抢红包等功能。同时，也会在自己客户端的开发过程中更注重信息的安全保护。研究逆向，一定要善于利用各种工具，并且做好不断失败的准备，愈挫愈勇，终会成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;Mac远程登录iP
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>半梦半醒之间</title>
    <link href="http://yoursite.com/2017/07/15/life-alone/"/>
    <id>http://yoursite.com/2017/07/15/life-alone/</id>
    <published>2017-07-15T13:48:10.000Z</published>
    <updated>2017-07-15T14:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>我大清早起，<br>站在人家屋角上哑哑的啼，<br>人家讨厌我，<br>说我不吉利，<br>我不能呢呢喃喃的讨人家欢喜。        </p>
<pre><code>----胡适《乌鸦》
</code></pre><p>昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦鸣，再也无法入眠。        </p>
<p>微风拂来，撩动水波流淌，夜色安谧，远远的，这条无人问津充斥着人们欢娱后残余下的瓶瓶罐罐被迫散发着恶息的溪流，却在这座城市中勾勒出最为灿烂的一副景画，灯火延绵、十里金粉，周围楼宇檐牙鳞次栉比地伸展绵延开去，使得这一方水土宛若盘踞于地面的金龙，孕育出这座城市繁华的景象，也倒映着一个夜行人的孤寂与萧条。我捡起一块沾满泥土的石块，投向了水中落寞的身影，摇曳的月光仿佛在嘲笑一个无家可归的人，我笑着摇了摇头，拍了拍手上的尘土，愈行愈远。        </p>
<p>一念花开，一念花落，这山长水远的人世，终究是要自己走下去。            </p>
<p>世上最痛苦的事，不是生老病死，而是生命的旅程虽短，却充斥着永恒的孤寂；世上最痛苦的事，不是永恒的孤寂，而是明明看见温暖与生机，我却无能为力；世上最痛苦的事，不是我无能为力，而是当一切都触手可及，我却不愿伸出手去。后来我才知道，原来这便是生活。        </p>
<p>《这个杀手不太冷》里，马蒂尔德问里昂：生活是否永远艰辛，还是只有童年如此。里昂说：永远如此。所以我们才拼了命的读书学习，也不过是为了把自己变成更好的人，以便遇到更好的人，避开这种庸俗。        </p>
<p>罗曼·罗兰说：这世界上只有一种真正的英雄主义，就是在看清生活的真相之后，依然热爱生活。        </p>
<p>这便是真英雄吧！        </p>
<p>我想起了网上的一个场景，久久不能忘怀。那应该是一个风和日丽的午后，暖暖的阳光掠过湖水，带起一阵美丽的涟漪。我歪歪斜斜的靠在斑驳、苍老的石灰墙上，目光慵懒而且游移不定，我看见一只狗眯着眼睛淌着涎水安详的打着盹，一只花白母鸡和一只脊背上一撮毛剥掉了的大红公鸡在无聊的刨土。一辆破旧的板车，它的两只胳膊已经断了，它的下半身由于长期处于积水塘里而生出了苔藓。这时候，一阵稍微大一点的风夹杂着竹叶与竹叶摩擦的声音拂面而来，那一瞬间，我幼小的心灵就产生了怅然若失的感觉，一种莫名的、强大的、浓重的忧伤像冬天的大雾一样裹住了我。我像是被整个世界离弃了一般，全世界的人都离我而去了，只剩下我一个人独自咀嚼着孤独的滋味。人呢？人都哪里去了？我的目光再一次停留在那破旧的板车上，想象着自己总有一天会像那辆板车一样落魄、潦倒，心里就愈发沉重起来，我竟然不知不觉为那辆板车也为自己洒下了一行童年时忧伤的泪水。        </p>
<p>我抬头望向天空，原来天真的是空的！这一刻，深深的为自己的渺小与无能而感到不知所措。        </p>
<p>我抚摸着这半截老墙，不禁感叹：你刚建造的时候人们反对你，阻碍了人与人之间的距离，当人们习惯的时候又开始依赖你，把你建的又宽又高，直到最后人们渐渐的忽略了你的存在，就这样我们每个人都被你封闭在了自己的围墙里，慢慢地、一丝丝、一缕缕渗透到我们的一寸寸肌肤里，原来面对面的两个人，中间却有两座厚重的壁垒，横亘在彼此之间。我们都小心翼翼的蜷缩在自己构建的城堡里，偷窥着外面的世界，形单影只，不外如是。        </p>
<p>这一路，半梦半醒间，走走停停，却又无比的惬意和轻松。或许这就是张爱玲说的：我们都是寂寞惯了的人。        </p>
<p>于是执笔研墨，写下了这一纸寂寞。            </p>
<hr>
<p>这是一篇无病呻吟的文章，纯属是一次风格的练习尝试。大家还是应该看些正能量的文章，比如我之前写的：<a href="http://coderperson.com/2015/05/26/byeyouth/" target="_blank" rel="external">《再见-百度空间》</a>。        </p>
<p>晚安！        </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我大清早起，&lt;br&gt;站在人家屋角上哑哑的啼，&lt;br&gt;人家讨厌我，&lt;br&gt;说我不吉利，&lt;br&gt;我不能呢呢喃喃的讨人家欢喜。        &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;----胡适《乌鸦》
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://yoursite.com/2017/01/02/life-2016summary/"/>
    <id>http://yoursite.com/2017/01/02/life-2016summary/</id>
    <published>2017-01-02T09:59:10.000Z</published>
    <updated>2017-01-02T10:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。</p>
<p>回首2016年，这一年是自己心态改变最大的一年，做事和考虑问题的方式和以前有了很大的不同。</p>
<p>这一年，由于工作原因和几个好朋友分开住了，所幸离得不是很远，每个星期都能聚聚，一起谈谈理想，扯扯人生，很幸运有这帮志同道合的朋友。</p>
<p>关于运动，今年坚持的还不错，从年初开始直到进入冬天，每周末至少会去奥森跑10公里或者去干部学院打一下午篮球。今年夏天还办了一张游泳卡，学会了游泳，游完泳后再去打篮球，也是累的不行。可惜进入冬天后，运动的次数明显是减少了，身体状态也不如以前了，引以为鉴。</p>
<p>今年冬天我更换了工作，这件事情对我的触动很大。我在这个项目上付出了很多，但是由于种种原因提出了离职，所幸的是后来我加入了一个很棒的团队，同时也在做一款伟大的产品。于是不爱加班的我开启了疯狂加班模式，理由很简单，我很看好这款产品。用老大的一句话就是：为了世界和平。</p>
<p>关于生活，仍然是一人吃饱全家不饿的状态。一个人过的很随便，直到周边朋友开始买车买房了，才给自己敲响了警钟，2017年该攒首付钱了。</p>
<p>关于读书，这块很惭愧，今年读的书比较少，2017年一定要多读书。日记也有半年没有写了，2017一定要坚持下来。</p>
<p>关于爱情，这块没有，略~~        </p>
<p>2016留下了很多遗憾，做错了很多事，总归是不断成长的。</p>
<p>展望2017，只有一个目标：努力提高自己！</p>
<p>再见，2016！<br>你好，2017！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。&lt;/p&gt;
&lt;p&gt;回首2016年，这一
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>访问坏内存Bug定位解决</title>
    <link href="http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/"/>
    <id>http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/</id>
    <published>2016-10-24T06:39:05.000Z</published>
    <updated>2016-10-24T06:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。</p>
<p>当对项目中的某一模块进行操作的时候遇到的错误是<code>EXC_BREAKPOINT (code=1, subcode=…)</code>而且没有任何错误log的打印。添加了<code>全局断点</code>还是没有定位到出错代码的位置，这时候就需要对xcode进行一些设置了。        </p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/EXC_BRECKPOINT.png" alt="EXC_BRECKPOINT.png"></p>
<p>xcode开启<code>僵尸模式</code>,如果遇到<code>The target process has no stack logs. Run it with the MallocStackLogging env</code>这种问题那么可以设置下<code>MallocStackLoggingNoCompact</code>为YES。</p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/malloc1.jpg" alt="zombie"></p>
<p>这个时候再对出问题的模块进行操作，会打印出<code>[testViewController retain]message sent to deallocated instance</code>的错误提示，这要就定位到了出问题的大体位置了,并且也知道了是坏内存访问的问题。</p>
<p>但是这个控制器中的代码有上千行，这个时候如何定位呢，既然是内存问题，这里就用到了内存调试工具<code>Zombies</code>了。<br>打开该工具，运行项目，当出现<code>message sent to deallocated instance</code>时候，工具会提示<code>An Objective-C message was sent to a deallocated object(zombie) at address:0x8b3b200</code>，点击提示，工具会提示可能存在内存问题的地方，然后自己看一下定位的具体代码，就能发现出现问题的地方了。    </p>
<p><img src="http://i.stack.imgur.com/qbfcb.png" alt=""></p>
<p><img src="http://i.stack.imgur.com/wpolZ.png" alt="">        </p>
<p>到这里你就应该定位到出问题代码的位置了，合理的利用调试工具，用助于我们高效率的开发。</p>
<blockquote>
<p>今天是1024，程序员的节日，祝大家节日快乐。</p>
</blockquote>
<p>参考资料在<a href="http://stackoverflow.com/questions/11170614/viewcontroller-respondstoselector-message-sent-to-deallocated-instance-crash" target="_blank" rel="external">这里</a>，欢迎大家转载，请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。&lt;/p&gt;
&lt;p&gt;当对项目中的某一模块进行操作的时候遇到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发实战</title>
    <link href="http://yoursite.com/2016/10/10/wx-progects/"/>
    <id>http://yoursite.com/2016/10/10/wx-progects/</id>
    <published>2016-10-10T03:10:55.000Z</published>
    <updated>2016-10-11T02:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信小程序做了几个小项目，感觉和以前学的ReactNavative开发有很多相似之处。</p>
<ul>
<li>骚客计算器</li>
</ul>
<p>用微信小程序搭建的简易计算器，一些计算逻辑可能还有一些问题，不过这不是重点，主要是通过这个项目练练手。里面涉及到的一些知识点：数据绑定、页面渲染、逻辑结构、事件响应、页面跳转等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-calculator.jpg" width="25%" height="25%"><br><br></center>



<ul>
<li>骚客天气</li>
</ul>
<p>用微信小程序搭建的简易天气界面，可以看到当天和未来三天的天气情况。里面涉及到的一些知识点：位置接口、网络通信、百度地图API、天气API、方法封装调用，Flex布局、模板处理、引用、列表渲染等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-weather.jpg" width="25%" height="25%"><br><br></center>        


<p>后续还会写一些简单的小应用。        </p>
<p>这些项目统一放在github上：<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">戳这里</a>，以后用微信小程序写的一些应用我也会统一放到<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="wx" scheme="http://yoursite.com/tags/wx/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天框架的搭建</title>
    <link href="http://yoursite.com/2016/09/28/iOS-weChat/"/>
    <id>http://yoursite.com/2016/09/28/iOS-weChat/</id>
    <published>2016-09-28T13:52:50.000Z</published>
    <updated>2018-03-07T05:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>XZ_WeChat</code>高仿微信聊天框架的搭建，工程地址：<a href="https://github.com/corderguo/XZ_WeChat" target="_blank" rel="external">https://github.com/corderguo/XZ_WeChat</a>        </p>
<p>效果图展示：            </p>
<p><img src="http://img.blog.csdn.net/20160928230616321" alt="1"><br><img src="http://img.blog.csdn.net/20160928230519993" alt="2">        </p>
<p>做了两年IM相关工作了，去年是集成环信的SDK实现的IM功能，今年公司拥有自己的长连接服务器，于是从头自己定协议然后一步步实现了IM的整体功能，基本把微信IM有关的内容都实现了。最近开始整理过去的一些知识，于是先从聊天框架下手，整理出这个简易的聊天框架，方便大家学习交流。</p>
<p>该框架摘除了本地缓存的功能（这部分内容太多了），预留好缓存的方法，使得该框架尽可能的简洁实用，方便大家学习，我也会逐渐把该框架完善起来。    </p>
<p>由于作者的电脑环境被折腾坏了，不能安装cocoapods来管理一些用到的三方，所以直接导入进了该框架，这一点大家不要学习。</p>
<p>该框架目前支持的消息类型：文本消息（包含表情），图片消息，语音消息，视频消息，文件消息(pdf,word,excel,ppt,png,html等格式)。</p>
<p>如果你想展示文件消息，你需要把文件拷贝到沙盒的<code>/Library/Caches/Chat/File</code>目录下,由于我以前是从PC端发送文件到手机端进行的展示，所以目前只能你手动拷贝了。</p>
<p>项目中展示的视频已经转成了<code>mp4</code>类型，而且也经过了压缩，语音也转换成了<code>amr</code>格式，节省流量的同时，可以和安卓端兼容。</p>
<p>你能从该框架学习到什么：        </p>
<ul>
<li>聊天框架的搭建</li>
<li>表情键盘的实现</li>
<li>语音相关的知识</li>
<li>视频相关的知识</li>
<li>文件相关的功能</li>
<li>转场动画相关的知识</li>
<li>数据模型和尺寸模型分离</li>
<li>你能清楚的了解到在实战项目中IM的实现    </li>
</ul>
<p>目前该框架这是初步，我还有好多功能没有加入进去，后续会慢慢加入，包括：        </p>
<ul>
<li>消息的转发、拷贝、撤回</li>
<li>文章的分享</li>
<li>订阅号的功能</li>
<li>红包的功能</li>
<li>本地缓存的功能(其实很多功能都要基于数据库的，我把数据库去除掉后，很多功能就一块去除了)</li>
<li>草稿箱的功能</li>
<li>等等等还有好多好多</li>
</ul>
<hr>
<p><strong>更新日志</strong>：            </p>
<p>10月8日：添加了消息的拷贝、删除、撤回功能，由于转发功能需要用到数据库所以我只添加了转发的UI,等添加了数据库后再完善。<code>注意</code>这里的只有自己的消息并且是发送成功的消息才可以撤回，我这里限制的是<code>5分钟</code>内的消息可以撤回,超过规定时间不允许撤回。            </p>
<p>10月12日：添加了系统消息，当消息撤回的时候聊天界面上提示一条<code>你撤回了一条消息</code>的提示。当多人聊天的时候，如果一方撤回了一条消息，系统应该给你发送一条指令，根据这条指令你识别出是哪一条消息被撤回了，然后删除这条消息，并且插入一条<code>谁谁撤回了一条消息</code>。</p>
<p>10月12日：适配xcode8.0，解决bug，如果用xcode8.0的模拟器访问相册时崩溃，则换成真机即可，我也是在升级到xcode8.0后遇到的问题，问题如下：            </p>
<pre><code class="objc">objc[<span class="number">6777</span>]: Class PLBuildVersion is implemented 
<span class="keyword">in</span> both /Applications/Xcode.        
app/Contents/Developer/Platforms/iPhoneSimulator.            
platform/Developer/SDKs/iPhoneSimulator.            
sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.
framework/AssetsLibraryServices (<span class="number">0x1227c3910</span>) and        
/Applications/Xcode.app/Contents/Developer/Platforms
/iPhoneSimulator.platform/Developer/SDKs
/iPhoneSimulator.    
sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.
framework/PhotoLibraryServices (<span class="number">0x1225ed210</span>).                 
One of the two will be used. Which one is undefined.
</code></pre>
<p>奇怪的是我原项目中没有遇到该问题，而抽出来的这个聊天框架却遇到了问题，我猜想是我项目中使用了cocoapods来管理三方，而该聊天框架中我是直接导入的，稍后我会集成cocoapods，尝试问题的解决。大家若有解决方法可以给我留言，大家共同提高。</p>
<p>如果你在学习过程中有什么问题可以和我留言，大家共同提高。如果该框架能帮助到你，欢迎star，你的关注是我最大的动力，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;XZ_WeChat&lt;/code&gt;高仿微信聊天框架的搭建，工程地址：&lt;a href=&quot;https://github.com/corderguo/XZ_WeChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WeChat" scheme="http://yoursite.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>iOS之安全加密</title>
    <link href="http://yoursite.com/2016/09/02/iOS-security-encrypt/"/>
    <id>http://yoursite.com/2016/09/02/iOS-security-encrypt/</id>
    <published>2016-09-02T02:12:15.000Z</published>
    <updated>2016-09-20T08:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><hr>
<p>在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用<code>POST</code>请求提交用户的这些隐私数据。因为<code>GET</code>请求的所有参数都直接暴露在<code>URL</code>中。同时请求的<code>URL</code>一般会记录在服务器的访问日志中，服务器的访问日志是黑客攻击的重点对象之一。</p>
<p>仅仅用<code>POST</code>请求提交用户的隐私数据，还是不能完全解决数据安全的问题，我们可以利用软件（比如Charles）设置代理服务器，拦截查看手机的请求数据。因此：提交用户的隐私数据时，一定不要明文提交，要加密处理后再提交。</p>
<p>另外，我们也不应该在本地保存用户的隐私数据的<code>明文</code>。</p>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><hr>
<p>常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES。</p>
<p>针对上述加密算法，我把目前流行的几种加密方式做下分类：</p>
<ul>
<li><p>哈希（散列）函数</p>
<ul>
<li>MD5（Message Digest Algorithm 5，译为“消息摘要算法第5版”）</li>
<li>SHA1</li>
<li>SHA256            </li>
</ul>
</li>
<li><p>对称加密算法</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES(高级密码标准，美国国家安全局使用的)</li>
</ul>
</li>
<li><p>非对称加密算法</p>
<ul>
<li>RSA</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点说一下散列函数的特点：    </p>
</blockquote>
<ul>
<li>算法是公开的;</li>
<li>对相同的数据加密，得到的结果是一样的;</li>
<li>对不同的数据加密，得到的结果是定长的。例如:MD5对不同的数据进行加密，得到的结果都是32个字符长度的字符串;</li>
<li>信息摘要，信息”指纹”，是用来做数据识别的！比如:搜索;</li>
<li>不能反算的,即是不可逆的。</li>
</ul>
<p>利用这些特点，我们在项目中的应用:    </p>
<p><code>加密密码</code>：服务器并不需要知道用户真实的密码！        </p>
<p><code>搜索</code>：比如你要搜索“张老师 杨老师 苍老师”和“苍老师 张老师 杨老师”，其实这两个要搜索的内容所表达的意思是一样的，但是我们应该如何判断呢。我们可以对搜索的每个关键字进行散列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！<br>张老师            1bdf605991920db11cbdf8508204c4eb<br>杨老师             2d97fbce49977313c2aae15ea77fec0f<br>苍老师             692e92669c0ca340eff4fdcef32896ee</p>
<p><code>版权</code>: 版权保护，文件识别。例如可以对文件内容进行MD5，然后可以根据该MD5串判断文件内容是否被修改过。我以前做IM的文件上传功能就是这样判断的，如果文件内容的MD5相同，表示该文件已经在服务器存在了，就不用再次上传了。</p>
<p>由于<code>MD5</code>加密算法具有较好的安全性，而且免费，因此该加密算法被广泛使用。不过遗憾的是该加密算法已经被暴力破解了,<a href="http://www.cmd5.com" target="_blank" rel="external">http://www.cmd5.com</a>该网站记录超过24万亿条，共占用160T硬盘 的密码数据，通过对海量数据的搜索得到的结果！    </p>
<p>不过我们可以通过提升MD5加密的安全性，加大被破解的难度。    </p>
<p><code>1</code>. 加“盐”（佐料）。<br><code>2</code>. HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符。</p>
<h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><hr>
<p>RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙：使用publicKey可以对数据进行加密，使用Key才能对数据进行解密。    </p>
<p>特点：单方向传输<br>用公钥加密的数据，只有私钥能解开（可用于加密）；<br>同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍）；</p>
<p>公钥与私钥：            </p>
<p>1.权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。<br>2.私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。<br>3.公钥好比安全性极高的挂号信箱地址，公开。        </p>
<p>举例：若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤：        </p>
<ol>
<li>甲用乙的公钥对合同加密。        </li>
<li>密文从甲发送到乙。        </li>
<li>乙收到密文，并用自己的私钥对其解密。        </li>
<li>解密正确，经阅读，乙用自己的私钥对合同进行签署。        </li>
<li>乙用甲的公钥对已经签署的合同进行加密。            </li>
<li>乙将密文发给甲。        </li>
<li>甲用自己的私钥将已签署合同解密。        </li>
<li>解密正确，确认签署。        </li>
</ol>
<p>从以上步骤，我们知道：            </p>
<ol>
<li>用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。        </li>
<li>如果某份密文被解开，那么肯定是密文的目标信息主体解开的。        </li>
<li>私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。        </li>
</ol>
<h3 id="Base64补充"><a href="#Base64补充" class="headerlink" title="Base64补充"></a>Base64补充</h3><hr>
<p>1.Base64简单说明：<br>描述：Base64可以成为密码学的基石，非常重要。<br>特点：可以将任意的二进制数据进行Base64编码<br>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。<br>65字符：A~Z a~z 0~9 + / =<br>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。        </p>
<p>2.命令行进行Base64编码和解码：<br>编码：base64 123.png -o 123.txt<br>解码：base64 123.txt -o test.png -D        </p>
<p>3.Base64编码原理：<br>1)将所有字符转化为<code>ASCII</code>码；<br>2)将ASCII码转化为<code>8</code>位二进制；<br>3)将二进制<code>3</code>个归成一组(不足<code>3</code>个在后边补<code>0</code>)共<code>24</code>位，再拆分成<code>4</code>组，每组<code>6</code>位；<br>4)统一在<code>6</code>位二进制前补两个<code>0</code>凑足<code>8</code>位；<br>5)将补<code>0</code>后的二进制转为十进制；<br>6)从Base64编码表获取十进制对应的Base64编码；    </p>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个<code>24bit</code>的缓冲区中，先来的byte占高位。<br>    b.数据不足<code>3byte</code>的话，于缓冲区中剩下的bit用0补足。然后，每次取出<code>6</code>个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加<code>1</code>个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加<code>2</code>个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。        </p>
<p> 4.在项目中的应用：        </p>
<p>1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持<br>2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。</p>
<p>代码实现：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64EncodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先把字符串转换为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对base64编码后的字符串进行解码</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64DecodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.把二进制数据转换为字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终端测试命令：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n A | base64			</span><br><span class="line">$ <span class="built_in">echo</span> -n QQ== |base64 -D</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据安全&quot;&gt;&lt;a href=&quot;#数据安全&quot; class=&quot;headerlink&quot; title=&quot;数据安全&quot;&gt;&lt;/a&gt;数据安全&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用&lt;code&gt;POST&lt;/code&gt;请求提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>关于委托代理的优化</title>
    <link href="http://yoursite.com/2016/08/20/iOS-delegate_optimized/"/>
    <id>http://yoursite.com/2016/08/20/iOS-delegate_optimized/</id>
    <published>2016-08-20T02:02:04.000Z</published>
    <updated>2016-09-06T06:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><hr>
<p>对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对象间的的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以发生相关事件时通知委托对象。</p>
<p>通常delegate对象中的方法名也一定要起得恰当才行。方法名应该准确描述当前发生的事件以及delegate对象为何要获知此事件。在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样，delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。若没有此信息，则委托对象在同一时间只能执行一套逻辑，这么做不太好。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><hr>
<p>在实现委托模式时，如果协议中的方法是可选得，那么就会写出一大批类似下面的代码来：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_delegate respondsToSelector:@selector(someClassDidSomething:)])</span><br><span class="line">&#123;</span><br><span class="line">	[_delegate someClassDidSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易用代码查出某个委托对象是否能响应特定的选择子，可是如果频繁执行此操作的话，那么除了第一次检测的结果有用之外，后续的检测可能都是多余的。如果委托对象本身没变，那么不太可能会突然响应某个原来不能响应的选择子，也不太会突然无法响应某个原来可以响应的选择子。鉴于此，我们可以把委托对象能否响应某个协议方法这一信息缓存起来，以优化程序效率。</p>
<p>将方法响应能力缓存起来的最佳途径是使用“位段”数据类型，我们可以把结构体中的字段占用的二进制位个数设为一个字节，从而用0和1表示方法是否被响应。</p>
<p>下面举个例子：</p>
<p>在“class-continuation分类”中新增实例变量，这个新增的实例变量是个结构体，用来缓存方法的响应与否。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	unsigned int didReceiveData     : 1;</span><br><span class="line">	unsigned int didFailWithError   : 1;</span><br><span class="line">&#125; _delegateFlags;</span><br></pre></td></tr></table></figure>
<p>这个结构体用来缓存委托对象是否能响应特定的选择子。实现缓存功能所用的代码可以写在delegate属性所对应的设置方法里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)<span class="built_in">set</span>Delegate:(id&lt;GXZNetWorkFetcher&gt;)delegate &#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData   = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</span><br><span class="line">	_delegateFlags.didFailWithError = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，每次调用delegate的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(_delegateFlags.didReceiveData) &#123;</span><br><span class="line">	[_dlegate networkFetcher:self didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相关方法要调用很多次时，值得进行这种优化。而是否需要优化，则应依照具体代码来定。这就需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。如果频繁的通过数据源协议从数据源中获取多份相互独立的数据，那么这项优化技术极有可能就会提高程序效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;委托模式&quot;&gt;&lt;a href=&quot;#委托模式&quot; class=&quot;headerlink&quot; title=&quot;委托模式&quot;&gt;&lt;/a&gt;委托模式&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用AVAudioPlayer遇到的奇葩问题</title>
    <link href="http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/"/>
    <id>http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/</id>
    <published>2016-08-10T13:16:15.000Z</published>
    <updated>2016-08-18T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工<br>具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    </p>
</blockquote>
<p>我开始播放音频的播放代码如下：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br><span class="line">    self.player.numberOfLoops = 0;</span><br><span class="line">    [self.player prepareToPlay];</span><br><span class="line">    self.player.delegate = self;</span><br><span class="line">    [self.player play];</span><br></pre></td></tr></table></figure>
<p>结果开始播放语音的时候，程序始终停在初始化这句：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br></pre></td></tr></table></figure>
<p>在这里你可以手动在Xcode上使程序强制运行过去，这样程序可以正常运行了，没有任何影响，这就奇了怪了。于是我在<font color="green">stackoverflow</font>上找到了一个解决方案:<br><img src="http://upload-images.jianshu.io/upload_images/1389022-a81ead68cba8f0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片">    </p>
<p>原来是我在XCode中设置了全局断点，导致audio无法播放，（但是我这里就有疑问了，同一个工具类为什么我播放IM中录音时没有问题，到这里就有问题了呢？）于是我把全局断点去掉后，程序果断正常运行了。        </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>以后遇到异常终止的情况（<strong>注意</strong>不是出错，可以手动使程序继续正常运行），可以尝试移除全局断点的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工&lt;br&gt;具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>沉痛悼念CSDN博主、年仅26岁的音视频专家雷霄骅</title>
    <link href="http://yoursite.com/2016/08/04/meidia-person/"/>
    <id>http://yoursite.com/2016/08/04/meidia-person/</id>
    <published>2016-08-04T04:30:07.000Z</published>
    <updated>2016-08-04T05:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160804134857626" alt=""></p>
<p>CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7月17日凌晨猝死在学校主楼五层，并于7月23号安葬。据相关报道称，事发前雷霄骅一直泡在实验室忙碌，怀疑其是劳累过度导致猝死。        </p>
<p>CSDN失去了一位亲密的友人，我们失去了一位深受网友爱戴的“雷大神”博主。最初当大家看到这则新闻时，除了不敢相信一再确认外，剩下的只有心痛。众多网友也自发地在多个平台表达了自己的悼念之情。<br><img src="http://img.blog.csdn.net/20160804085950156" alt=""></p>
<p>逝者的博客地址：<a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="external">http://blog.csdn.net/leixiaohua1020</a>,我很久以前就关注了雷神的博客，雷神的文章让我学到了很多东西。        </p>
<p>霄骅的博客为很多人所知，在他的博客上，有这样一段自我介绍「主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。」截止笔者发稿，这一刻CSDN上霄骅的博客数据为：    </p>
<ul>
<li>访问：4354295次</li>
<li>积分：43750</li>
<li>等级：8</li>
<li><p>排名：第52名</p>
</li>
<li><p>原创：375篇</p>
</li>
<li><p>转载：159篇</p>
</li>
<li>译文：28篇</li>
<li>评论：4985条    </li>
</ul>
<p>从此，这些数据将会灰色定格！<br>我们感谢霄骅做出的巨大贡献！而认识雷霄骅，还可以从他的相关专栏和开源项目中做更深入了解：<br>专栏:        </p>
<blockquote>
<p>FFmpeg（135篇）    </p>
<ul>
<li>开源多媒体项目源代码分析（91篇）        </li>
<li>视频质量评价（41篇）</li>
</ul>
</blockquote>
<p>开源项目列表 :            </p>
<blockquote>
<ul>
<li>[SourceForge]：<a href="https://sourceforge.net/u/leixiaohua1020/wiki/" target="_blank" rel="external">https://sourceforge.net/u/leixiaohua1020/wiki/</a><br>[Github]：<a href="http://leixiaohua1020.github.io/" target="_blank" rel="external">http://leixiaohua1020.github.io/</a></li>
<li>TIandSI：本工具用于计算视频的时间信息（TI，也称为时间复杂度），以及空间信息（SI，也称为空间复杂度），以上两个指标取自于ITU-R BT.1788标准。</li>
<li>VideoEye：一个开源的视频分析的软件。本软件可以播放和分析视频数据。它支持多种视频流输入方式：HTTP，RTMP，RTSP以及文件等等。该软件可以实时分析视频流并能以图形化的方式呈现其分析结果。目前该软件还处于完善阶段。</li>
</ul>
</blockquote>
<p>CSDN博客运营人员回忆：“一直以来，与霄骅的接触都在QQ上，第一次见面，是在CSDN老友记的活动上。在我的印象中，他是低调、内敛的男孩，他的笑容很真实，也能打动人，很真诚、乐于帮助别人的一位博客专家。”而霄骅也写了篇小短文做记录，表示不虚此行。        </p>
<p>霄骅在14年5月31日正式成为博客专家，他擅长的技术当时在CSDN上内容还不算很多，所以系列更新一下子吸引了很多人来浏览和讨论。他的博客帮助了很多人，除了在博客上回复大家的问题，以及还有自己的技术交流群，旨在为视音频技术同行方便交流提供一个平台。无论是实验室、电视台、互联网视频、安防、播放器、媒体中心等都可以加入讨论。他认为多交流可以更快的进步~        </p>
<p>乐于分享技术的他，在视音频技术做出了巨大贡献的他，当之无愧地连续两年获得CSDN年度博客之星称号。        </p>
<p>就在今年上半年，CSDN曾邀请霄骅成为其签约作者，当时霄骅提到最近要忙着写毕业设计，工作人员一直在等他忙完这阵子。结果，这个噩耗无情地到来。        </p>
<p>斯人已去，对于霄骅博文出书以及家人号召成立基金会事宜，CSDN表示都会全力支持协助。我们在沉痛悼念霄骅的同时，也呼吁所有技术开发者们，一定要照顾好自己的身体，远离病痛折磨！    </p>
<p>希望天堂里霄骅一切安好！    </p>
<p>希望从事IT行业的人员都要注重身体的健康！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160804134857626&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7
    
    </summary>
    
      <category term="资讯" scheme="http://yoursite.com/categories/%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="media" scheme="http://yoursite.com/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发各种权限问题(相机、录音等)</title>
    <link href="http://yoursite.com/2016/08/02/iOS-authorization/"/>
    <id>http://yoursite.com/2016/08/02/iOS-authorization/</id>
    <published>2016-08-02T09:13:02.000Z</published>
    <updated>2016-08-02T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，直接去调用了，这样会出现问题。        </p>
<h3 id="麦克风权限"><a href="#麦克风权限" class="headerlink" title="麦克风权限"></a>麦克风权限</h3><hr>
<p>我在项目中开发IM的录音功能的时候，没有判断当前APP是否拥有响应的权限，导致录制失败（录制出来是0kb，长度也是0毫秒）。为此我在工具类中，添加了麦克风权限的判断方法，当用户去录音的时候，如果检测到没有响应的麦克风权限，则提示用户到手机的设置页面打开麦克风的权限，当用权限的时候直接录制就可以了。   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecord</span><br><span class="line">&#123;</span><br><span class="line">    __block BOOL bCanRecord = YES;</span><br><span class="line">    <span class="keyword">if</span> ([[[UIDevice currentDevice] systemVersion] compare:@<span class="string">"7.0"</span>] != NSOrderedAscending)</span><br><span class="line">    &#123;</span><br><span class="line">        AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">        <span class="keyword">if</span> ([audioSession respondsToSelector:@selector(requestRecordPermission:)]) &#123;</span><br><span class="line">            [audioSession performSelector:@selector(requestRecordPermission:) withObject:^(BOOL granted) &#123;</span><br><span class="line">                bCanRecord = granted;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> bCanRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相机权限"><a href="#相机权限" class="headerlink" title="相机权限"></a>相机权限</h3><hr>
<p>同样在开发IM的小视屏(和微信小视屏一样)功能的时候也遇到了同样的问题，在没有判断相机权限的前提下，我手动关掉了APP的相机访问权限，则我录制视频的时候的预览页黑乎乎一片，什么也没有，同样没办法录制，这给用户的体验非常差，所以当我们调用系统资源的时候，一定要先判断是否拥有相应的权限。以下是我的判断相机权限的代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecordViedo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *mediaType = AVMediaTypeVideo;</span><br><span class="line">    AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType];</span><br><span class="line">    <span class="keyword">if</span> (authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h3><hr>
<p>其实该权限不去判断也可以，因为当你没有相册权限而去调用本机相册的时候，系统默认会pop出一个提示的页面，提示用户，没有相册权限，去手机的设置页面设置该权限。系统的这个页面还是可以的（不丑），所以我就用了系统的提示页面了。但是我还是在工具类中实现了相册权限的判断，方便以后归类。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)albumAuthority</span><br><span class="line">&#123;</span><br><span class="line">    ALAuthorizationStatus author = [ALAssetsLibrary authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (author == kCLAuthorizationStatusRestricted || author ==kCLAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h3><hr>
<p>当用户用到定位的功能的时候，也涉及到权限的问题，我顺便也实现了该功能权限的判断：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)locationAuthority</span><br><span class="line">&#123;</span><br><span class="line">    CLAuthorizationStatus status = [CLLocationManager authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (kCLAuthorizationStatusDenied == status || kCLAuthorizationStatusRestricted == status) &#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>当我们调用系统资源的时候，一定要先判断是否拥有相应的权限，做到代码的严谨性。        </p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><hr>
<p>扫码关注下面二维码，干货不断：<br><img src="http://img.blog.csdn.net/20160623095054012" alt="二维码"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于死锁的一点总结</title>
    <link href="http://yoursite.com/2016/07/23/iOS-gcd-deadlock/"/>
    <id>http://yoursite.com/2016/07/23/iOS-gcd-deadlock/</id>
    <published>2016-07-23T04:02:04.000Z</published>
    <updated>2016-09-12T10:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。        </p>
<p>例如：     </p>
<p>死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。    </p>
<h3 id="GCD导致死锁的例子"><a href="#GCD导致死锁的例子" class="headerlink" title="GCD导致死锁的例子"></a>GCD导致死锁的例子</h3><hr>
<p>比如下面的这个会产生死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以自己先分析一下该程序产生死锁的原因。    </p>
<p>我们首先要搞清楚<code>同步&amp;异步</code> <code>串行&amp;并发</code>这两组基本概念：    </p>
<blockquote>
<p>同步执行：比如dispatch_sync，这个函数会把一个block加入到指定的队列中，而且会一直等到执行完blcok，这个函数才返回。因此在block执行完之前，调用dispatch_sync方法的线程是阻塞的。        </p>
<p>异步执行：一般使用dispatch_async，这个函数也会把一个block加入到指定的队列中，但是和同步执行不同的是，这个函数把block加入队列后不等block的执行就立刻返回了。</p>
</blockquote>
<p>接下来是”串行和并行”：        </p>
<blockquote>
<p>串行队列：比如dispatch_get_main_queue,这个队列中所有任务，一定按照先来后到的顺序执行。不仅如此，还可以保证在执行某个任务时，在它前面进入队列的所有任务肯定执行完了。对于每一个不同的串行队列，系统会为这个队列建立唯一的线程来执行代码。            </p>
<p>并发队列：比如dispatch_get_global_queue,这个队列中的任务也是按照先来后到的顺序开始执行，注意是开始，但是它们的执行结束时间是不确定的，取决于每个任务的耗时。对于n个并发队列，GCD不会创建对应的n个线程而是进行适当的优化。</p>
</blockquote>
<p>理解清楚上面的两组概念后我们再来分析上面例子产生死锁的原因：        </p>
<p>该程序中在主线程中同步执行<code>dispatch_sync(queue,block)</code>任务，而该任务又被分发到了主线程<code>dispatch_get_main_queue()</code>中，这就产生了问题。程序在执行<code>dispatch_sync(queue,block)</code>时，会阻塞调用线程（在这里是主线程），等待block中的任务执行完后再返回阻塞线程继续进行执行，但是block中的任务在执行的时候又需要在主线程中执行，而现在主线程被阻塞，所以就会产生两者相互等待的情况，死锁就形成了。    </p>
<p>下面对比着总结一下<code>dispatch_sync</code>和<code>dispatch_async</code>的执行流程：        </p>
<p>（1）dispatch_sync的执行流程：</p>
<ul>
<li>将block添加到queue队列中</li>
<li>阻塞调用线程，等待block（）执行结束，回调到调用线程。</li>
</ul>
<p>（2）dispatch_async的执行流程：    </p>
<ul>
<li>将block添加到queue队列中</li>
<li>直接回到调用线程（不阻塞调用线程）,异步执行。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>下面我总结一下关于死锁的一些注意事项：    </p>
<ul>
<li>异步执行一定不会产生死锁，因为异步的执行，block会立刻返回，不会阻塞线程。所以在我们开发过程中如果遇到死锁的问题，很大可能是同步执行的原因，这样可以帮助我们快速定位。</li>
<li>不要把block任务同步派发到调用gcd所在线程的关联队列中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。   
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods更新遇redefinition问题及其它问题汇总</title>
    <link href="http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/"/>
    <id>http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/</id>
    <published>2016-07-11T08:20:30.000Z</published>
    <updated>2016-07-11T10:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。</p>
<h2 id="1、问题环境"><a href="#1、问题环境" class="headerlink" title="1、问题环境"></a>1、问题环境</h2><p>升级时所使用的命令为：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>升级后用”pod –version”查看版本号是0.39.0，升级前的版本我没记错的话应该是0.37.2.</p>
<h2 id="2、Redefinition问题"><a href="#2、Redefinition问题" class="headerlink" title="2、Redefinition问题"></a>2、Redefinition问题</h2><p>升级后遇到的最大的问题就是这个Redefinition问题了，具体情况是我的工作项目中需要增加一个新的pod引用，pod update后编译报出一大堆Redefinition问题，涉及到AFNetworking，SDWebImage等常用库，而以前都好好的，百思不得其解。        </p>
<p><a href="&quot;Redefinition of module X&quot; errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue">“Redefinition of module X” errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue</a>提到了这个问题，但我并不得要领。        </p>
<p>为了这个问题我把Pods文件夹、Podfild.lock文件删除重新更新，甚至把CocoaPods降级到0.38.2以及0.37.2版本都没有解决，然后这个过程中又遇到了其它的问题，问题怎么解决的后面再说。</p>
<p>静下心来再查看这个问题，发现错误日志里还是提供了一些关键要素，能显示重复定义在哪里。因为我一般情况下都是看默认显示在Xcode左侧栏里的错误日志列表就解决，很少展开日志详细信息。这次的关键要素就是在日志详细信息中，然后就发现了一些规律：以AFNetworking为例，我在pch文件中是这样引用的：#import &lt;AFNetworking/AFNetworking.h&gt;，然后在其它文件也做了这样的引用：#import “AFNetworking.h”。这两个引用同时存在就造成了Redefinition，去掉后者的引用方式就可以解决AFNetworking的Redefinition问题了。        </p>
<p>正常情况下肯定是用尖括号那种引用方式，但是由于历史原因，项目中使用后者那种引用方式也有不少，以前也从来没出问题，不知道现在为什么一下子就全部暴露出来了。这一改就要改不少，没办法就只能一个一个改了。        </p>
<blockquote>
<p>后记：根据最新回复，是必须得使用#import &lt; AFNetworking\/AFNetworking.h &gt;这种形式的头文件引用了，应该是检查更严格了。            </p>
</blockquote>
<p><em>我在这里遇到的问题是SDWebImage的Redefinition问题，是在pch中导入了#import &lt; SDWebImage\/UIImageView+WebCache.h &gt;，但是在其他的类中又导入了#import “UIImageView+WebCache.h”，从而引起了Redefinition问题</em>        </p>
<h2 id="3、undefined-method-project’-for-lt-Pod-Installer问题"><a href="#3、undefined-method-project’-for-lt-Pod-Installer问题" class="headerlink" title="3、undefined method `project’ for #&lt;Pod::Installer问题"></a>3、undefined method `project’ for #&lt;Pod::Installer问题</h2><p>旧版本的Podfile在升级Cocoapods后pod install就会遇到这个问题，根据这篇文章，是因为Cocoapods升级到0.38或0.39版本后installer_representation.project.targets.each中的project改名了，变成了pods_project，好在给了一个0.37——0.39都通用的办法，比如原来的Podfile是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line">post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">    installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">            config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>升级后就要改成：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.pods_project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="4、DVTAssertions-ASSERTION-FAILURE问题"><a href="#4、DVTAssertions-ASSERTION-FAILURE问题" class="headerlink" title="4、DVTAssertions: ASSERTION FAILURE问题"></a>4、DVTAssertions: ASSERTION FAILURE问题</h2><p>这是CocoaPods降级到0.37.2后pod install遇到的问题，记忆中当初好像就是因为这个问题而升级到0.39.0版本的。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[MT] DVTAssertions: ASSERTION FAILURE <span class="keyword">in</span> /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-8227/IDEFoundation/Initialization/IDEInitialization.m:590</span><br><span class="line">Details: Assertion failed: _initializationCompletedSuccessfully</span><br><span class="line">Function: BOOL IDEIsInitializedForUserInteraction()</span><br><span class="line">Thread: &#123;number = 1, name = main&#125;</span><br><span class="line">Hints: None</span><br><span class="line">Backtrace:</span><br><span class="line">0 0x000000010462aa5c -DVTAssertionHandler handleFailureInFunction:fileName:lineNumber:assertionSignature:messageFormat:arguments:</span><br><span class="line">1 0x000000010462a1e9 _DVTAssertionHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">2 0x000000010462a455 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">3 0x000000010462a3b7 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">4 0x0000000107191f5c IDEIsInitializedForUserInteraction (<span class="keyword">in</span> IDEFoundation)</span><br><span class="line">5 0x0000000109da8eb9 +PBXProject projectWithFile:errorHandler:<span class="built_in">read</span>Only:</span><br><span class="line">6 0x0000000109daaa3e +PBXProject projectWithFile:errorHandler:</span><br><span class="line">7 0x00007fff8bc68f44 ffi_call_unix64 (<span class="keyword">in</span> libffi.dylib)</span><br><span class="line">Abort <span class="built_in">trap</span>: 6</span><br></pre></td></tr></table></figure>
<p>网上大部分的帖子都说升级CocoaPods，比如这个<a href="https://github.com/CocoaPods/CocoaPods/issues/4209" target="_blank" rel="external">帖子</a>，然而具体问题具体分析好不好，我这个是降级时遇到的问题。</p>
<p>这个问题应该就是与Xcode版本有关了，实际就是与Developer的路径有关。我的Mac上同时存在有Xcode6.1.1版本与Xcode7.0版本，后者是默认的Xcode版本。</p>
<p>当CocoaPods为0.37.2版本时，对应的Developer路径应该是Xcode6.1.1版本的路径，因为这个之前一直都配合使用好好的。那么，就需要用到xcode-select问题了。通过xcode-select -p命令可以查看当前Developer路径，用xcode-select -s可以指定新的Developer路径。</p>
<p>我是这样指定的：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select <span class="_">-s</span> /Applications/Xcode6.1.1.app/Contents/Developer</span><br></pre></td></tr></table></figure>
<p>然后这个问题就不复存在了。注意当有必要使用CocoaPods 0.39.0版本时，必须得切换回来，要不然还是会遇到这个问题        </p>
<h2 id="5、CocoaPods多版本共存问题"><a href="#5、CocoaPods多版本共存问题" class="headerlink" title="5、CocoaPods多版本共存问题"></a>5、CocoaPods多版本共存问题</h2><p>本来我是想降级的，结果CocoaPods好像默认就是多版本共存了，比如我原来本来是0.37.2版本，用了本文开头的升级命令升级后，虽然用pod –version看是0.39.0版本，但是0.37.2版本并没有删除。这个可以用下面的命令查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem list --local | grep cocoapods</span><br></pre></td></tr></table></figure>
<p>如果你的只有一个版本，你可以再安装一个CocoaPods 0.38.2版本或者其它版本试试。比如安装0.38.2版本的命令就是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 0.38.2</span><br></pre></td></tr></table></figure>
<p>说是共存了，但到底是怎么共存使用呢？就比如说我的CocoaPods默认版本是0.39.0，有一个项目要用0.37.2版本的CocoaPods该怎么用呢？        </p>
<p><a href="http://stackoverflow.com/questions/28130938/how-to-switch-cocoapods-or-other-gem-version-on-command-line/28140522#28140522" target="_blank" rel="external">这里</a>有人提供了这样的一个方法，但我没有细研究，也没实践，需要用到rbenv：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rbenv global 2.1.0</span><br><span class="line">gem install cocoapods -v 0.34.4</span><br><span class="line">rbenv global 2.0.0-p0</span><br><span class="line">gem install cocoapods -v 0.33.1</span><br></pre></td></tr></table></figure>
<p>步骤:        </p>
<ul>
<li>在项目根目录下创建Gemfile，指定CocoaPods版本    </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">'~&gt; 0.37.2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行bundle install命令</li>
</ul>
<p>****************这是华丽丽的分割线o(╯□╰)o******************</p>
<p>我是在原<a href="http://www.jianshu.com/p/ee32eef74ba9" target="_blank" rel="external">文章</a>的基础上做了些许改动,总结了自己遇到的一些问题。</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之HTTPS</title>
    <link href="http://yoursite.com/2016/06/27/iOS-security-https/"/>
    <id>http://yoursite.com/2016/06/27/iOS-security-https/</id>
    <published>2016-06-27T01:42:55.000Z</published>
    <updated>2016-09-20T16:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能，屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS。        </p>
<h3 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h3><hr>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版，HTTPS = HTTP + SSL/TLS。即在HTTP下加入了SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。HTTPS的信任基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）,因此该网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。（苹果官网是强制安装证书的,不会询问用户）。</p>
<blockquote>
<p>HTTPS和HTTP的区别主要为以下四点：        </p>
</blockquote>
<p>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。        </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>如果是自己使用NSURLSession来封装网络请求，涉及代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line">   <span class="built_in">NSURLSessionDataTask</span> *task =  [session dataTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com"</span>] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [task resume];</span><br></pre></td></tr></table></figure></p>
<p>下面我们实现代理方法，在代理方法中处理证书。如果你的请求是HTTP而不是HTTPS是不走该代理方法的：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 我们需要在该方法中告诉系统, 是否信任服务器返回的证书</span><br><span class="line"> Challenge: 挑战 质问 (包含了受保护的区域)</span><br><span class="line"> protectionSpace : 受保护区域</span><br><span class="line"> NSURLAuthenticationMethodServerTrust : 证书的类型是 服务器信任</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span>, <span class="built_in">NSURLCredential</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断服务器返回的证书类型, 是否是服务器信任</span></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         NSURLSessionAuthChallengeUseCredential = 0,                   使用证书</span><br><span class="line">         NSURLSessionAuthChallengePerformDefaultHandling = 1,          忽略证书(默认的处理方式)</span><br><span class="line">         NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,   忽略书证, 并取消这次请求</span><br><span class="line">         NSURLSessionAuthChallengeRejectProtectionSpace = 3,      拒绝当前这一次, 下一次再询问</span><br><span class="line">         */</span></span><br><span class="line">        <span class="built_in">NSURLCredential</span> *card = [[<span class="built_in">NSURLCredential</span> alloc]initWithTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeUseCredential</span> , card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是使用<code>AFN</code>框架，那么我们不需要做任何额外的操作，AFN内部已经做了处理。但是对于对于自制证书的网站还需要进行一些设置：        </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line"><span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line"><span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line"><span class="comment">// 假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"><span class="comment">// 置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line"><span class="comment">// 如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 如果就是CA证书，则不需要设置上面两项，正常使用AFN即可</span></span><br><span class="line">[manager GET:url parameters:<span class="literal">nil</span> progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</span><br><span class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">	 <span class="comment">// 请求成功</span></span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>虽然HTTPS相比于HTTP来说，会有一定的性能上的劣势，但对于网络飞速发展，移动设备的性能成倍增长的今天，安全才是我们更应该去考虑的。全网HTTPS并不是那么遥远。        </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>继承的陷阱</title>
    <link href="http://yoursite.com/2016/06/20/iOS-inherit-trap/"/>
    <id>http://yoursite.com/2016/06/20/iOS-inherit-trap/</id>
    <published>2016-06-20T04:16:35.000Z</published>
    <updated>2016-09-02T02:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。</p>
<p>在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文件中去声明，而是直接在.m文件中去实现，也许为了区分，还会为方法加上类似于”xx_”这样的前缀，如图1所示，以这种方式定义”私有方法“。</p>
<p>但这只是一种障眼法，在外部调用时，确实是看不到，如果我们直接调用这些方法，编译器会报错，但如果用performSelector:来调用，依然可以正常执行。</p>
<p>上面这种问题通常可以避免。一个潜藏的问题是出现在继承体系里面。如果父类和子类的.m文件定义了两个同名的”私有方法“，则子类的方法会覆盖父类的方法，这样我们可能会在不经意间修改了父类的一些实现。</p>
<p>在继承第三方非开源库中的类时，如果遇到这种情况，会是一种很淡疼的感觉，那样你只能修改自己的方法名了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。&lt;/p&gt;
&lt;p&gt;在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift实现导航栏头像大小渐变和导航栏颜色渐变</title>
    <link href="http://yoursite.com/2016/04/12/iOS-ChangeNavImg/"/>
    <id>http://yoursite.com/2016/04/12/iOS-ChangeNavImg/</id>
    <published>2016-04-12T11:12:50.000Z</published>
    <updated>2016-08-17T06:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>github地址: <a href="https://github.com/corderguo/ChangeNavTitleImage" target="_blank" rel="external">https://github.com/corderguo/ChangeNavTitleImage</a><br>本文地址: <a href="http://coderperson.com/2016/04/12/iOS-ChangeNavImg/" target="_blank" rel="external">http://coderperson.com/2016/04/12/iOS-ChangeNavImg/</a><br>欢迎转载，请注明出处，谢谢。</p>
</blockquote>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://img.blog.csdn.net/20160702190808768" alt=""></p>
<h3 id="创建tableView"><a href="#创建tableView" class="headerlink" title="创建tableView"></a>创建tableView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 我是以懒加载的形式创建</span><br><span class="line">private lazy var tableView: UITableView = &#123;</span><br><span class="line">        <span class="built_in">let</span> tableView = UITableView(frame: self.view.bounds)</span><br><span class="line">        tableView.dataSource = self</span><br><span class="line">        tableView.delegate   = self</span><br><span class="line">        <span class="built_in">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">// 以extension的形式遵循代理 并在其中实现代理方法</span><br><span class="line">extension ViewController : UITableViewDataSource,UITableViewDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>协议的写法，不需要写&lt;&gt;        </li>
<li>刚遵循完协议的时候会报错，不用担心，那是因为还没实现代理方法</li>
<li>Swift中的懒加载和OC中的懒加载区别还是挺大的</li>
</ul>
<p>这里要注意，我是在viewDidLoad方法中注册cell的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableView.registerClass(UITableViewCell.self, <span class="keyword">for</span>CellReuseIdentifier: ID)</span><br></pre></td></tr></table></figure>
<h3 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">let</span> cell = tableView.dequeueReusableCellWithIdentifier(ID, <span class="keyword">for</span>IndexPath: indexPath)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"骚客--\(indexPath.row):http://coderperson.com"</span></span><br><span class="line">        <span class="built_in">return</span> cell</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止我们的基本界面搭建完成了，下面就是关键部分了。</p>
<h3 id="自定义titleView"><a href="#自定义titleView" class="headerlink" title="自定义titleView"></a>自定义titleView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义imageView的属性，用来操控图片的大小改变</span><br><span class="line">var imageV : UIImageView?</span><br><span class="line">// 创建</span><br><span class="line"><span class="built_in">let</span> titleV : UIView = UIView()</span><br><span class="line">navigationItem.titleView = titleV</span><br><span class="line">imageV = UIImageView(frame: CGRectMake(0, 0, 70, 70))</span><br><span class="line">imageV?.image = UIImage(named: <span class="string">"100.jpg"</span>)</span><br><span class="line">imageV?.layer.cornerRadius = 35</span><br><span class="line">imageV?.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">imageV?.center = CGPointMake(titleV.center.x, 0)</span><br><span class="line">titleV.addSubview(imageV!)</span><br></pre></td></tr></table></figure>
<p>这里不要自己单独向navigationBar上添加子控件，只需要修改titleView即可</p>
<h3 id="监听偏移量"><a href="#监听偏移量" class="headerlink" title="监听偏移量"></a>监听偏移量</h3><p>这里通过监听偏移量，实现的大小缩放动画<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        </span><br><span class="line">        // 偏移量，相对于contentView，你也可以不加scrollView.contentInset.top，即相对scrollView，然后适当调整即可</span><br><span class="line">        <span class="built_in">let</span> offsetY = scrollView.contentOffset.y + scrollView.contentInset.top</span><br><span class="line">        var scale:CGFloat = 1.0</span><br><span class="line">        <span class="keyword">if</span> offsetY &lt; 0  // 下拉</span><br><span class="line">        &#123;</span><br><span class="line">            scale = min(1.5, 1.0 - offsetY / 300.0) // 300值可以自己调整</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> offsetY &gt; 0</span><br><span class="line">        &#123;</span><br><span class="line">            // 为了防止缩小过度，给一个最小值为0.45，其中0.45 = 31.5 / 70.0，表示</span><br><span class="line">            // 头像最小是31.5像素</span><br><span class="line">            scale = max(0.45, 1 - offsetY / 300);</span><br><span class="line">        &#125;</span><br><span class="line">        // 保证缩放后y的坐标不会改变</span><br><span class="line">        imageV?.transform = CGAffineTransformMakeScale(scale, scale)</span><br><span class="line">        var frame = imageV?.frame</span><br><span class="line">        frame?.origin.y = -(imageV?.layer.cornerRadius)! / 2.0</span><br><span class="line">        imageV?.frame = frame!</span><br><span class="line">        </span><br><span class="line">        // 导航栏颜色渐变</span><br><span class="line">        changeNavColor(offsetY)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>单独抽出来的颜色渐变的方法<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private func changeNavColor(offsetY:CGFloat) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> offsetY &gt;= 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> offsetY &lt; 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0 - -offsetY / 300.0</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止你已经可以看到自己想要的效果了。        </p>
<p>Done！</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：      </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/corderguo/ChangeNavTitleImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/corde
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS中block的Strong-Weak Dance的思考</title>
    <link href="http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/"/>
    <id>http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/</id>
    <published>2016-03-24T02:10:18.000Z</published>
    <updated>2016-08-25T09:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak Dance”。        </p>
<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><hr>
<p>这是一种 强引用 –&gt; 弱引用 –&gt; 强引用 的变换过程。在弄明白为什么要如此大费周章之前，我们首先来看看一般的写法会有什么问题。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法可以避免循环引用，但是我们要考虑这样的问题：    </p>
<p><strong>假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 wself 是一个弱引用，因此会自动变为 nil。而在 KVO 中，这会导致崩溃。</strong>    </p>
<h3 id="Strong-Weak-Dance"><a href="#Strong-Weak-Dance" class="headerlink" title="Strong-Weak Dance"></a>Strong-Weak Dance</h3><hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    __strong __typeof(wself) sself = wself; // 强引用一次</span><br><span class="line">    [sself.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一来，self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁。        </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><hr>
<p>在和小伙伴的讨论过程中，他提出了几个问题。虽然都不难，但是有利于把各种知识融会贯通起来。</p>
<p>1.Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof(wself) sself = wself;</span><br></pre></td></tr></table></figure>
<p>A：会的。引用计数描述的是对象而不是指针。这句话的意思是：        </p>
<blockquote>
<p>sself 强引用 wself 指向的那个对象</p>
</blockquote>
<p>因此对象的引用计数会增加一个。</p>
<p>2.Q：block 内部定义了sself，会不会因此强引用了 sself？<br>A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题。<br>3.Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> __weak MyViewController *wself = self;</span><br><span class="line">wself.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wself) &#123; // 只有当 wself 不为 nil 时，才执行以下代码</span><br><span class="line">        [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了。</p>
<p>4.Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了。</p>
<p>A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行。另外，如果执行一个为 nil 的闭包会导致崩溃。        </p>
<p>5.Q：如果在执行 block 的过程中，block 被释放了怎么办？        </p>
<p>A：简单来说，block 还会继续执行，但是它捕获的指针会具有不确定的值，详细内容请参考<a href="http://stackoverflow.com/questions/12272783/what-happens-when-a-block-is-set-to-nil-during-its-execution" target="_blank" rel="external">这篇文章</a>    </p>
<h3 id="strongify-和-weakify"><a href="#strongify-和-weakify" class="headerlink" title="@strongify 和 @weakify"></a>@strongify 和 @weakify</h3><hr>
<p>这是<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> 中定义的一个宏。一般可以这样使用：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文并非分析它们的实现原理，所以就简单解释两点：        </p>
<ol>
<li><p>这里的“@”没有任何用处，仅表示强调，这个宏实际上包含了一个空的 AutoreleasePool，这也就是为什么一定要加上“@”。        </p>
</li>
<li><p>它的原理还是和之前一样，生成了一段形如 __weak MyViewController *wself = self; 这种格式的代码：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define rac_strongify_(INDEX, VAR) \\</span></span><br><span class="line">__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</span><br></pre></td></tr></table></figure>
<h3 id="Swift-中的情况"><a href="#Swift-中的情况" class="headerlink" title="Swift 中的情况"></a>Swift 中的情况</h3><hr>
<p>在 Swift 中也有 Strong-Weak Dance 的概念。最简单的方法就是直接沿用 OC 的思路：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">        /// ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法的缺点在于，我们不能写 if let self = self，因此需要重新定义一个变量 strongSelf，命名方式显得不够优雅。            </p>
<p>除此以外还可以使用 Swift 标准库提供的函数 withExtendedLifetime：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    withExtendedLifetime(self) &#123;</span><br><span class="line">        /// ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点在于，self 依然是可选类型的，还需要把它解封后才能使用。        </p>
<p>最后，还有一种解决方案是自定义 withExtendedLifetime函数：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Optional &#123;</span><br><span class="line">    func withExtendedLifetime(body: T -&gt; Void) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">            body(strongSelf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这种写法是否更加优雅，就见仁见智了：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    self.withExtendedLifetime &#123;</span><br><span class="line">        /// 这里用 <span class="variable">$0</span> 表示 self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于YYKit中block的细节"><a href="#关于YYKit中block的细节" class="headerlink" title="关于YYKit中block的细节"></a>关于YYKit中block的细节</h3><hr>
<p>下面是YYCache中的一段代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)_trimRecursively &#123;</span><br><span class="line">    __weak typeof(self) _self = self;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        __strong typeof(_self) self = _self;</span><br><span class="line">        <span class="keyword">if</span> (!self) <span class="built_in">return</span>;</span><br><span class="line">        [self _trimInBackground];</span><br><span class="line">        [self _trimRecursively];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：         </p>
<p>如果直接引用 strong self，那 block 创建时就会立刻强引用了 self；而如果先用 weak 引用，则 block 创建时对 self 是弱引用，而直到 block 开始执行时，self 才会被强引用。    </p>
<p>如果 block 提交到 queue 但还未执行的时候，整个 Cache 对象被释放了，那这时 weak self 就会变为 nil 了，而后 block 执行的时候 if (!self) return; 就会成立了。            </p>
<p>非常严谨！！！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><hr>
<p><a href="http://www.jianshu.com/p/4ec18161d790" target="_blank" rel="external">http://www.jianshu.com/p/4ec18161d790</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="block" scheme="http://yoursite.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发环境配置</title>
    <link href="http://yoursite.com/2016/03/20/reactNative-configure/"/>
    <id>http://yoursite.com/2016/03/20/reactNative-configure/</id>
    <published>2016-03-20T02:11:11.000Z</published>
    <updated>2016-08-26T02:46:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h3><hr>
<p>1.安装Homebrew:        </p>
<p>Homebrew是OS X的套件(包)管理器，我们可以通过它获取并且安装很多组件<br>安装方式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>2.安装npm 和 Node.js:        </p>
<p> Node.js最好安装4.0及其以上更高版本，node安装成功后npm自动也就有了，直接下载安装Node.js，网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a>        </p>
<p>3.安装WatchMan:</p>
<p>该插件用于监控bug文件和文件变化 ，并且可以触发指定的操作.        </p>
<p>安装方式:        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>4.安装Flow:</p>
<p>flow是一个JavaScript的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误.            </p>
<p>安装方式:                </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure>
<h3 id="React-Native安装"><a href="#React-Native安装" class="headerlink" title="React Native安装"></a>React Native安装</h3><hr>
<p>1.安装React Native：                    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>iOS开发环境需求:Xcode 7 及其以上更高版本.</p>
<h3 id="React-Native的第一个应用"><a href="#React-Native的第一个应用" class="headerlink" title="React Native的第一个应用"></a>React Native的第一个应用</h3><hr>
<p>1.执行命令,生成一个工程：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init 项目名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:由于众所周知的网络原因，需要等待一段时间（具体视网络情况而定）。react-native命令行从npm官方源拖代码时会遇上麻烦，可以将npm仓库源替换为国内镜像：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>
<p>2.目录结构分析:    </p>
<p>a）默认生成android和ios两个平台的原生项目；            </p>
<p>b）其中，index.android.js和index.ios.js文件为Android和iOS的空壳应用文件；</p>
<p>c）此外，node_modules文件夹，是为Node.js存放和管理npm包资源，也包含React Native框架文件。    </p>
<h3 id="管理React-Native库的版本"><a href="#管理React-Native库的版本" class="headerlink" title="管理React Native库的版本"></a>管理React Native库的版本</h3><hr>
<p>1.查看本地的React Native库的版本                               </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native --version</span><br></pre></td></tr></table></figure>
<p>2.更新本地的React Native的版本                   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>3.查询react-native的npm包最新版本                    </p>
<p>npm包地址 ：<a href="https://www.npmjs.com/package/react-native" target="_blank" rel="external">https://www.npmjs.com/package/react-native</a>         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react-native</span><br></pre></td></tr></table></figure>
<p>4.升级或者降级npm包的版本：                        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native@0.18</span><br></pre></td></tr></table></figure>
<p>5.更新项目templates文件（可选）：                 </p>
<p>新的npm包会包含更新在运行react-native init命令生成的一些动态文件，例如init创建项目的时候会生成iOS和Android的子项目，我们可以通过以下的命令进行获取最新的代码         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native upgrade</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境需求&quot;&gt;&lt;a href=&quot;#环境需求&quot; class=&quot;headerlink&quot; title=&quot;环境需求&quot;&gt;&lt;/a&gt;环境需求&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.安装Homebrew:        &lt;/p&gt;
&lt;p&gt;Homebrew是OS X的套件(包)管理器，我们可以通
    
    </summary>
    
      <category term="ReactNative" scheme="http://yoursite.com/categories/ReactNative/"/>
    
    
      <category term="RN" scheme="http://yoursite.com/tags/RN/"/>
    
  </entry>
  
</feed>
