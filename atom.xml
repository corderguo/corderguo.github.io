<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客</title>
  <subtitle>菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-27T10:56:29.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React|Redux技术点</title>
    <link href="http://yoursite.com/2020/06/10/web-react_redux%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <id>http://yoursite.com/2020/06/10/web-react_redux技术点/</id>
    <published>2020-06-10T12:14:10.000Z</published>
    <updated>2020-06-27T10:56:29.970Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/corderguo/corderguo.github.io/blob/master/images/react%E6%8A%80%E6%9C%AF%E7%82%B9.jpg?raw=true" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/corderguo/corderguo.github.io/blob/master/images/react%E6%8A%80%E6%9C%AF%E7%82%B9.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>创业说</title>
    <link href="http://yoursite.com/2019/08/23/business/"/>
    <id>http://yoursite.com/2019/08/23/business/</id>
    <published>2019-08-23T11:54:08.000Z</published>
    <updated>2019-08-23T12:42:06.135Z</updated>
    
    <content type="html"><![CDATA[<p>一个互联网产品从0到1，从创意到落地，需要经历的过程十分漫长、艰辛，按照“风险-收益模型”，互联网创业要么获得高额回报，要么可以收获极大的教训。</p>
<p>在经历几个创业项目（千万级风投）的失败后，我果然收获了极大的教训。</p>
<blockquote>
<p>为了对项目内容进行保密，下文以 A、B、C 表示笔者参与过的三个互联网项目。</p>
</blockquote>
<h2 id="试错？"><a href="#试错？" class="headerlink" title="试错？"></a>试错？</h2><p>这几年，试错心理在互联网创业中普遍存在，也经常看到一些文章说，不要站着不动，去试，哪怕是错的，这种想法是十分有害的，在一个资金有限的创业团队里，一错可能就万劫不复。</p>
<p>根据笔者的观察，大部分的试错行为，本质其实是<strong>产品没想透</strong>，一些团队做产品时十分着急，恨不得马上能出来，产品没有经过严谨的推理流程，最后发现产品存在严重不符合商业逻辑，功能满足的是自己的需求，而非用户，便推卸责任，美其名曰——试错。</p>
<blockquote>
<p>A项目的推进中，我们的产品没有经过很严谨地推理，产品来源于创始人的想法，产品经理火急火燎地出了原型，外包承接，就开始了，后来产品出来后，开始发现产品存在很多问题，开始改版，之前定下的推广计划基本上作废，团队浪费了几个月的时间。</p>
</blockquote>
<p>很多错，是不需要试的，放下浮躁，冷静、严谨地思考产品与方向才是王道，当团队开始有试错的想法，可能就已经错了。</p>
<h2 id="不要打断研发"><a href="#不要打断研发" class="headerlink" title="不要打断研发"></a>不要打断研发</h2><p>产品诞生的前期，研发是主力，团队的重心应该80%放在研发团队上，通过严谨推理与讨论，确定下版本后，必须按着研发的计划走。</p>
<p>在这个过程中，最常犯错的是CEO，尤其是有很强控制欲的CEO，经常会对研发“指手画脚”，运营在此阶段也经常会热心提出很多意见与新功能，这本是一个好事情，但是技术人员一般会对进度过于乐观，低估时间，胡乱答应功能，最终时间赶，隐藏Bug多，所以除非存在严重的事故或相当紧急的事情，否则，请暂时压制住你满腔的热情，留到下一个版本中，打乱研发节奏，损失的将是未来数个版本。</p>
<blockquote>
<p>A项目，产品着急地开始，在我加入团队前，产品就已经开始研发，中途发现很多功能没有想透，开始修改，修改后影响到了很多之前的产品逻辑，而因为修改，花费了大量时间，研发时间节点不肯推迟，那么最终这些影响并没有被很好的发现，后续版本为之十分头疼，而带着问题的版本发布出来，其实也只是给大众留下不好的第一印象与业界嘲笑罢了。</p>
</blockquote>
<p>一开始就能理解并克制自己是很难的，通常要经过好几次项目失败后，才能深刻理解这一点，就在于这笔学费团队能不能承受。</p>
<p><strong>从一开始就充分讨论清楚业务，不要等中途再来做大量修改，充分给予研发团队时间，新发现的需求，应该交由专人整理归纳，筛选后与下一版本开发。</strong></p>
<h2 id="团队毒瘤"><a href="#团队毒瘤" class="headerlink" title="团队毒瘤"></a>团队毒瘤</h2><p>很多创业团队在团队上想得过于简单，忽略了人这个不确定性因素，在打江山时期，只有靠谱的人，最终做出来的产品才会靠谱，大公司有管理体系压着，创业公司制度是不完善的，人有问题，说毒瘤并不为过，因为Ta对团队的伤害十分巨大。</p>
<blockquote>
<p>B项目时期，老板大方，团队也积极有活力，但是团队中存在若干团队毒瘤，最终导致一个估时不长的项目，花了接近一年才上线。</p>
</blockquote>
<p>这些团队毒瘤都有些什么特征呢？</p>
<blockquote>
<p><strong>自私</strong><br>方便我一个，其它我不理，如果听到这种言论的话，不用犹豫，请他离开团队，尤其是研发团队中，B项目的延误大部分就是因为存在这样的人。</p>
<p><strong>负能量</strong><br>团队中，总会有那么一两个人，什么事情都要吐槽，遇到难题总想逃避，在项目没按自己的想法推进时，就一直散播这样下去会XXX的言论。在A项目中，后期大量人员离职就是因为这样的人，也因此，项目最终结束了。</p>
<p><strong>求安稳</strong><br>有些人，上班只是为了安稳地生活，有些人，不要让Ta进入你的团队，因为创业团队没办法提供足够多的福利，并且比一般公司要辛苦得多，他们终将转化为自私者与负能量者。</p>
<p><strong>能力弱</strong><br>能力弱与没经验是两个完全不同的概念，但在应届生身上很难区分，但是一旦发现能力存在问题，换人，能力与职位不匹配是最大的悲剧，对双方都有伤害，慈不掌兵。</p>
</blockquote>
<p><strong>在HR招聘的时候，就必须严格地进行把关，千军易得，一将难求！</strong></p>
<h2 id="坚定方向"><a href="#坚定方向" class="headerlink" title="坚定方向"></a>坚定方向</h2><p>在三个项目中，我一直在思考一个问题，一个CEO应该做些什么，有人说是战略，有人说统筹，而最终我观察得到的结果却是：<strong>坚定团队的方向，并在成员动摇的时候，告诉他，没问题！</strong></p>
<p>所以团队坚定方向是很重要的，然而，失败的团队经常会存在更换方向的事情，比如</p>
<blockquote>
<p><strong>场景一</strong><br>CEO：这个产品我觉得没搞头，我们换一个方向；</p>
<p><strong>场景二</strong><br>CEO：我们帮其他公司做一个产品，这样我们可以获得XX资源；</p>
<p><strong>场景三</strong><br>CEO：上线后研发应该也不忙了，我找一些外包项目来给你们做；</p>
</blockquote>
<p>一个团队，拼了命去做一个产品，都未必能做好，何况顾左右而言他？</p>
<p><strong>没准备好不要开始，准备好了就专注地坚持下去</strong></p>
<h2 id="打磨产品"><a href="#打磨产品" class="headerlink" title="打磨产品"></a>打磨产品</h2><p>在创业团队中，经常会有这样的一个声音：</p>
<blockquote>
<p>我们先做这几个功能做了，先上线嘛，功能可以慢慢完善</p>
</blockquote>
<p>如果你是用户，你第一次接触一个App时觉得它很简陋，功能缺胳膊少腿，你后续还会关注它吗？</p>
<p>打磨产品这个最重要的事情总是被遗忘，当你面临这样一个选择时</p>
<blockquote>
<p>A、花1个月时间开发一个新功能<br>B、花1个月时间完善现有功能，改善用户体验</p>
</blockquote>
<p>你会选择哪一个？</p>
<p>其实功能并不是越多越好，每个阶段的推广基本上只能围绕一个功能点，那是否把每个要推广的功能点的体验做好，流程做完善，功能做妥当，才是最重要的事情？</p>
<p>End.</p>
<blockquote>
<p>这是一篇转载的文章，读完之后想到自己在创业公司的经历，非常理解作者在创业过程中的心酸和无奈。文中提到的问题基本是创业公司普遍存在的问题，每一个问题都有可能导致项目的难产。千军易得，一将难求，创业起步时合适的人才真的太重要了。</p>
<p>原文链接：<a href="https://www.jianshu.com/p/3cec5079e7b3" target="_blank" rel="external">这里</a> 。</p>
</blockquote>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个互联网产品从0到1，从创意到落地，需要经历的过程十分漫长、艰辛，按照“风险-收益模型”，互联网创业要么获得高额回报，要么可以收获极大的教训。&lt;/p&gt;
&lt;p&gt;在经历几个创业项目（千万级风投）的失败后，我果然收获了极大的教训。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了对
    
    </summary>
    
      <category term="人文" scheme="http://yoursite.com/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="人文" scheme="http://yoursite.com/tags/%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift中枚举和可选项的细节</title>
    <link href="http://yoursite.com/2019/08/15/ios_enum_detail/"/>
    <id>http://yoursite.com/2019/08/15/ios_enum_detail/</id>
    <published>2019-08-15T07:13:02.000Z</published>
    <updated>2019-08-23T12:43:01.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>打印枚举成员默认输出的是其本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br><span class="line">var dir = Direction.west</span><br><span class="line">print(dir)  //输出为： west</span><br></pre></td></tr></table></figure>
<p>原始值：枚举成员可以预先设置相同类型的默认值，这个默认值就叫做原始值。使用rawValue获取其原始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Grade : Character &#123;</span><br><span class="line">    case perfect = &quot;A&quot;</span><br><span class="line">    case great = &quot;B&quot;</span><br><span class="line">    case good = &quot;C&quot;</span><br><span class="line">    case bad = &quot;D&quot;</span><br><span class="line">&#125;</span><br><span class="line">var good = Grade.good</span><br><span class="line">print(good)   // good</span><br><span class="line">print(good.rawValue) // C</span><br><span class="line">print(Grade.great.rawValue) // B</span><br></pre></td></tr></table></figure>
<p>注意：原始值不占用枚举变量的内存。</p>
<p>如果枚举的原始值类型是<code>Int</code>、<code>String</code>，Swift会自动分配原始值。<code>Int</code>默认的原始值从0递增，<code>String</code>默认的原始值是枚举成员的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction : String &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br><span class="line">print(Direction.south)  // south</span><br><span class="line">print(Direction.south.rawValue) // south</span><br></pre></td></tr></table></figure>
<p>关联值：有时将枚举的成员值跟其他类型的值关联存储在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Score &#123;</span><br><span class="line">    case points(Int)</span><br><span class="line">    case grade(Character)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var score = Score.points(99)</span><br><span class="line">score = .grade(&quot;A&quot;)</span><br><span class="line">switch score &#123;</span><br><span class="line">case let .points(i):</span><br><span class="line">    print(i)</span><br><span class="line">case let .grade(i):</span><br><span class="line">    print(i)     // A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归枚举：枚举成员的关联值类型是其自身。在使用递归枚举时，前方必须有<code>indirect</code>关键字修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">indirect enum ArithExpr &#123;</span><br><span class="line">    case number(Int)</span><br><span class="line">    case sum(ArithExpr, ArithExpr)</span><br><span class="line">    case difference(ArithExpr, ArithExpr)</span><br><span class="line">&#125;</span><br><span class="line">let five = ArithExpr.number(5)</span><br><span class="line">let four = ArithExpr.number(4)</span><br><span class="line">let two = ArithExpr.number(2)</span><br><span class="line">let sum = ArithExpr.sum(five, four)</span><br><span class="line">let diff = ArithExpr.difference(sum, two)</span><br><span class="line"></span><br><span class="line">func calculate(_ expr:ArithExpr) -&gt; Int &#123;</span><br><span class="line">    switch expr &#123;</span><br><span class="line">    case let .number(value):</span><br><span class="line">        return value</span><br><span class="line">    case let .sum(left, right):</span><br><span class="line">        return calculate(left)+calculate(right)</span><br><span class="line">    case let .difference(left, right):</span><br><span class="line">        return calculate(left)-calculate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(calculate(diff))  // 7</span><br></pre></td></tr></table></figure>
<p><strong>下面分析一下枚举的内存</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Password &#123;</span><br><span class="line">    case number(Int,Int,Int,Int)</span><br><span class="line">    case other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个<code>Int</code>占<code>32</code>个字节，然后需要注意的是<code>case other</code>，由于<code>other</code>没有内容，系统会分配给它一个字节的内存空间用来标记它， 所以实际需要的内存为<code>33</code>个字节，另外由于内存对齐参数是<code>8</code>字节，所以分配的占用空间为<code>40</code>。</p>
<p>MemoryLayout可以获取数据类型占用的内存大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var pwd = Password.number(1, 4, 5, 9)</span><br><span class="line">pwd = .other</span><br><span class="line">MemoryLayout.stride(ofValue: pwd)  // 40</span><br><span class="line">MemoryLayout.size(ofValue: pwd)    // 33</span><br><span class="line">MemoryLayout.alignment(ofValue: pwd) // 8</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>Bool</code>类型的内存对齐参数是<code>1</code>。</p>
<p>还需要注意下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">    case test,test1,test2,test3</span><br><span class="line">&#125;</span><br><span class="line">// 这里只需要一个字节就可以标记出来这四个枚举成员</span><br><span class="line">var t = TestEnum.test</span><br><span class="line">MemoryLayout.stride(ofValue: t) // 1</span><br><span class="line">MemoryLayout.size(ofValue: t)   // 1</span><br><span class="line">MemoryLayout.alignment(ofValue: t) // 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">    case test</span><br><span class="line">&#125;</span><br><span class="line">var t = TestEnum.test</span><br><span class="line">MemoryLayout.stride(ofValue: t) // 1</span><br><span class="line">MemoryLayout.size(ofValue: t)   // 0   </span><br><span class="line">MemoryLayout.alignment(ofValue: t) // 1</span><br></pre></td></tr></table></figure>
<p><em>MemoryLayout.size(ofValue: t) 为什么它的值是0呢？？？</em> </p>
<p>因为该枚举类型只有一个成员，所以使用枚举变量的起始地址就可以表示(标记)这个仅有的枚举成员了，因此不需要单独分配内存去标记了，所以size为0。</p>
<p>再看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum &#123;</span><br><span class="line">    case test(Int)</span><br><span class="line">&#125;</span><br><span class="line">var t = TestEnum.test(10)</span><br><span class="line">MemoryLayout.stride(ofValue: t) // 8</span><br><span class="line">MemoryLayout.size(ofValue: t)   // 8   </span><br><span class="line">MemoryLayout.alignment(ofValue: t) // 8</span><br></pre></td></tr></table></figure></p>
<p>实际只需要占用的空间是8，而不是8+1，因为只有一个枚举成员，不需要单独的一个字节去区分枚举成员，因此实际占用和分配的空间都是8。</p>
<p><strong>原始值不占用内存空间，关联值占用枚举的内存</strong>。上面看了关联值的内存例子了，下面看看原始值的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum TT:Int &#123;</span><br><span class="line">    case test=1,test1,test2,test3</span><br><span class="line">&#125;</span><br><span class="line">let t = TT.test</span><br><span class="line">MemoryLayout.stride(ofValue: t) // 1</span><br><span class="line">MemoryLayout.size(ofValue: t)   // 1</span><br><span class="line">MemoryLayout.alignment(ofValue: t) // 1</span><br></pre></td></tr></table></figure>
<p>因为原始值的具体值是枚举变量通过 <code>rawValue</code> 获取到的，所以并不需要在枚举内存中存储。</p>
<p>而关联值，每个枚举变量对应的关联值都是后来赋值的，不同枚举变量的关联值可能是不同的，所以需要存储在枚举变量的内存中。</p>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><p>一个主意的细节： <code>nil</code> 强制解包会报错。但是 <code>Optional(Opational(nil))</code>强制解包后为<code>Optional(nil)</code> ，因此不会报错。</p>
<p>空合并运算符??的运算规则：</p>
<blockquote>
<p>a ?? b</p>
<p>a 是可选项</p>
<p>b是可选项或者不是可选项</p>
<p>b跟a的存储类型必须相同</p>
<p>如果a不为nil，就返回a</p>
<p>如果a为nil，就返回b</p>
<p>如果b不是可选项，返回a时会自动解包</p>
</blockquote>
<p>多重可选项需要注意的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num1:Int? = 10</span><br><span class="line">var num2:Int?? = num1</span><br><span class="line">var num3:Int?? = 10</span><br><span class="line">print(num2 == num3)  // true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num1:Int? = nil</span><br><span class="line">var num2:Int?? = num1</span><br><span class="line">var num3:Int?? = nil</span><br><span class="line">print(num2 == num3)  // false</span><br></pre></td></tr></table></figure>
<p>第二个结果是 <code>false</code>  因为num3本身是空的nil，但是num2并不是空的，可以表示成Opational(nil)。</p>
<p>那么num1和num3是否相等呢？</p>
<p>当然是不相等的，因为他们本身的类型就不一样，一个是Int?，一个是Int?? 。</p>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>



]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;打印枚举成员默认输出的是其本身。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>毛衣战启示录</title>
    <link href="http://yoursite.com/2019/08/09/tradewar/"/>
    <id>http://yoursite.com/2019/08/09/tradewar/</id>
    <published>2019-08-09T13:00:08.000Z</published>
    <updated>2019-08-23T12:43:35.541Z</updated>
    
    <content type="html"><![CDATA[<p>中美毛衣战已经持续一年多时间了，自己也一直在关注事情的进展，里面有些事情感觉还是挺有意思的。</p>
<p>首先明确一点，中国的经济体制是具有中国特色的社会主义市场经济，这里的重点是前缀”<strong>特色</strong>“。中国的市场经济活跃在”特色”这双大手之下，市场跟着政策走，因此中国市场也被称为<strong>政策市</strong>。</p>
<p>毛衣问题除了增加巨额关税外，影响最大的是美方切断了高科技行业核心部件对中国的出口，导致中国很多公司在整个产业链上都出现了问题。中兴通讯在核心部件被禁后不得不停工，便是典型的例子。</p>
<p>中低端制造扎堆，产能过剩，高端制造和高科技核心技术严重落后，是中国面临的一道严峻考验，也是毛衣战暴露出来的最大问题。</p>
<p>其实中国之前早已经意识到这个问题，并且也在尝试引导市场改变这种状况。</p>
<p>我记得头两年中国在环保这块抓得很紧，出台了很多政策。当时大家的想法也很简单，国家重视环保，保护环境，努力为我们营造一个青山绿水的家园，感觉挺不错。但是现在想想这背后还有一层重要的意思：去产能。这是国家供给侧改革重要的一环，淘汰一些低端制造，促进资源的合理分配，以便达到经济结构调整的目的。</p>
<p>毛衣站只是提前了这个问题暴露的时间而已。</p>
<p>前两个月政府也出台了一些政策，要大力发展农村市场。在当前动荡的国际形势下，作为世界中低端加工厂，中国在出口问题上遇到了很大的挑战，偌大的农村市场希望能承担部分产能。</p>
<p>毛衣问题也警醒了我们发展科技的重要性。今年以来，相关政策密集出台，给科技企业减税，降低科技企业融资门槛等等，让更多的钱流入科技行业。反应到二级市场，投资结构也跟随着发生了变化，之前在大消费抱团的资金，纷纷调仓换股到了科技行业，这也造成了科技板块远远跑赢了上证指数。</p>
<p>同时老大亲自开口成立了科创板，降低了很多科技企业的上市门槛。在全球经济退潮期，可能很多企业晚几年上市融资，就被退潮的大浪淹没倒闭了。而且后续很多相关政策对这些科创公司的发展都会起到很大的促进作用。这也表明了国家大力发展科技产业的决心。即便是用钱砸也要砸出来几个像样的科技公司。</p>
<p>要想大力发展某个产业，除了政策的密集支持，还要有源源不断的热钱涌入，这样才能支撑这个产业不断走牛。这就像美股的十年牛市和中国房地产的十年牛市一样，都是源源不断的真金白银支撑起了他们的走势。</p>
<p>那么热钱从哪来呢？当然是从房地产市场出来。</p>
<p><strong>我认为中国房价目前已经是阶段顶部了</strong>。之前支撑房价上涨的逻辑是什么：城镇化建设，造成大量人员移居城市，而且在经济滑坡时，房地产是政府有效的刺激经济的手段，当房价上涨之后，外边滞留的大量资金不断流入形成正向反馈，助推房价不断走高。但是当前的经济环境和市场背景我找不到支撑房价上涨的有效逻辑。人口数量下滑和老龄化加剧，城市闲置大量空房，国家对房价炒作的不断打压，银行提高了房企的贷款门槛，房产税政策也不断的被提上日程，这些都是阻碍房价上涨的有利条件。而且雄安新区作为公租房推行的一个重要试点，如果效果显著，那么公租房政策的推行也是房价上涨的强大阻力。当房价停止上涨后，外部的热钱需要寻找新的投资方向，没有现金流的支撑，房价上涨也就失去了基础动力。</p>
<p>市场密集出台的普惠科技行业的政策，给市场流动的资金提供了方向，政治觉悟永远要摆到第一位。</p>
<p>当然最最重要的一点是，最新一届中央政治局会议再次强调，坚持房子是用来住的、不是用来炒的定位，落实房地产长效管理机制，<strong>不将房地产作为短期刺激经济的手段</strong>。</p>
<p>看懂这一条就够了。</p>
<p>房地产毕竟是政府重要的经济来源，科技行业的发展需要大量的时间研究才会有成果，经济结构改革的过程必然是艰难曲折的，但是我相信在滚滚大势面前，<strong>一切反动派都是纸老虎</strong>！</p>
<p>毛衣期间发生过一件特别搞笑的事情。之前双方老大在日本会面谈过之后，紧张局势得到很大的缓和，但是后来，特朗普说中国没有按照协议购买美国农产品，所以继续增加额外的关税，两边局势又变的十分紧张。当日外交部发言人说中国有购买美国的农产品，指责特朗普是颠倒黑白，无中生有。两边各执一词，搞的吃瓜群众也不知道具体情况是怎么样的，作为一名共产党员，我也是强烈谴责特朗普的。后来看了具体原因，忍不住捧腹大笑：”因为要增加关税，所以美国农产品在市场上的价格不占优势，因此导致订单没有成交”。O(∩_∩)O~，不知道你有没有get到其中的笑点。</p>
<p>最近美国把中国认定为“灰绿”操纵国，毛衣战已经扩散为金融战。人民币“灰绿”破7，香港台湾问题不断，中国面临内外前所未有的挑战，但是我仍然坚信，<strong>一切反动派都是纸老虎</strong>！</p>
<p>中国，加油！</p>
<p>最后以我最想表达的观点作为结语：</p>
<p>毛衣战是特朗普对沉睡的东方雄狮的一记当头棒喝，虽然很疼，但是狮醒了！</p>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>





]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中美毛衣战已经持续一年多时间了，自己也一直在关注事情的进展，里面有些事情感觉还是挺有意思的。&lt;/p&gt;
&lt;p&gt;首先明确一点，中国的经济体制是具有中国特色的社会主义市场经济，这里的重点是前缀”&lt;strong&gt;特色&lt;/strong&gt;“。中国的市场经济活跃在”特色”这双大手之下，市
    
    </summary>
    
      <category term="投资" scheme="http://yoursite.com/categories/%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="投资" scheme="http://yoursite.com/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>股市风云录</title>
    <link href="http://yoursite.com/2019/07/22/stock_market/"/>
    <id>http://yoursite.com/2019/07/22/stock_market/</id>
    <published>2019-07-22T13:00:08.000Z</published>
    <updated>2019-08-23T12:44:13.738Z</updated>
    
    <content type="html"><![CDATA[<p>首先在投资中需要明确一点，股价的涨跌是有资金推动的，股价上涨是真金白银堆起来的，因此千万不要随意抄底一些在底部不动的股票。一定要相信你肉眼看到的，不要相信自己脑子YY的。这是很多人会犯的错误，因此开篇点出来。</p>
<p>进入正题，那么我们如何根据日常生活中看到的听到的遇到的事情，发现投资机会呢？</p>
<p><strong>5G </strong></p>
<p>去年以来，我们就能看到关于5G方面的各种新闻，”什么是5G”,”5G有多快”，”哪家公司要生产5G手机了”等等，从这些日常新闻中我们可以看出，5G时代马上要来临了。</p>
<p>也就是这个时候，A股迎来了关于5G投资的产业升级主升浪。只要是5G相关的科技股，基站，频谱，电缆，孪生切片等等，凡是和4G5G技术沾边的公司都会迎来一波大涨。这波5G主升浪迎来了一只全市场总龙头，一只许多年不曾见到的十倍股：东方通信。有”东方不败””东方大帝”之称的东方通信从开始的4元用了三个月时间猛涨到41元，暴涨十倍。</p>
<p>巴菲特有句耳熟能详的名言：在别人恐惧的时候贪婪，在别人贪婪的时候恐惧。他在经济危机的时候赌的是美国的国运，投资的包括大金融银行，大消费可口，战略资源石油等。只要美国经济复苏他就能赚得盆满钵满。（中国股市十年了还在三千点徘徊）。</p>
<p>其实在这波5G疯狗浪过程中也能看到在A股也可以说在股市中的另一条真理：<em>在别人贪婪的时候你要更贪婪，在别人恐惧的时候你要更恐惧</em>。</p>
<p>东方大帝起初的时候也是一波三折，公司公告说没有5G相关技术，证监会发布关注函防止股价暴涨等等。但是这个时候已经没人管了，资本都是逐利的，贪婪的，巨大的赚钱效应，不断刺激场外的资金源源不断的进入。在这个过程中就看谁更贪婪。</p>
<p><strong>创投</strong></p>
<p>去年老大提出了个科创板，号称对标美股纳斯达克指数。老大亲自提出的板块，和雄安一样横空出世的大题材。饥渴躁动的资金四处寻觅哪些公司可能在该板块上市，那么拥有它股份的当前上市公司，就会开启一波暴涨。 资金纷纷挂起了隔夜单。</p>
<p>其中市北高新一口气12个涨停 直接三倍多，关键是资金的利用率，只需要12个交易日，简单直接高效。创投概念在这期间正式开启了一波疯狗浪。 市北高新后来二波又涨了3倍  一共暴涨六倍多。在二波的时候起来的人民网涨了4倍，当时我是十分看好它的，后来公司发布澄清公告加上市场环境比较弱，资金出逃就夭折了。  </p>
<p><strong>大麻</strong></p>
<p>美国通过了大麻商用合法化的法案，美股Tilray一个月暴涨十倍，是一个月十倍，太恐怖了。因为这是一块没开垦过的蛋糕，在资本市场这简直有无限可能。美股的大麻概念开启了疯狗浪。中国股市也看到这个投资机会，刚好这个时候，顺灏股份在中国取得了大麻商用牌照，暴涨了八倍。这个时候，一波一波的说要投资大麻的公司出现，纷纷发公告称公司成立了大麻项目部，研究大麻商用，好，你的股票涨涨涨。有些公司，只是发个公告在某个小区的某个房间成立的大麻项目或者子公司，其实就是个空壳子，股票照样涨涨涨。更有甚者，公司是生产麻袋的，跟麻字沾边，股票照样跟着涨（至于后来的价值回归，这里不提）。</p>
<p>中国股市很多时候跟着美股的一些投资逻辑，比如最近的人造肉公司BeyondMeat，很多知名大佬投资（比尔盖茨），上市一月股价暴涨近六倍。中国股市那些人造肉公司也跟着涨了一波。</p>
<p><strong>毛衣战</strong></p>
<p>这个时候想到的肯定是芯片公司，中国的芯片公司要得到政府的大力扶持，中国当自强，也要靠芯片，好了，涨涨涨。</p>
<p>重点说一下中兴通信。被美国封杀后，核心技术被断，公司停业，股价闪崩，八个跌停板，资金想出都出不来，之前的大白马，30块钱跌到将近10块钱，瞬间让价值投资者亏出了底裤。</p>
<p>这个时候你估计是不敢买该公司的股票了。但是很多厉害的投资者，却能发现这次难得的投资机会，抄底中兴通讯，并且这次抄底非常成功，这个效应在投资市场被称为<strong>戴维斯双杀</strong>。为什么敢抄底呢。大家想想。</p>
<p>同样是被美国封杀，中兴通信放假，华为加班，为什么，因为中兴通讯是中国特色社会主义的伟大产物：国有企业。不怕，有国家在背后撑腰，后面关于很多5G的项目都会给了它，照样还是一个活蹦乱跳的巨婴。现在股价已经涨回当初的价格了。很多大佬或者机构，当时都割肉了。而且关于毛衣站，历史经验告诉我们这会是一个漫长的边打边谈最后达到某种平衡的结果。</p>
<p>毛衣战打到今年，国家资源部发表了一个声明，要整顿稀土行业。这个时候你看到了什么。国家<strong>可能</strong>要用稀土反制美国了。</p>
<p>中国是稀土出口大国，战略资源，制造大型武器和高科技产品的必备物，虽然美国的稀土资源全球靠前，但是由于污染环境，他们根本不开采，基本全部是进口。</p>
<p>这个时候稀土股票不用说了，涨涨涨，涨了一波涨不动了之后，重磅消息来了，老大去了江西，参观了一家公司：金力永磁，就是开采稀土的，这个时候用屁股想也知道，这家公司的股票全靠抢了，一口气10个涨停，一共涨了三倍多，注意可是连着涨的，不到一个月三倍，太厉害了，稀土相关的股票接着涨涨涨。后来由于涨的太高，涨不动了，获利盘太多，没人愿意去接盘，这个时候资金又想到了一招，港股一家公司“中国稀土”，是个垃圾企业，一个仙股，拥有一个好名字，一天直接涨了70%，直接刺激A股稀土股票接着涨了一波，不过这个时候已经上涨乏力，是资金跑路的时候了。</p>
<p><strong>猪瘟</strong></p>
<p>全球猪瘟，你发现了什么投资机会。</p>
<p>这个时候猪都快死光了，很多投资者肯定会认为这些养猪的企业股票要跌了，赶快跑路吧。但是恰恰相反，养猪企业直接开启一波疯狗浪，很多上市的养猪公司的股票翻了好几倍，正邦科技从底部起来直接翻了六倍，大股东大笔减持股票套现也阻挡不了股价的上涨。</p>
<p>背后的投资逻辑是什么呢？ 中小型养殖场纷纷倒闭，大型上市公司养殖企业抓紧融资扩张。养殖业从以前的周期股转变成了成长股。并且中国是全球猪肉需求大国，进口猪肉完全填补不上这个巨大的空缺，在供不应求的情况下，未来猪价肯定会暴涨，现在已经跳涨一波了，企业只要保证出栏量，那么未来大幅盈利是必然的。</p>
<p>你还发现其它投资逻辑了吗？就是<strong>鸡肉替代</strong>。</p>
<p>猪肉少了，猪瘟影响了猪肉的流通，但是鸡肉不影响，那么很多地方肯定增加了鸡肉的流动量和需求量，对应的鸡肉公司的盈利肯定暴涨，所以在这期间，养鸡公司也跟着开启了一波暴涨。养鸡公司益生股份刚刚公布的半年报又是整长将近百分之三千。</p>
<p>中间有个奇葩的事情，国外几十年都研究不出来的猪瘟疫苗，中国农业部只用了几个月就说研究出来了，太神奇了，后来又说只是临床初级阶段，还没效果。不管成没成，牛皮先吹出去再说，反正也没人相信它能成。</p>
<hr>
<p>几个典型的投资机会先说到这里。还是忍不住感叹美国的十年长牛，那个K线太漂亮了。记得当初人民网还是证券报来着说过一句话：美股泡沫越来越大，中国股市越来越有投资价值。涨的多就是泡沫，跌的多就是有价值，这是有多厚的脸皮才能说出这样buyaolian的话啊。</p>
<p>最后送给大家一个<strong>盈利秘诀</strong>。在中国股市如何能在一个月内从一万做到两万翻倍呢？只需要中间再向自己的账户冲十万。</p>
<p>今天还有一件历史大事，大大亲自点名的科创板开市了，25家公司当日平均涨140%，最高的涨幅520%。</p>
<p>这场击鼓传花的游戏，你准备好了吗？！</p>
<blockquote>
<p>文章中出现的投资观点或逻辑，仅供参考。入市有风险，投资需谨慎！</p>
</blockquote>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>











]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先在投资中需要明确一点，股价的涨跌是有资金推动的，股价上涨是真金白银堆起来的，因此千万不要随意抄底一些在底部不动的股票。一定要相信你肉眼看到的，不要相信自己脑子YY的。这是很多人会犯的错误，因此开篇点出来。&lt;/p&gt;
&lt;p&gt;进入正题，那么我们如何根据日常生活中看到的听到的遇
    
    </summary>
    
      <category term="投资" scheme="http://yoursite.com/categories/%E6%8A%95%E8%B5%84/"/>
    
    
      <category term="投资" scheme="http://yoursite.com/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI尝鲜</title>
    <link href="http://yoursite.com/2019/07/05/ios_swiftui_taste/"/>
    <id>http://yoursite.com/2019/07/05/ios_swiftui_taste/</id>
    <published>2019-07-05T11:12:04.000Z</published>
    <updated>2019-08-19T12:05:36.765Z</updated>
    
    <content type="html"><![CDATA[<p>一个星期前苹果推出了SwiftUI这个全新的UI框架。《SwiftUI尝鲜》是我在公司移动端内部分享的一个课题，在这里整理一下分享的大致结构和PPT内容。            </p>
<h2 id="SwiftUI简介"><a href="#SwiftUI简介" class="headerlink" title="SwiftUI简介"></a>SwiftUI简介</h2><p>2019年 WWDC 大会上，苹果宣布了基于Swift的全新的UI开发框架-SwiftUI，让开发者用更少的代码编写相同的UI，开发体验有了很大的提升。</p>
<p>声明式语法</p>
<p>learn one, apply anywhere</p>
<p>实时预览</p>
<p>缺点：目前最低支持iOS13。</p>
<h2 id="目前UI开发面临的挑战"><a href="#目前UI开发面临的挑战" class="headerlink" title="目前UI开发面临的挑战"></a>目前UI开发面临的挑战</h2><p>从 iOS SDK 2.0 开始，UIKit 已经伴随广大 iOS 开发者经历了接近十年的风风雨雨。</p>
<p>UIKit 提供的是一套符合直觉的，基于控制流的命令式的编程方式。</p>
<p>负面影响：Controller 承担了绝大部分职责，如果没有妥善管理，会导致状态管理越来越复杂，难以控制。</p>
<h2 id="声明式界面开发方式"><a href="#声明式界面开发方式" class="headerlink" title="声明式界面开发方式"></a>声明式界面开发方式</h2><p>声明式的意思就是让我们描述我们需要一个什么样的界面，而不是告诉计算机一步一步要干什么。</p>
<p>比如：如果我们需要添加一个“Hello World”的标签，对于传统的UIKit，它需要负责“创建label”, “设置文字”， “将其添加到view上”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let label = UILabel()</span><br><span class="line">    label.text = &quot;Hello World&quot;</span><br><span class="line">    view.addSubview(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应的，使用SwiftUI我们只需要告诉SDK我们需要一个文字标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">    Text(&quot;Hello World&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SwiftUI开发实战"><a href="#SwiftUI开发实战" class="headerlink" title="SwiftUI开发实战"></a>SwiftUI开发实战</h2><p>通过开发下面的功能，了解SwiftUI的具体使用。</p>
<p>这是分享的重点内容。</p>
<p><img src="https://github.com/corderguo/corderguo.github.io/blob/master/images/swiftui_demo.jpg?raw=true" alt=""></p>
<h2 id="SwiftUI-vs-Flutter"><a href="#SwiftUI-vs-Flutter" class="headerlink" title="SwiftUI vs Flutter"></a>SwiftUI vs Flutter</h2><p>声明式语法</p>
<p>Flutter跨平台性更强，SwiftUI更能兼容平台特性</p>
<p>SwiftUI代码更为简洁</p>
<p>Flutter更成熟</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个星期前苹果推出了SwiftUI这个全新的UI框架。《SwiftUI尝鲜》是我在公司移动端内部分享的一个课题，在这里整理一下分享的大致结构和PPT内容。            &lt;/p&gt;
&lt;h2 id=&quot;SwiftUI简介&quot;&gt;&lt;a href=&quot;#SwiftUI简介&quot; cla
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>2018年度总结</title>
    <link href="http://yoursite.com/2019/01/10/life-2018/"/>
    <id>http://yoursite.com/2019/01/10/life-2018/</id>
    <published>2019-01-10T09:59:10.000Z</published>
    <updated>2019-08-23T12:46:11.896Z</updated>
    
    <content type="html"><![CDATA[<p>转眼2018年已经过去了，年龄越大时间过的越快。这一年是有趣的一年，平平淡淡的湖面下，活跃着自己一颗跳动的心。</p>
<p>今年是深入投资的一年，虽然投资的结果比较惨淡，但是对应的给自己带来的收获却是千金难买的。</p>
<p>之前一直在玩的基金今年也没玩了，于是就定投了部分，放在那里不看了，引起不了自己的兴趣。</p>
<p>17年是比特币爆火的一年，自己涉足这块的时候已经是在山顶开始漫漫熊途了。17年底只是轻仓试玩。18年年初已经开始重金杀入了。从波段到杠杠，以一个小菜鸟的身份玩的不亦乐乎。虚拟货币的暴涨暴跌也反应在了自己的心态上，完全没有自己的交易模式和交易理念。那个时候仿佛着魔了一般，走着路经常看着行情，被对象说了好多次，惭愧惭愧。</p>
<p>对应的中国股市，2018也是一熊到底。那个时候学习网上很多人的价值投资，都是以巴菲特为例子，但是很多人都误解了价值投资的定义，在中国股市搞价值投资，无异于小时候玩过的挖地雷游戏，动不动就是一个雷。长生生物，乐视，中兴通讯，康得新等等等等，让“价值投资”的人轻轻松松倾家荡产。</p>
<p>每种投资模式在不同的阶段和在不同性格的人身上都会发挥很重要的作用，只是这种方式目前还不适合我而已。</p>
<p>从价值投资到投机到波段到潜伏到超短，这一路下来磕磕绊绊，黑灯瞎火的摸索，短短几个字承载了自己太多的心血。</p>
<p>悲伤，迷茫，痛苦，绝望，希望，喜悦，既然选择了这里，这里的一切都是对你的磨练。</p>
<p>功夫不负有心人。这一年对交易对投资有了更深入的认识，也总算是找到了自己的交易模式和原则。</p>
<p><strong>投资</strong>不仅仅是指交易，而是一种生活态度和看待问题的方式。这是我的一点拙见。</p>
<p>有点扯远了~</p>
<p>工作上，今年一直在做自己最喜欢的证券软件的开发，而且产品形式和特点非常有趣，非常棒。自己工作的内容刚好是自己特别爱好的事情，这是一件多么幸运的事情啊。感恩！</p>
<p>而且工作中也遇到了很多非常厉害的同事，从他们身上也学到了很多。</p>
<p>年中的时候学习了<code>python</code> ，后来耽搁了，已经快还回去了。接下来要好好学习学习。</p>
<p>生活上，可能自己变懒了吧，参加朋友的聚会越来越少了。天气暖和的时候，晚上还和同事一块打打球，进入冬天后就没怎么运动了。重点是：女朋友把我从120斤的小伙养成了140来斤的中年大叔~~。</p>
<p>和喜欢的人一起牵手迎接来了2018，又一起迎来了2019，这种感觉，真好。</p>
<p>===================</p>
<p>展望2019：</p>
<p>要坚持锻炼身体。</p>
<p>努力提高技术能力。</p>
<p>规划两次远途旅游，读万卷书也要行万里路。</p>
<p>2019，充满未知充满忐忑充满挑战充满希望的又一年又来了。</p>
<p>恩，已经来了。</p>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>



]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼2018年已经过去了，年龄越大时间过的越快。这一年是有趣的一年，平平淡淡的湖面下，活跃着自己一颗跳动的心。&lt;/p&gt;
&lt;p&gt;今年是深入投资的一年，虽然投资的结果比较惨淡，但是对应的给自己带来的收获却是千金难买的。&lt;/p&gt;
&lt;p&gt;之前一直在玩的基金今年也没玩了，于是就定投了
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计(看这一篇就够了)</title>
    <link href="http://yoursite.com/2018/12/25/iOS-OOD/"/>
    <id>http://yoursite.com/2018/12/25/iOS-OOD/</id>
    <published>2018-12-25T13:52:50.000Z</published>
    <updated>2019-08-24T07:12:50.744Z</updated>
    
    <content type="html"><![CDATA[<p>最近在团队内部组织了一场面向对象的分享会，做了部分内容整理。      </p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>1.在OO设计中，属性和行为都包含在一个对象中；而在过程式程序设计中，属性和行为是分开的，它把程序的内容分为数据和操作数据的操作两部分，这种编程方式的核心问题是数据结构和算法的开发和优化。</p>
<blockquote>
<p>也就是说，在结构化设计中，数据和过程通常是分离的，有时数据时全局的，多个函数都可以访问全局数据，说明对数据的访问是非受控而且不可预测的，这给测试和调试带来了很多困难。而对象技术可以解决这些问题，它将数据和行为合并到一个完备的包中。</p>
</blockquote>
<p>2.面向过程是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物（对象）在解决整个问题步骤中的行为。</p>
<p>例如五子棋系统的开发：</p>
<p><img src="https://github.com/corderguo/gxz/blob/master/wuzhiqi.jpg?raw=true" alt="五子棋"></p>
<blockquote>
<p>面向过程的设计思路就是首先分析问题的步骤：</p>
<ol>
<li>开始游戏</li>
<li>黑子先走</li>
<li>绘制画面</li>
<li>判定输赢</li>
<li>轮到白子</li>
<li>绘制画面</li>
<li>判定输赢</li>
<li>返回步骤2</li>
<li>输出最后结果</li>
</ol>
<p>把上面每个步骤分别用函数实现，问题就解决了。</p>
<p>而面向对象的设计原则是从另外的思路来解决问题。整个五子棋可以分为：</p>
<ol>
<li>黑白双方（玩家对象），这两方的行为是一模一样的</li>
<li>棋盘系统(对象)，负责绘制画面</li>
<li>规则系统(对象)，负责判定诸如犯规、输赢等。</li>
</ol>
<p>玩家对象负责接受用户输入，并告知棋盘对象棋子布局的变化，棋盘系统对象接收到棋子的变化负责在屏幕上显示出变化，同时利用规则系统对象来对棋局进行判定。</p>
</blockquote>
<p>可以看出，面向对象是以<strong>功能</strong>来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图功能的统一。</p>
<p>功能上的统一保证了面向对象的可扩展性。</p>
<blockquote>
<p>比如要加入悔棋的功能，在面向过程的设计中，从输入到判定到显示这一连串的步骤都要改动，甚至整体上要进行大规模的改动。假如是面向对象设计的话，只用改动棋盘对象就行了，棋盘对象保存了黑白双方的棋谱，简单的回溯就可以了，而其他地方则不用改动，改动的只是局部。</p>
</blockquote>
<p>到这里可以很明显的看出面向对象和面向过程的区别了。</p>
<p><strong><em>面向过程向面向对象的演进：</em></strong></p>
<p>在结构化编程中，人们发现把某种数据结构和用于操纵它的各种操纵绑定到一起会非常方便，如果对抽象数据类型进一步的抽象，会发现这种数据类型的实例会成为一个具体的东西、事物、对象，这就引发了人们对编程过程中怎么看待处理问题的一次大的改变。经过不断的发展，人们处理问题的思考的方式不再是怎样的数据结构描述问题，而是直接考虑各个对象之间的关系。这就出现了现在的面向对象开发。</p>
<p>====================================================================</p>
<h3 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h3><p>面向对象三大核心要素：<strong>封装、继承、多态</strong>。</p>
<p><strong>封装</strong></p>
<p>通过把属性和方法合并到一个实体中，这在OO术语称为<strong>封装</strong>。可以再不影响使用的情况下改变类的内部实现。同时限制对某些属性或方法的访问，保护类内部数据。</p>
<blockquote>
<p>比如<code>Math</code>对象中有两个整数<code>intA</code> 和<code>intB</code>，同时有一个<code>sum()</code>方法将这两个整数相加求和，通过封装处理，限制其它对象对<code>Math</code>对象中数据的访问，这样的好处是你无须知道两个数的和是如何计算的。采用这种设计方法，我们可以改变<code>Math</code>对象计算两个数的和的方法，而不需要修改调用者的逻辑。你想要的只是两个数的和，并不关心它是如何计算的。</p>
</blockquote>
<p><strong>接口</strong></p>
<p><strong>接口</strong>是对象间通信的基本途径。在面向对象设计中，要尽可能多地隐藏数据。</p>
<p>public方法和属性才属于接口。</p>
<p>设计类是要遵循最小接口原则：</p>
<ol>
<li>只有在用户需要的时候才增加接口。</li>
<li>只为用户提供他们确实需要的东西，这意味着类的接口尽可能少。</li>
<li>从用户角度设计类，而不要从信息系统的角度进行设计。应该从易于用户使用的角度考虑。</li>
<li>确保设计类时与将真正使用这个类的人（不只是开发人员）反复考虑过需求和设计。</li>
</ol>
<p>设计接口的时候要使用<strong>抽象思维</strong>：OO程序设计的主要优点之一是类可以重用。一般地，可重用类的接口往往更抽象而不是更具体。具体接口通常比较特定，而抽象的接口更为一般。（通常如此）。</p>
<p>所以我们在设计接口的时候，要想充分利用OO带来的好处，我们就需要设计高度抽象的用户接口。</p>
<blockquote>
<p>例如：创建了一个出租车对象，有一个<em>载我去机场</em> 的接口比诸如<em>左转、右转、启动、停车</em> 等单独的接口更好用。</p>
</blockquote>
<p>对属性的访问加以控制，一旦出现问题，就不必操心去跟踪可能改变该属性的每一段代码，它只会在一个地方改变（即设置方法中）。从安全性的角度看，也不希望无控制的代码修改或获取敏感数据。</p>
<p><strong>构造函数</strong>(如果一个方法与所在类同名，而且没有提供任何返回类型，则这个方法就是一个特殊的方法。oc是以init开头)</p>
<p>通常把构造函数作为类的入口点，构造函数非常适合完成初始化和准备工作。其中初始化属性是构造函数完成的一个常见功能，能确保应用处于一种稳定的状态。</p>
<p>一般经验是，总是应该提供一个构造函数，即使你不打算在其中做任何事情。可以先提供一个构造函数，其中不包含任何内容，等以后补充。使用编译器提供的默认构造函数尽管从技术上没什么问题，但是最好清楚地知道你的代码到底是怎样的。比如一个属性默认初始化为0，当这个属性用作除法运算时，就会出现不稳定的情况。</p>
<p><strong>类名</strong></p>
<p>类名相当重要，类名可以描述类本身，它提供了这个类做什么以及它与更大系统如何交互的有关信息。见名知意才是比较好的类名设计。</p>
<h3 id="类设计指导原则"><a href="#类设计指导原则" class="headerlink" title="类设计指导原则"></a>类设计指导原则</h3><ol>
<li><p>真实世界系统建模。</p>
<blockquote>
<p>面向对象程序设计的主要目标之一就是类似于人们真正的思维方式对真实世界的系统建模。这种思想的妙处在于，类能够对真实对象以及这些对象与其他真实对象如何交互进行建模。比如<code>Cat</code>和<code>Dog</code>类都是对真实世界的实体建模。</p>
</blockquote>
</li>
<li><p>明确最小公共接口，并隐藏实现。</p>
<blockquote>
<p>为用户提供简洁和有用的功能。并对用户隐藏实现细节。</p>
</blockquote>
</li>
<li><p>设计健壮的构造函数。</p>
</li>
<li><p>在类中设计错误处理。</p>
<blockquote>
<p>每个系统都会遇到不可遇见的问题。设计类时，开发人员应该要预计可能出现的错误，并包含一些代码，从而在真正遇到这种错误时处理这些情况。</p>
<p>一般经验是，应用绝对不能崩溃。遇到错误时，系统应当自行修正并继续，或者妥善地退出，不要丢失任何对用户重要的数据。</p>
</blockquote>
</li>
<li><p>设计时充分考虑重用。</p>
<blockquote>
<p>对象可以在不同系统中重用，因此编写代码时应当充分考虑重用。设计类时应当做周全的考虑，尽可能想到所有可能性。</p>
</blockquote>
</li>
<li><p>设计时充分考虑可扩展性。</p>
<blockquote>
<p>比如在设计<code>Person</code> 类的时候，应当只包含一个人特定的数据和行为。这样其他类派生该类时，继承其适当的数据和行为，而不会夹杂其它不属于该类的数据或行为。</p>
<ol>
<li><p>抽出不可移植的代码</p>
<ul>
<li>指的是将这些不可移植的代码单独放在一个类中，或者至少单独放在一个方法中（一个可以覆盖的方法）。</li>
</ul>
</li>
<li><p>让作用域尽可能的小</p>
<ul>
<li>这与抽象和将实现隐藏的概念是紧密相关的。这种思想是尽可能将属性和行为置于局部。采用这种方式，维护、测试和扩展类就会容易得的。</li>
</ul>
</li>
<li><p>类应当对自己负责</p>
<ul>
<li><p>所有的对象都应当尽可能的自行负责自己的行为。举个例子：</p>
<p>假如有个<code>Shape</code>类，有一个<code>print</code> 打印形状的接口，如果你想打印圆形该如何处理呢。这里可以利用多态把<code>Circle</code> 类归到 <code>Shape</code> 类中，<code>Shape</code> 知道应该如何自行打印。如果再扩展其它形状也就很好扩展。（多态是一种非常好的解耦合方式）</p>
</li>
</ul>
<p><img src="https://github.com/corderguo/gxz/blob/master/uml_shape.png?raw=true" width="250" height="250" alt=" " align="center"></p>
</li>
</ol>
</blockquote>
</li>
</ol>
<ol>
<li><p>设计时充分考虑可维护性</p>
<blockquote>
<p>设计类的过程要求你将代码组织到多个可管理的部分中。单独的代码段往往比更大的代码更可维护。为了提高可维护性，一定要减少相互依赖的代码，降低类的耦合度。</p>
</blockquote>
</li>
</ol>
<p><strong>多态</strong> </p>
<p>不同类的对象对同一消息作出不同的响应就叫多态。也可以简单理解为：父类指针指向子类对象。多态是面向对象的重要特征，可以帮助我们消除类之间的耦合关系。</p>
<p>Shape的例子</p>
<h3 id="利用对象设计好的系统"><a href="#利用对象设计好的系统" class="headerlink" title="利用对象设计好的系统"></a>利用对象设计好的系统</h3><p>一个可靠的OO设计往往包括以下步骤：</p>
<ol>
<li>完成适当的分析</li>
<li>建立一份描述系统的工作陈述</li>
<li>从这个工作陈述中收集需求</li>
<li>开发一个用户界面原型</li>
<li>明确类</li>
<li>确定各个类的职责</li>
<li>确定各个类如何相互交互</li>
<li>创建一个高层模型来描述要构建的系统</li>
</ol>
<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>继承和组合都是实现重用的机制。要想重用原先构建的类，只能通过继承和组合这两种途径。</p>
<p><strong>继承</strong></p>
<p><strong>继承</strong> 是从其他类继承属性和行为。这种情况下，存在一种真正的父/子关系。（is-a）</p>
<p>OO程序设计中很强大的一个特性是代码重用，继承不仅有利于代码重用，还可以实现更好的整体设计。OO程序设计中主要的设计问题之一就是抽取不同类的共性，而继承就会发挥很好的作用。</p>
<center><br><img src="https://github.com/corderguo/corderguo.github.io/blob/master/images/mammal.png?raw=true" width="250" height="250" alt=" " align="center"><br></center>

<p><code>Dog</code>和<code>Cat</code>的代码都包含表示眼睛颜色的属性，可以利用继承找出他们的共性，相同的特性上移到<code>Mammal</code>类中，这种情况下<code>Dog</code> 和 <code>Cat</code> 都继承自 <code>Mammal</code> 类。</p>
<p>这样带来的显著的好处：我们编写 <code>Dog</code> 和 <code>Cat</code> 类时不需要重新编写父类已有的方法，假如要修改 <code>Mammal</code>  中的方法，就不需要再在 <code>Dog</code> 和 <code>Cat</code> 类中修改了。   而且 <code>Dog</code> 和 <code>Cat</code> 都是 <code>Mammal</code> 也符合我们的认知，并且以后扩展不同种的狗或猫都可以分别继承 <code>Dog</code> 和 <code>Cat</code> 。这样逐步向下建立继承树时对象会越来越具体。<em>继承的思想就是通过抽出共性实现从一般化到特殊化(具体化)</em> 。</p>
<p>在<em>EffectiveC C++</em> 中给出了一个例子，来说明使用继承完成设计时遭遇的一个难题。考虑为鸟建立一个类。鸟的突出特征就是鸟能飞，所以创建了一个包含 <code>fly</code> 方法的 <code>Bird</code> 类。这个时候应该发现问题，企鹅和鸵鸟怎么办，他们都是鸟，但是不能飞。可以局部覆盖这种行为，但是这个方法名仍然是 <code>fly</code> ,对于一个不会飞的鸟，有一个 <code>fly</code> 方法显然是不合理的。</p>
<p>其实我认为这里并不是继承的缺陷，而是抽出共性的过程出现了问题，可以创建两个类，分别对应能飞的鸟和不能飞的鸟即可。</p>
<p><strong><em>继承同时也是面向对象的另一个重要特征——多态 的实现的基础。</em></strong></p>
<p><strong><em>设计决策</em></strong></p>
<p>理论上讲，应该尽可能多地抽出共性。尽管尽可能多地抽取共性可以尽量接近实际生活，但也许并不能尽可能贴切地表示你的模型。抽取得越多，系统就会越复杂（在大规模系统中，反复这种决策，复杂性会飞速增加）。这里就带来了一个难题：你想要一个更精确的模型还是一个不太复杂的系统，这里就要根据自己的具体情况作出选择。</p>
<p>有些情况下，你的设计中，模型的更准确所带来的好处比不上它所增加的复杂性。</p>
<p>设计的根本目标是构建一个灵活的系统，但不要增加太大的复杂性使系统自己不堪重负。</p>
<p>比如：你是一位动物管理员，只是养一些寻常的鸟类，并且以后也没有计划进购那些笨重的鸟类，那么在设计的时候，<code>Bird</code> 中就可以有它们共同的行为 <code>fly</code>。</p>
<p><strong><em>继承会削弱封装</em></strong></p>
<p>封装在OO中是非常重要的，这是OO中的基本概念。通过封装，类隐藏了不需要其它类知道的所有细节。（这句可以不要）</p>
<p>继承关系的类与其它类仍然是强封装，但是超类和子类之间的封装被削弱了。如果子类从超类继承了一个实现，然后超类修改这个实现，那么超类的修改可能会对整个类层产生涟漪影响。</p>
<p>为了减少这种情况所产生的风险，使用继承时一定要坚持严格的 <code>is-a</code> 条件，这很重要。如果子类确实是超类的一种特殊化，那么父类的修改会是一种自然的、可预见的方式影响子类。其实好与坏只是看运用方式是否得当。</p>
<p><strong>组合</strong></p>
<p><strong>组合</strong> 是指使用其他对象来构建对象。这是一种组装，不存在父/子关系。(has-a)</p>
<blockquote>
<p> 例如，汽车有一个（has-a）发动机。发动机和汽车是不同的对象。这就构成了一种组合关系。</p>
</blockquote>
<p>使用组合的原因是，可以通过结合不太复杂的部分来构建复杂系统。这是人们解决问题的常用方法。</p>
<blockquote>
<p>比如，我们看到一辆车，我们会说“这里有一辆车”，而不会说“这里有一个包括一个方向盘，4个轮子和一个发动机等的大家伙”。</p>
</blockquote>
<p>使用组合的另一个主要优点是系统和子系统可以独立构建，更重要的是，可以独立地测试和维护。当今的软件系统越来越复杂，要让大型软件系统正常地工作而且易于维护，它们必须分解为较小的、更可管理的部分。而组合则可以做到这些。</p>
<p>而且使用组件的另一个好处是，你可以使用其他开发人员构建的组件，方便自己的开发。</p>
<center><br><img src="https://github.com/corderguo/gxz/blob/master/yinxiang.jpg?raw=true" width="230" height="250" alt=" " align="center"><br></center>

<blockquote>
<p>比如音响系统，单独的部件坏了可以重新换一个部件即可继续使用，而如果这个系统是个集成系统（也就是说该系统完全是一个大黑箱系统），不是基于组件构成，这个情况下，你需要把整个系统拿去修理，这样做不仅复杂，费用高，同时你也将无法使用其他并没有损坏的部分。</p>
</blockquote>
<p>诺贝尔奖得主Herbert Simon对稳定系统提出以下观点：</p>
<ol>
<li>稳定的复杂系统通常采用一种层次结构的形式，其中各个系统都是由更简单的子系统构成，而各个子系统则是由更简单的下一级子系统构成。</li>
<li>稳定的复杂系统几乎都是可以分解的。</li>
<li>稳定的复杂系统几乎总是只由几个不同类型的子系统组成，并以不同的结合方式组织。</li>
<li>能正常工作的稳定系统几乎总是由能正常工作的简单系统发展而来。</li>
</ol>
<p>这也说明的<strong>组合</strong>的重要性。</p>
<p>使用组合时，要避免建立非常依赖其他对象的对象，也即是<strong><em>避免依赖性</em></strong>。</p>
<p>使用太多组合也会导致更大的模型复杂性。这和继承中模型复杂性的问题类似。</p>
<blockquote>
<p>假设汽车由一个发动机、一个音响、和一个车门组成。发动机又包含活塞和火花塞。音响包含收音机和CD播放器。车门包含一个把手。再往下一个层次，收音机还需要一个调谐开关，车门把手包含一把锁等。多层次详细的组合树也会导致模型复杂性的问题。</p>
</blockquote>
<p><strong>小结</strong></p>
<p>很多知名的OO设计人员指出，应该尽可能的地使用组合，而只在必要的情况下才使用继承。 尽管更多的情况下使用组合比使用继承更合适，但是继承和组合都是很好的设计方式，需要应用到适当的上下文环境中。</p>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在团队内部组织了一场面向对象的分享会，做了部分内容整理。      &lt;/p&gt;
&lt;h3 id=&quot;面向对象和面向过程的区别&quot;&gt;&lt;a href=&quot;#面向对象和面向过程的区别&quot; class=&quot;headerlink&quot; title=&quot;面向对象和面向过程的区别&quot;&gt;&lt;/a&gt;面向对象和面
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用Fastlane实现自动化打包</title>
    <link href="http://yoursite.com/2018/10/09/fastlane_study/"/>
    <id>http://yoursite.com/2018/10/09/fastlane_study/</id>
    <published>2018-10-09T05:59:20.000Z</published>
    <updated>2018-10-09T06:33:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="http://coderperson.com/2018/09/29/iOS-auto_packaging/" target="_blank" rel="external">文章</a>讲解了利用python封装脚本进行自动化打包，这两天又看了看github上很火的自动化打包工具<a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">Fastlane</a>。</p>
<p>Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 官方文档看<a href="https://docs.fastlane.tools/" target="_blank" rel="external">这里</a>。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>安装Xcode命令行工具:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<ul>
<li>查看ruby版本，要求2.0及以上版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br><span class="line"></span><br><span class="line">ruby的镜像文件路径改为https://gems.ruby-china.org/</span><br><span class="line"></span><br><span class="line">gem sources --remove https://ruby.taobao.org/</span><br><span class="line"></span><br><span class="line">gem sources --add https://rubygems.org</span><br><span class="line"></span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<ul>
<li>安装：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install fastlane</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>切换项目目录到包含xxx.xcodeproj的项目目录下输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure>
<p>输出：        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[15:21:56]: What would you like to use fastlane for?</span><br><span class="line">1. 📸  Automate screenshots</span><br><span class="line">2. 👩‍✈️  Automate beta distribution to TestFlight</span><br><span class="line">3. 🚀  Automate App Store distribution</span><br><span class="line">4. 🛠  Manual setup - manually setup your project to automate your tasks</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<p>这四个选项的意思是:        </p>
<blockquote>
<p>1.自动截屏。这个功能能帮我们自动截取APP中的截图，并添加手机边框（如果需要的话），我们这里不选择这个选项，因为我们的项目已经有图片了，不需要这里截屏。</p>
<p>2.自动发布beta版本用于TestFlight，如果大家有对TestFlight不了解的，可以参考王巍写的这篇文章</p>
<p>3.自动的App Store发布包。我们的目标是要提交审核到APP Store，按道理应该选这个，但这里我们先不选，因为选择了以后会需要输入用户名密码，以及下载meta信息，需要花费一定时间，这些数据我们可以后期进行配置。</p>
<p>4.手动设置。</p>
</blockquote>
<p>选择第四个后一路回车即可（等待时间略长），结束后会看到生成了fastlane目录，该目录包含Appfile和Fastfile；同时还生成了两个文件Gemfile和Gemfile.lock，是和fastlane文件夹在同一个目录。</p>
<h3 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h3><p>Appfile用来存放app_identifier，apple_id和team_id。文件生成的时候会定义好格式，按格式填写即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_identifier(&quot;[[xxxx]]&quot;) # The bundle identifier of your app</span><br><span class="line">apple_id(&quot;[[xxxx]]&quot;) # Your Apple email address</span><br></pre></td></tr></table></figure>
<p>你也可以为每个lane提供不同的 app_identifier, apple_id 和 team_id，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for_lane :inhouse do</span><br><span class="line">  app_identifier &quot;xxxx&quot;</span><br><span class="line">  apple_id &quot;xxxx&quot;</span><br><span class="line">  team_id &quot;xxxx&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里就是为Fastfile中定义的inhouse这个lane设置单独的信息。</p>
<h3 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h3><p>Fastfile管理你所创建的 lane 。</p>
<blockquote>
<ul>
<li>scan 自动化测试工具，很好的封装了 Unit Test    </li>
<li>sigh 针对于 iOS 项目开发证书和 Provision file 的下载工具    </li>
<li>match 同步团队每个人的证书和 Provision file 的超赞工具    </li>
<li>gym 针对于 iOS 编译打包生成 ipa 文件    </li>
<li>deliver 用于上传应用的二进制代码，应用截屏和元数据到 App Store    </li>
<li>snapshot 可以自动化iOS应用在每个设备上的本地化截屏过程    </li>
</ul>
</blockquote>
<p>这里我们主要用<code>gym</code>来打包。</p>
<p>Fastlane内部的工具不是新写的，而是调用mac本身的命令，只不过是实现了自动化而已。比如gym工具只是xcodebuild工具的一个封装，如果你会xcodebuild，那gym对你来说小菜一碟。xcodebuild的使用可以看<a href="http://coderperson.com/2018/09/29/iOS-auto_packaging/" target="_blank" rel="external">这篇文章</a>。</p>
<p>找了一个比较全的格式，可以参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 指定 fastlane 最小版本</span><br><span class="line">fastlane_version &quot;2.20.0&quot;</span><br><span class="line"></span><br><span class="line"># 指定当前平台，可以设置为 ios 、android、mac</span><br><span class="line">default_platform :ios</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line"></span><br><span class="line"># 在执行每一个 lane 之前都先执行这个代码</span><br><span class="line">  before_all do</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"># 定义一个创建测试包的 lane</span><br><span class="line"># 我们调用的命令就是调用 fastlane 的 lane</span><br><span class="line">  lane :buildDebugApp do |op|</span><br><span class="line">      # 根据输入的版本设置项目 version number （我们初始化 fastlane 的时候是在 .xcworkspace 目录下， 而我们的项目中 ，.xcworkspace 和 .xcodeproj 不在同一级目录，这里的“increment_version_number”需要检测 .xcodeproj 项目文件，所以需要指定该文件的目录）</span><br><span class="line">    increment_version_number(&#123;xcodeproj: &apos;./HomeMate2_Trunk/HomeMate.xcodeproj&apos;, version_number: op[:version]&#125;)</span><br><span class="line"></span><br><span class="line">    # 根据输入的版本设置项目 build number （同上，也是需要指定 .xcodeproj 的目录）</span><br><span class="line">    increment_build_number(&#123;xcodeproj: &apos;./HomeMate2_Trunk/HomeMate.xcodeproj&apos;, build_number: op[:version]&#125;)</span><br><span class="line"></span><br><span class="line">    # 最重要的打包命令</span><br><span class="line">    gym(</span><br><span class="line">              export_method: &apos;ad-hoc&apos;,        # 打包的方式，可设置为 appstore(默认)，enterprise</span><br><span class="line">                     scheme: &quot;HomeMate&quot;,    # 指定需要打那个 scheme 的包</span><br><span class="line">                  workspace: &quot;HMWorkSpac.xcworkspace&quot;,    # 指定打包的项目文件</span><br><span class="line">                output_name: &quot;HomeMate.ipa&quot;,      # 打包输出名称</span><br><span class="line">                     silent: true,    # 隐藏不必要信息</span><br><span class="line">                      clean: true,    # 打包前是否 clean 项目</span><br><span class="line">              configuration: &quot;Debug&quot;,    # 配置为 debug 版本</span><br><span class="line">              buildlog_path: &quot;./fastlanelog&quot;,    # 日志输出目录</span><br><span class="line">       codesigning_identity: &quot;iPhone Developer: Hailiang He (xxxxxxxxxx)&quot;,       # 代码签名证书</span><br><span class="line">           output_directory: &quot;/Users/xxx/Desktop&quot;     # ipa输出目录</span><br><span class="line">     )</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 在执行每一个 lane 之后执行该功能</span><br><span class="line">  after_all do |lane|</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 在执行每一个 lane 出错的时候执行该功能</span><br><span class="line">  error do |lane, exception|</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>上面的代码块包含了日常打包常用的功能，可以参考。</p>
<p>我这边测试打包的时候，写了一个最简单版本的Appfile和Fastfile文件，理解了这个最简单版本，在这个基础上继续增加功能即可，<code>非常便于理解</code>。</p>
<p>Appfile文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_identifier(&quot;[[xxx]]&quot;) # The bundle identifier of your app</span><br><span class="line">apple_id(&quot;[[xxx]]&quot;) # Your Apple email address</span><br></pre></td></tr></table></figure>
<p>Fastfile文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">  desc &quot;Description of what the lane does&quot;</span><br><span class="line">  lane :custom_lane do</span><br><span class="line">    # add actions here: https://docs.fastlane.tools/actions</span><br><span class="line">    gym(scheme: &quot;xxx&quot;,</span><br><span class="line">      export_method:&quot;ad-hoc&quot;,</span><br><span class="line">      output_directory:&quot;./build&quot;, # 打包后的 ipa 文件存放的目录</span><br><span class="line">      output_name:&quot;xxx.ipa&quot;  # ipa 文件名</span><br><span class="line">   )</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>export_method对应的打包类型：app-store、ad-hoc、development、enterprise。</p>
<p>编辑好以上内容，打开终端执行下面的命令，即可看到在当前目录下生成一个build文件夹，ipa包就在该文件夹中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane custom_lane</span><br></pre></td></tr></table></figure>
<p>如果lane中设置了可以接收版本号,则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane custom_lane version:1.1.0</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;http://coderperson.com/2018/09/29/iOS-auto_packaging/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;讲解了利用python封装脚本进行自动化打包，这两天又看了看git
    
    </summary>
    
      <category term="Ruby" scheme="http://yoursite.com/categories/Ruby/"/>
    
    
      <category term="Ruby" scheme="http://yoursite.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>利用python实现自动化打包</title>
    <link href="http://yoursite.com/2018/09/29/iOS-auto_packaging/"/>
    <id>http://yoursite.com/2018/09/29/iOS-auto_packaging/</id>
    <published>2018-09-29T11:12:59.000Z</published>
    <updated>2018-10-09T06:32:52.769Z</updated>
    
    <content type="html"><![CDATA[<p>频繁的手动打包是一项耗时耗力的工程，而且是一项重复性的劳动，因此实现打包的自动化是非常必要的。通过自动化打包可以实现一键打包，并上传到fir或蒲公英等第三方平台。</p>
<h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h2><p>当我们通过<code>Archive</code>手动打包的时候，<code>Xcode</code>本身是通过调用<code>xcodebuild</code>命令来实现打包的过程。</p>
<p><code>xcodebuild</code>是苹果提供的用于打包项目或者工程的命令，可以通过<code>man xcodebuild</code>命令查看它的介绍。</p>
<blockquote>
<p>NAME        </p>
<p>xcodebuild – build Xcode projects and workspaces</p>
<p>DESCRIPTION</p>
<p>xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.</p>
<p>Usage</p>
<p>To build an Xcode project, run xcodebuild from the directory containing your project (i.e. the<br>     directory containing the name.xcodeproj package). If you have multiple projects in the this<br>     directory you will need to use -project to indicate which project should be built.  By default,<br>     xcodebuild builds the first target listed in the project, with the default build configuration.<br>     The order of the targets is a property of the project and is the same for all users of the<br>     project.<br>To build an Xcode workspace, you must pass both the -workspace and -scheme options to define the<br>     build.  The parameters of the scheme will control which targets are built and how they are built,<br>     although you may pass other options to xcodebuild to override some parameters of the scheme.<br>     There are also several options that display info about the installed version of Xcode or about projects or workspaces in the local directory, but which do not initiate an action.  These<br>     include -list, -showBuildSettings, -showdestinations, -showsdks, -usage, and -version.</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>需要在包含 <code>name.xcodeproj</code> 的目录下执行 <code>xcodebuild</code> 命令，且如果该目录下有多个 projects，那么需要使用 <code>-project</code> 指定需要 build 的项目。</li>
<li>在不指定 <code>build</code> 的 <code>target</code> 的时候，默认情况下会 build project 下的<code>第一个</code>target</li>
<li>当 build workspace 时，需要同时指定 <code>-workspace</code> 和 <code>-scheme</code> 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。</li>
<li>有一些诸如 <code>-list, -showBuildSettings, -showsdks</code> 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。</li>
</ul>
<p>那么，xcodebuild 究竟如何使用呢？ 继续看文档:</p>
<p>&gt;</p>
<blockquote>
<p>SYNOPSIS</p>
<p>xcodebuild [-project name.xcodeproj][[-target targetname] … | -alltargets]<br>                [-configuration configurationname][-sdk [sdkfullpath | sdkname]] [action …]<br>                [buildsetting=value …] [-userdefault=value …]</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …]<br>                [-destination-timeout value] [-configuration configurationname]<br>                [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …]<br>                [-userdefault=value …]</p>
<p>xcodebuild -workspace name.xcworkspace -scheme schemename<br>                [[-destination destinationspecifier] …][-destination-timeout value]<br>                [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …]<br>                [buildsetting=value …] [-userdefault=value …]</p>
<p>xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]</p>
<p>xcodebuild -showsdks</p>
<p>xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath<br>                -exportOptionsPlist path</p>
<p>等等</p>
</blockquote>
<p>挑几个常用的形式介绍一下：</p>
<ul>
<li><code>xcodebuild -showsdks</code>: 列出 Xcode 所有可用的 SDKs。</li>
<li><code>xcodebuild -showBuildSettings</code>: 查看当前工程 build setting 的配置参数。</li>
<li><code>xcodebuild [-project name.xcodeproj] [[-target targetname] ... | -alltargets] build</code>: 会 build 指定 project，其中 -target 和 -configuration 参数可以使用 xcodebuild -list 获得，-sdk 参数可由 xcodebuild -showsdks 获得。</li>
<li><code>xcodebuild -workspace name.xcworkspace -scheme schemename build</code>:build 指定 workspace，当我们使用 CocoaPods 来管理第三方库时，会生成 xcworkspace 文件，这样就会用到这种打包方式。</li>
</ul>
<h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><p><code>开始打包</code>—-&gt;<code>archive文件</code>—-&gt;<code>ipa包</code></p>
<h4 id="生成archive文件"><a href="#生成archive文件" class="headerlink" title="生成archive文件"></a>生成archive文件</h4><p>首先看一下生成<code>archive文件</code>的命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcodebuild archive -workspace 项目名称.xcworkspace </span><br><span class="line">                   -scheme 项目名称 </span><br><span class="line">                   -configuration 构建配置 </span><br><span class="line">                   -archivePath archive包存储路径 </span><br><span class="line">                    CODE_SIGN_IDENTITY=证书 </span><br><span class="line">                    PROVISIONING_PROFILE=描述文件UUID</span><br></pre></td></tr></table></figure>
<ul>
<li>workspace 这个就是项目名</li>
<li>scheme 可以通过xcodebuild -list获取</li>
<li>configration 一些参数，也可以通过xcodebuild -list获取，一般使用Debug、Release</li>
<li>archivePath archive后的路径</li>
<li>CODE_SIGN_IDENTITY 证书的Inentity</li>
<li>PROVISIONING_PROFILE 描述文件UUID</li>
</ul>
<p>如果使用Xcode的自动管理证书功能，则<code>CODE_SIGN_IDENTITY</code>和<code>CODE_SIGN_IDENTITY</code>参数不需要添加。</p>
<h4 id="生成ipa文件"><a href="#生成ipa文件" class="headerlink" title="生成ipa文件"></a>生成ipa文件</h4><p>同样看一下生成ipa文件的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcodebuild -exportArchive -archivePath archive文件的地址.xcarchive </span><br><span class="line">                          -exportPath 导出的文件夹地址 </span><br><span class="line">                          -exportOptionsPlist exprotOptionsPlist.plist </span><br><span class="line">                          CODE_SIGN_IDENTITY=证书 </span><br><span class="line">                          PROVISIONING_PROFILE=描述文件UUID</span><br></pre></td></tr></table></figure>
<p>官方解释：</p>
<p>&gt;</p>
<blockquote>
<p>Exports the archive MyMobileApp.xcarchive to the path ExportDestination using the<br>              options specified in export.plist.</p>
</blockquote>
<p>同样，如果你不需要的指定证书和Provisioning文件，可以把上面的两个参数去掉，它会根据你的Xcode配置去匹配。</p>
<p><code>exportOptionsPlist</code>这个参数，对应一个plist文件,用来配置一些打包时需要配置的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">    &lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UA21BCDJHK3&lt;/string&gt; //TeamID</span><br><span class="line">        &lt;key&gt;method&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;ad-hoc&lt;/string&gt; //ad-hoc打包</span><br><span class="line">        &lt;key&gt; compileBitcode&lt;/key&gt; //是否编译bitcode</span><br><span class="line">        &lt;false/&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p><code>exportOptionsPlist.plist</code>可配置的字段，可以使用<code>xcodebuild --help</code>命令查看。</p>
<p>至此你已经能通过命令生成ipa包了。</p>
<h2 id="上传第三方平台"><a href="#上传第三方平台" class="headerlink" title="上传第三方平台"></a>上传第三方平台</h2><p>一般第三方平台都会开放上传app包的API，这里以咱们使用的<code>fir</code>平台为例：</p>
<p>查看<code>fir</code>的文档，可以在<code>文档</code>中看到<code>发布应用</code>的选项卡，其中有获取上传凭证的API：</p>
<p>&gt;</p>
<blockquote>
<p>POST <a href="http://api.fir.im/apps" target="_blank" rel="external">http://api.fir.im/apps</a></p>
</blockquote>
<p>上传文件的API:</p>
<p>&gt;</p>
<blockquote>
<p>POST upload_url</p>
</blockquote>
<p>然后按文档格式，配置指定的参数即可。</p>
<p>然后利用<code>python</code>将刚才生产的ipa包，上传到fir平台即可。</p>
<h2 id="上传到AppStore"><a href="#上传到AppStore" class="headerlink" title="上传到AppStore"></a>上传到AppStore</h2><p>利用<code>altool</code>: Application Loader命令行工具可以验证并上传应用程序的二进制文件到AppStore。</p>
<h2 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h2><p>综合以上过程，利用<code>python</code>实现脚本工具，完成一键打包并上传fir。</p>
<p>工具代码如下,可以在此基础代码的基础上增加更多功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Release Debug</span><br><span class="line">CONFIGURATION = &quot;Debug&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def desktopPath():</span><br><span class="line">    return os.path.join(os.path.expanduser(&quot;~&quot;), &apos;Desktop&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#清除临时文件</span><br><span class="line">def cleanArchiveFile(archivePath):</span><br><span class="line">	cleanCmd = &quot;rm -r %s&quot; %(archivePath)</span><br><span class="line">	os.system(cleanCmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#上传到第三方平台</span><br><span class="line">def uploadIpaToPlatform(ipaPath):</span><br><span class="line"></span><br><span class="line">    #需要的参数</span><br><span class="line">    upload_url = &quot;xxxx&quot;</span><br><span class="line">    bundle_id = &quot;xxxx&quot;</span><br><span class="line">    api_token = &quot;xxxx&quot;</span><br><span class="line"></span><br><span class="line">    #获取上传凭证（上传地址）</span><br><span class="line">    data = &#123;&apos;type&apos;: &apos;ios&apos;, &apos;bundle_id&apos;: bundle_id,</span><br><span class="line">        &apos;api_token&apos;: api_token&#125;</span><br><span class="line"></span><br><span class="line">    response = requests.post(url = upload_url, data = data)</span><br><span class="line">    json = response.json()</span><br><span class="line">    binaryDict = (json[&quot;cert&quot;][&quot;binary&quot;])</span><br><span class="line"></span><br><span class="line">    print &apos;====&apos; + ipaPath + &apos;=====&apos; + binaryDict[&apos;upload_url&apos;]</span><br><span class="line"></span><br><span class="line">    f = open(ipaPath, &apos;rb&apos;)</span><br><span class="line">    file_binary = &#123;&apos;file&apos;: f&#125;</span><br><span class="line">    param = &#123;&quot;key&quot;:binaryDict[&apos;key&apos;],&quot;token&quot;:binaryDict[&apos;token&apos;]&#125;</span><br><span class="line">    #上传ipa    </span><br><span class="line">    req = requests.post(url=binaryDict[&apos;upload_url&apos;],files=file_binary,data=param,verify=False)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#build过程</span><br><span class="line">def xcbuild():</span><br><span class="line"></span><br><span class="line">	#初始化</span><br><span class="line">	#工程名字</span><br><span class="line">	workspace = &quot;test.xcworkspace&quot;</span><br><span class="line">	scheme = &quot;test&quot;</span><br><span class="line"></span><br><span class="line">	# exportOptions.plist文件路径；根据自己的实际情况改变</span><br><span class="line">	plistPath = &apos;./../../build/exportOptions.plist&apos;</span><br><span class="line"></span><br><span class="line">	#桌面路径</span><br><span class="line">	deskPath = desktopPath()</span><br><span class="line"></span><br><span class="line">	#archive文件导出路径</span><br><span class="line">	archivePath = deskPath + &apos;/&apos; + scheme + &apos;.xcarchive&apos;</span><br><span class="line"></span><br><span class="line">	#导出ipa文件所在文件名</span><br><span class="line">	currentT = time.strftime(&apos;%Y-%m-%d-%H-%M-%S&apos;,time.localtime(time.time()))</span><br><span class="line">	ipaDirName = scheme + currentT</span><br><span class="line"></span><br><span class="line">	#ipa文件路径</span><br><span class="line">	ipaPath = deskPath + &apos;/&apos; + ipaDirName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	# 生成archive文件的命令</span><br><span class="line">	archiveCmd = &quot;xcodebuild archive -workspace %s -scheme %s -configuration %s -archivePath %s&quot; %(workspace,scheme,CONFIGURATION,archivePath)</span><br><span class="line">	#python执行命令</span><br><span class="line">	os.system(archiveCmd)</span><br><span class="line">	#生成.ipa包的命令</span><br><span class="line">	exportCmd = &quot;xcodebuild -exportArchive -archivePath %s -exportOptionsPlist %s -exportPath %s&quot; %(archivePath,plistPath,ipaPath)</span><br><span class="line">	os.system(exportCmd)</span><br><span class="line"></span><br><span class="line">	#上传fir</span><br><span class="line">	uploadIpaToPlatform(ipaPath + &apos;/&apos; + scheme + &apos;.ipa&apos;)</span><br><span class="line"></span><br><span class="line">	#清除临时文件</span><br><span class="line">	cleanArchiveFile(archivePath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">	#判断输入的参数</span><br><span class="line">	if len(sys.argv) &gt; 1:</span><br><span class="line">		config = sys.argv[1]</span><br><span class="line">		global CONFIGURATION</span><br><span class="line">		if sys.argv[1]==&apos;Release&apos; or sys.argv[1]==&apos;RELEASE&apos;:</span><br><span class="line">			CONFIGURATION = &apos;Release&apos;</span><br><span class="line">		elif sys.argv[1]==&apos;Debug&apos; or sys.argv[1]==&apos;DEBUG&apos;:</span><br><span class="line">			CONFIGURATION = &apos;Debug&apos;</span><br><span class="line"></span><br><span class="line">	#build过程</span><br><span class="line">	xcbuild()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>
<p>为了不污染项目，该脚本和plist文件并没有放到项目工程目录中，而是把py文件设置成了全局可用，<code>exportOptionsPlist.plist</code>文件放到单独的目录，在脚本文件中引用即可。</p>
<p>使用的时候只需在工程目录敲命令:</p>
<p>如果打<code>Debug</code>包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build.py</span><br></pre></td></tr></table></figure>
<p>如果打<code>Release</code>包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build.py Release</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;频繁的手动打包是一项耗时耗力的工程，而且是一项重复性的劳动，因此实现打包的自动化是非常必要的。通过自动化打包可以实现一键打包，并上传到fir或蒲公英等第三方平台。&lt;/p&gt;
&lt;h2 id=&quot;xcodebuild&quot;&gt;&lt;a href=&quot;#xcodebuild&quot; class=&quot;he
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="http://yoursite.com/2018/09/21/acm-dijkstra/"/>
    <id>http://yoursite.com/2018/09/21/acm-dijkstra/</id>
    <published>2018-09-21T11:12:59.000Z</published>
    <updated>2018-10-02T08:57:54.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>假设一个开车的人希望找出从新疆到北京的可能的最短路线。他有一张中国公路地图，该公路图上标出了每一对相邻的公路交叉之间的距离，他应该如何找出这一最短路线呢？</p>
<p> 一种可能的方法就是枚举出所有从新疆到北京之间的路线，依然存在着数以百万计的行车路线，而其中绝大多数是不值得考虑的。</p>
<p>现实中很多抽象的例子都可以转化成类似这样的问题，这类问题统一称为求<code>最短路径</code>的问题。</p>
<h2 id="最短路径的解决算法"><a href="#最短路径的解决算法" class="headerlink" title="最短路径的解决算法"></a>最短路径的解决算法</h2><ul>
<li>Floyd<br>求多源、无负权边的最短路。用矩阵记录图。时效性较差，时间复杂度<code>O(V^3)</code>。</li>
<li>Dijkstra<br>求单源、无负权的最短路。时效性较好，时间复杂度<code>O(V^2)</code>。</li>
<li>Bellman-Ford<br>求单源最短路，可以判断有无负权回路。通过不断构建以源点为根的最短路径树，不断扩展。</li>
<li>SPFA<br>可以用于存在负数边权的图，算法时间效率是不稳定的，即它对于不同的图所需要的时间有很大的差别。<code>SPFA</code>算法是在<code>Bellman-Ford</code>算法的基础上进行优化而来。</li>
</ul>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h5 id="定义概览"><a href="#定义概览" class="headerlink" title="定义概览"></a>定义概览</h5><p><code>Dijkstra</code>(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。<code>Dijkstra</code>算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。</p>
<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p><code>算法思想</code>：设<code>G=(V,E)</code>是一个带权有向图，把图中顶点集合<code>V</code>分成两组，第一组为已求出最短路径的顶点集合（用<code>S</code>表示，初始时<code>S</code>中只有一个源点，以后每求得一条最短路径 , 就将加入到集合<code>S</code>中，直到全部顶点都加入到<code>S</code>中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用<code>U</code>表示），按最短路径长度的递增次序依次把第二组的顶点加入<code>S</code>中。在加入的过程中，总保持从源点<code>v</code>到<code>S</code>中各顶点的最短路径长度不大于从源点<code>v</code>到<code>U</code>中任何顶点的最短路径长度。此外，每个顶点对应一个距离，<code>S</code>中的顶点的距离就是从<code>v</code>到此顶点的最短路径长度，<code>U</code>中的顶点的距离，是从<code>v</code>到此顶点只包括<code>S</code>中的顶点为中间顶点的当前最短路径长度。</p>
<p><code>算法步骤</code>：</p>
<ol>
<li><p>初始时，<code>S</code>只包含源点，即<code>S＝{v}</code>，<code>v</code>的距离为<code>0</code>。<code>U</code>包含除<code>v</code>外的其他顶点，即:<code>U={其余顶点}</code>，若<code>v</code>与<code>U</code>中顶点<code>u</code>有边，则<code>&lt;u,v&gt;</code>正常有权值，若<code>u</code>不是<code>v</code>的出边邻接点，则<code>&lt;u,v&gt;</code>权值为<code>∞</code>。</p>
</li>
<li><p>从U中选取一个距离<code>v</code>最小的顶点<code>k</code>，把<code>k</code>，加入<code>S</code>中（该选定的距离就是<code>v</code>到<code>k</code>的最短路径长度）。</p>
</li>
<li><p>以<code>k</code>为新考虑的中间点，修改<code>U</code>中各顶点的距离；若从源点<code>v</code>到顶点<code>u</code>的距离（经过顶点<code>k</code>）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值为顶点<code>k</code>的距离加上<code>&lt;k,u&gt;</code>边上的权。</p>
</li>
<li><p>重复步骤 <code>2</code> 和 <code>3</code> 直到所有顶点都包含在 <code>S</code> 中。</p>
</li>
</ol>
<p><code>Tip</code>:<br>通常在编码过程中，以一个二维数组<code>map[][]</code>来表示整张图，以一个一维数组<code>dist[]</code>来表示源点到各个顶点的当前最短路径，以一个一维数组<code>set[]</code>来标识当前顶点是否已经被并入到集合<code>S</code>中，即当前顶点的最短路径已经求出。</p>
<p><code>执行动画</code>:</p>
<p><img src="https://corderguo.github.io/images/dijkstra.gif" alt="dijkstra_img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>由上述讲解可以写出如下Dijkstra算法代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 图的存储在 MGraph  g.n为顶点数量 g.edges[][]为边的权值</span><br><span class="line">// v为源点</span><br><span class="line">// dist[] 保存源点到各个顶点的当前最短路径</span><br><span class="line">void Dijkstra(MGraph g, int v, int dist[]) &#123;</span><br><span class="line">    int set[maxSize];</span><br><span class="line">    int min,i,j,u;</span><br><span class="line">    // 初始化</span><br><span class="line">    for(i = 0;i&lt;g.n;i++) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    set[v] = 1;</span><br><span class="line">    </span><br><span class="line">    for(i = 0;i &lt; g.n; i++ ) &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        // 这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的</span><br><span class="line">        for (j = 0;j&lt; g.n;j++) &#123;</span><br><span class="line">            if(set[h] == 0 &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        // 以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测</span><br><span class="line">        for (j = 0;j &lt; g.n;j++) &#123;</span><br><span class="line">            if (set[j]==0&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[u]+g.edges[u][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例如经典的题目<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="external">HDU1874</a>。</p>
<p><code>问题描述</code>：            </p>
<p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。<br>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p>
<p><code>Input</code>:    </p>
<p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。            </p>
<p><code>Output</code>:            </p>
<p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p>
<p><code>解析</code>：</p>
<p>这是典型的求解最短路径的问题，可以把城镇转换成图中的点，道路转换成图中的有权边，然后根据构造出的这张图，求解源点到各个点的最短路径即可。</p>
<p><code>代码</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#define MAX_INT 10000</span><br><span class="line">//</span><br><span class="line">int set[202];</span><br><span class="line">int map[202][202];</span><br><span class="line">int dis[202];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Dijkstra(int start , int n) &#123;</span><br><span class="line">    </span><br><span class="line">    // 初始化</span><br><span class="line">    for (int i = 0; i&lt;n; i ++) &#123;</span><br><span class="line">        dis[i] = map[start][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    set[start] = 1;</span><br><span class="line">    </span><br><span class="line">    for (int j = 0 ; j &lt; n; j ++) &#123;</span><br><span class="line">        </span><br><span class="line">        // 找当前最短路径</span><br><span class="line">        int temp = MAX_INT;</span><br><span class="line">        int u = start;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (set[i] == 0 &amp;&amp; dis[i] &lt; temp) &#123;</span><br><span class="line">                temp = dis[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        </span><br><span class="line">        // 以u为中间点更新最短路径</span><br><span class="line">        for (int i = 0 ; i &lt; n; i ++) &#123;</span><br><span class="line">            if (set[i] == 0 &amp;&amp; dis[u] + map[u][i] &lt; dis[i]) &#123;</span><br><span class="line">                dis[i] = dis[u] + map[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m) != EOF) &#123;</span><br><span class="line">        // 图的初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    map[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    map[i][j] = MAX_INT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (m--) &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            if (c &lt; map[a][b]) &#123;</span><br><span class="line">                map[a][b] = map[b][a] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int start , end;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;start,&amp;end);</span><br><span class="line">        Dijkstra(start, n);</span><br><span class="line">        if (dis[end] == MAX_INT) &#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,dis[end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个变形题目，可以当做练习：</p>
<p><a href="http://acm.hdu.edu.cn/diy/contest_show.php?cid=34192" target="_blank" rel="external">练习题</a></p>
<p>password:123</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>经过以上步骤，我们已经求出了源点到各个顶点的最短路径的值，如果此时需要知道该最短路径所上所经过的点，该如何解决呢？</p>
<p>此时我们可以用一个一维数组<code>path[]</code>来保存最短路径上所经过的订单。<br>比如：<code>path[Vi]</code>中保存从源点到<code>Vi</code>的最短路径上<code>Vi</code>的前一个顶点，假设最短路径上的顶点序列为<code>V0,V1,V2,V3,...,Vi-1,Vi</code> 则<code>path[Vi]=Vi-1</code>。</p>
<p><code>path[]</code>测初态为：假设<code>V0</code>为源点，如果<code>V0</code>到<code>Vi</code>有边，则<code>path[Vi]=V0</code>,否则<code>path[Vi]=-1</code>。<br>在上面的步骤中，每一次更新最短路径的值的时候，同时更新<code>path[]</code>的值，直到所有的顶点的最短路径更新完毕，<code>path[]</code>中也就保存了每个最短路径所经历的顶点，这是一个<code>树形结构</code>。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>在上面的代码上做一些修改,增加了<code>path[]</code>数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 图的存储在 MGraph  g.n为顶点数量 g.edges[][]为边的权值</span><br><span class="line">// v为源点</span><br><span class="line">// dist[] 保存源点到各个顶点的当前最短路径</span><br><span class="line">// path[] 保存从源点到`Vi`的最短路径上`Vi`的前一个顶点</span><br><span class="line">void Dijkstra(MGraph g, int v, int dist[], int path[]) &#123;</span><br><span class="line">    int set[maxSize];</span><br><span class="line">    int min,i,j,u;</span><br><span class="line">    // 初始化</span><br><span class="line">    for(i = 0;i&lt;g.n;i++) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">        // path[] 初始化</span><br><span class="line">        if (g.edges[v][i] &lt; INF) &#123;</span><br><span class="line">        	path[i] = v;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	path[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set[v] = 1;</span><br><span class="line">    path[v] = -1;</span><br><span class="line">    </span><br><span class="line">    for(i = 0;i &lt; g.n; i++ ) &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        // 这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的</span><br><span class="line">        for (j = 0;j&lt; g.n;j++) &#123;</span><br><span class="line">            if(set[h] == 0 &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        // 以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测</span><br><span class="line">        for (j = 0;j &lt; g.n;j++) &#123;</span><br><span class="line">            if (set[j]==0&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[u]+g.edges[u][j];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;假设一个开车的人希望找出从新疆到北京的可能的最短路线。他有一张中国公路地图，该公路图上标出了每一对相邻的公路交叉之间的距离，他应该如何找出这
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向之动态调试</title>
    <link href="http://yoursite.com/2018/06/06/iOS-hacking-lldb/"/>
    <id>http://yoursite.com/2018/06/06/iOS-hacking-lldb/</id>
    <published>2018-06-06T04:02:04.000Z</published>
    <updated>2018-06-06T07:45:42.282Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。</p>
<h2 id="Xcode的动态调试原理"><a href="#Xcode的动态调试原理" class="headerlink" title="Xcode的动态调试原理"></a>Xcode的动态调试原理</h2><p>首先了解一下 <code>Xcode</code> 编译和调试器的发展。<code>Xcode</code> 中的编译器发展历程：<code>GCC</code> -&gt; <code>LLVM</code>,调试器的发展历程：<code>GDB</code> -&gt; <code>LLDB</code> 。</p>
<p><code>Xcode</code> 调试安装到手机上的应用的原理：<code>Xcode</code> 通过 <code>LLDB</code> 调试器把调试指令发送到手机上的 <code>debugserver</code>, <code>debugserver</code> 再与相应的 <code>APP</code> 进行交互，达到调试的效果。</p>
<p><code>debugserver</code> 一开始是存放在Mac的Xcode里面,路径： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms</span><br><span class="line">/iPhoneOS.platform/DeviceSupport</span><br><span class="line">/<span class="number">9.1</span>/DeveloperDiskImage.dmg</span><br><span class="line">/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
<p>当 <code>Xcode</code> 识别到手机设备时，<code>Xcode</code> 会自动将 <code>debugserver</code> 安装到手机上。</p>
<p><code>Xcode</code> 调试的局限性：一般情况下，只能调试通过 <code>Xcode</code> 安装的APP，无法调试其它APP。</p>
<h3 id="给debugserver赋予权限"><a href="#给debugserver赋予权限" class="headerlink" title="给debugserver赋予权限"></a>给debugserver赋予权限</h3><p>默认情况下 <code>/Developer/usr/bin/debugserver</code> 缺少一定的权限，只能调试通过Xcode安装的App，如果希望调试其它App，需要对 <code>debugserver</code> 重新签名，签上可以调试其它App的权限。</p>
<p>需要的两个权限为：<code>get-task-allow</code> 和 <code>task_for_pid-allow</code></p>
<p>iPhone上的 <code>/Developer</code> 目录是只读的，无法直接对 <code>/Developer/usr/bin/debugserver</code> 文件签名，需要先把 <code>debugserver</code> 复制到Mac。</p>
<p>通过 <code>ldid</code> 命令导出文件以前的签名权限:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -e debugserver &gt; debugserver.entitlements</span><br></pre></td></tr></table></figure>
<p><code>debugserver.entitlements</code> 这个文件其实是个 <code>plist</code> 文件，在这个文件中加上上面提到的两个权限后，再通过 <code>ldid</code> 命令对文件重新签名。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -Sdebugserver.entitlements debugserver</span><br></pre></td></tr></table></figure>
<p>然后将已经签好权限的 <code>debugserver</code> 放到 <code>/usr/bin</code> 目录，便于找到 <code>debugserver</code> 指令。</p>
<h3 id="debugserver附加到某个APP进程"><a href="#debugserver附加到某个APP进程" class="headerlink" title="debugserver附加到某个APP进程"></a>debugserver附加到某个APP进程</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ debugserver *:端口号 -a 进程</span><br></pre></td></tr></table></figure>
<ul>
<li>*:端口号：使用iPhone的某个端口启动debugserver服务（不是保留端口）</li>
<li>-a进程：输入APP的进程信息（进程ID或者进程名称）</li>
</ul>
<h3 id="Mac远程连接iPhone上的debugserver服务"><a href="#Mac远程连接iPhone上的debugserver服务" class="headerlink" title="Mac远程连接iPhone上的debugserver服务"></a>Mac远程连接iPhone上的debugserver服务</h3><p>启动LLDB：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端输入</span></span><br><span class="line">$ lldb</span><br></pre></td></tr></table></figure>
<p>连接debugserver服务</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process connect connect:<span class="comment">//手机IP地址:debugserver服务端口号</span></span><br></pre></td></tr></table></figure>
<p>使用LLDB的c命令让程序先继续运行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<p>到此，就可以远程调试别人的App了。</p>
<h3 id="常用的LLDB指令"><a href="#常用的LLDB指令" class="headerlink" title="常用的LLDB指令"></a>常用的LLDB指令</h3><ul>
<li>给ViewController的test方法设置断点</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -n <span class="string">"-[ViewController test]"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看指令用户使用 <code>help</code> 指令： <code>help breakpoint</code> 等。</li>
<li>打印线程的堆栈信息： <code>thread backtrace</code></li>
</ul>
<p>很多命令不在这里赘述，请参考：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">http://lldb.llvm.org/lldb-gdb.html</a></p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>获取 <code>ASLR</code> 的偏移量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure>
<p>打印结果的第二列前面的地址就是我们需要的 <code>ASLR</code> 的偏移量offset。</p>
<p>假如我们想给某个类中的test方法添加断点，那么通过 <code>Hooper</code> 工具找到该方法的第一个内存地址,假如为0x010101，然后地址加上我们得到的 <code>ASLR</code> 的偏移量就是该方法的实际地址。然后通过该地址给方法下断点。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -o <span class="number">0x010101</span>+offset</span><br></pre></td></tr></table></figure>
<p>到此就给该方法添加了断点，之后当程序调用该方法的时候，会停在该断点出。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>练习 <code>lldb</code> 的各种指令时，推荐先在 <code>Xcode</code> 上练习各种用法，因为会有提示和直观的输出结果，更容易我们理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。&lt;/p&gt;
&lt;h2 id=&quot;Xcode的动态调试原理&quot;&gt;&lt;a href=&quot;#Xcode的动态调试原理&quot; class
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向之logify跟踪方法调用</title>
    <link href="http://yoursite.com/2018/06/05/iOS-logify/"/>
    <id>http://yoursite.com/2018/06/05/iOS-logify/</id>
    <published>2018-06-05T04:02:04.000Z</published>
    <updated>2018-06-08T03:04:38.654Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章的介绍，我们将App的头文件使用 <code>class-dump</code> 导出后，然后利用 <code>theos</code> 创建逆向的工程，编写 <code>hook</code> 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪个方法我们不好定位，这时候就用到了 <code>logify</code> 来跟踪函数调用，从而定位到我们需要的函数。</p>
<p><code>logify</code> 是 <code>theos</code> 的一个组件，<code>logify</code> 可以将一个头文件快速转换成已经包含打印信息的xm文件。当然如果某个类中的方法很少，你完全可以自己手动添加 <code>NSLog</code> 的打印信息，但是某个文件中的方法很多的时候，收到给每个方法添加日志信息，会浪费很多很多时间，<code>logify</code> 便是一个不错的工具。</p>
<p>我们以微信的聊天界面为例，假如在当前界面我收到红包消息的时候，我想确定是响应了哪个方法，方便分析抢红包的后续操作。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>我们利用 <code>Reveal</code> 确定出了群聊界面的控制器名称为 <code>BaseMsgContentViewController</code> 并且利用 <code>class-dump</code> 将头文件导出，这个类中的方法特别多，接下来我们利用 <code>logify</code> 把该文件快速转换成已经包含打印信息的xm文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出已添加日志信息的xm文件</span></span><br><span class="line">logify.pl BaseMsgContentViewController.h &gt; Tweak.xm</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>theos</code>工程，用我们刚才生成的 <code>Tweak</code> 替换刚才创建的 <code>theos</code> 项目的<code>Tweak.xm</code>。然后重新编译打包安装。</p>
<h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p><code>logify.pl</code> 生产的xm文件，有很多时候是编译不通过的，需要进行一些处理。</p>
<ul>
<li>删除 <code>__weak</code></li>
<li>删除 <code>inout</code></li>
<li>删除协议 ,或者在头部声明一下协议，<code>@protocol XXXDelegate</code></li>
<li>删除 <code>HBLogDebug(@&quot; = 0x%x&quot;, (unsigned int)r)</code></li>
<li>替换类名为 <code>void *</code> ，比如将 <code>XXPerson *</code> 替换为 <code>void *</code> 因为都是指针类型。或者在头部声明一下，<code>@class XXPerson</code></li>
</ul>
<p>根据自己编译的时候报的具体错误，进行适当的修改即可。</p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><code>theos</code> 工程重新打包安装成功后，重新打开微信的聊天界面，然后打开 <code>Xcode -&gt; Window -&gt; Devices and Simulators</code> 即可跟踪方法的调用。</p>
<p><code>Xcode9.0</code> 之后该方法已经不方便查看了，使用 <code>syslog</code> 来实时查看日志。</p>
<p>在手机上安装两个插件：</p>
<ul>
<li>syslogd to/var/log/syslog : 记录log        </li>
<li>Core Utilities : 使用 <code>tail</code> 命令    </li>
</ul>
<p>在 <code>theos</code> 构建的逆向工程的 <code>Makefile</code> 文件中添加</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>比如查看微信的日志：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog | grep WeChat</span><br></pre></td></tr></table></figure>
<p>好了，接下来就可以根据实时查看微信的日志了，分析方法调用逻辑就一目了然了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据上一篇文章的介绍，我们将App的头文件使用 &lt;code&gt;class-dump&lt;/code&gt; 导出后，然后利用 &lt;code&gt;theos&lt;/code&gt; 创建逆向的工程，编写 &lt;code&gt;hook&lt;/code&gt; 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向解密</title>
    <link href="http://yoursite.com/2018/06/04/iOS-hacking/"/>
    <id>http://yoursite.com/2018/06/04/iOS-hacking/</id>
    <published>2018-06-04T04:02:04.000Z</published>
    <updated>2018-06-06T06:31:58.351Z</updated>
    
    <content type="html"><![CDATA[<p>学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。</p>
<h2 id="Mac远程登录iPhone"><a href="#Mac远程登录iPhone" class="headerlink" title="Mac远程登录iPhone"></a>Mac远程登录iPhone</h2><p>iOS和Mac OS X都是基于Darwin（苹果的一个基于Unix的开源系统内核），所以iOS中同样支持终端的命令行操作。    </p>
<p>在逆向工程中，我们经常会通过命令行来操纵iPhone。为了能够让Mac终端中的命令行能作用在iPhone上，我们得让Mac和iPhone建立连接。连接有两种方式：<code>wifi连接</code>和<code>usb连接</code>。</p>
<blockquote>
<p>先在越狱软件上安装ssh插件OpenSSH ,命令行下和应用交互的插件Cycript        </p>
<p>让越狱手机和mac电脑在同一个局域网下(为了能够通过ssh服务从mac电脑访问手机)</p>
<p>在mac的命令行终端 通过ssh服务登录手机 输入<code>ssh root@手机ip</code>。默认情况下的root密码是alpine。root密码可以自己修改。        </p>
<p>然后在手机上运行程序，在mac终端上利用ps -A 查看手机当前运行的进程，找到进程id后便可以利用cycript进行一些列操作。例如：进入当前运行着的微信进程的cycript状态<code>cycript -p WeChat</code></p>
</blockquote>
<p>采用<code>wifi连接</code>有时候会出现卡顿延迟的现象，所以我通常采用<code>usb连接</code>。</p>
<blockquote>
<p>Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone        </p>
<p> 我使用了两个脚本进行登录：    </p>
<ul>
<li><p><code>python ~/iOS/tcprelay.py -t 22:10010</code>进行端口的映射</p>
</li>
<li><p><code>ssh -p 10010 root@localhost</code> usb的登录</p>
</li>
</ul>
</blockquote>
<h2 id="Cycript的使用"><a href="#Cycript的使用" class="headerlink" title="Cycript的使用"></a>Cycript的使用</h2><p>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物，可以用来探索、修改、调试正在运行的Mac\iOS APP。官网：<a href="http://www.cycript.org/" target="_blank" rel="external">http://www.cycript.org</a></p>
<p>比如一些简单的使用：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信进程</span></span><br><span class="line">cycript -p WeChat</span><br><span class="line"><span class="comment">// 获得沙盒路径</span></span><br><span class="line"><span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 打印当前页面view的层级</span></span><br><span class="line"><span class="built_in">UIApp</span>.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure>
<p>主要搭配<code>Reveal</code>使用，从<code>Reveal</code>中获得某个界面或者<code>view</code>所属的类或控制器，然后拿到该类或控制器利用cycript进行调试。比如，知道了一个<code>view</code>对应的类为<code>testView</code>,想把该<code>view</code>从当前界面移除，达到不显示的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[testView removeFromSuperview];</span><br></pre></td></tr></table></figure>
<h2 id="代码Hook分析"><a href="#代码Hook分析" class="headerlink" title="代码Hook分析"></a>代码Hook分析</h2><p>如果要逆向App的某个功能少不了代码的分析。</p>
<ol>
<li><p>通过上面的分析，找到某个<code>view</code>对应的类后，就需要导出该类对应的头文件进行具体的分析了。        </p>
</li>
<li><p>首先找到App的二进制文件（Mach-O类型），（使用iFunBox把该文件导出到Mac上）然后使用class-dump工具导出其中的所有头文件，这些头文件中可以看到其中的属性和方法。<code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></p>
</li>
<li><p>如果要查看<code>Mach-O</code>文件完整信息，建议用<code>MachOView</code>。<code>otool -l</code>打印所有的 <code>Load Commands</code>，建议搭配<code>grep</code>进行正则过滤。<code>otool -L</code> 可以查看使用的库文件。</p>
</li>
<li><p>头文件分析完毕后，就可以利用<code>theos</code>进行越越代码的开发了，编译生成Tweak插件(<code>deb</code>格式)。</p>
<blockquote>
<p>利用<code>nic.pl</code>指令，选择<code>iphone/tweak</code>，创建一个tweak工程。</p>
<p>在这个tweak工程中编辑<code>Tweak.xm</code>文件，编写自己的越狱代码。</p>
<p>开发完成后利用<code>make package</code>打包和<code>make install</code>安装到手机。重启应用，你会发现对应的功能已经根据hook的代码改变了。</p>
<p>原理：iOS在越狱后，会默认安装一个名叫<code>mobilesubstrate</code>的动态库，它的作用是提供一个系统级的入侵管道，所有的<code>tweak</code>都可以依赖它来进行开发。在目标程序启动时根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序，从而达到修改内存中代码逻辑的目的。</p>
</blockquote>
</li>
<li><p>有时候想看某个类中的某个方法的实现以及调用逻辑，就需要用到<code>Hopper Disassembler</code>工具。</p>
</li>
</ol>
<h3 id="theos的常用语法"><a href="#theos的常用语法" class="headerlink" title="theos的常用语法"></a>theos的常用语法</h3><ul>
<li><p>%hook ,%end : hook一个类的开始和结束</p>
</li>
<li><p>%log：打印方法调用详情</p>
</li>
<li><p>HBDebugLog：跟NSLog类似</p>
</li>
<li><p>%new：添加一个新的方法的时候使用</p>
</li>
<li><p>%orig：函数原来的代码逻辑</p>
</li>
<li><p>%ctor：在加载动态库时调用</p>
</li>
<li><p>logify.pl：可以将一个头文件快速转换成已经包含打印信息的xm文件</p>
</li>
<li><p>如果有额外的资源文件（比如图片），放到项目的layout文件夹中，对应着手机的根路径/</p>
</li>
</ul>
<h2 id="砸壳-脱壳"><a href="#砸壳-脱壳" class="headerlink" title="砸壳(脱壳)"></a>砸壳(脱壳)</h2><p>如果使用越狱手机直接从<code>pp助手</code>下载下来的部分应用免去了我们自己脱壳的过程。但是如果是从App Store下载下来的应用，App Store已经为该应用进行了加密，再使用<code>class-dump</code>是无法导出头文件的，这是时候就需要对APP进行脱壳操作了。</p>
<p>脱壳工具有两种，<code>Clutch</code> 和 <code>dumpdecrypted</code></p>
<p><code>Clutch</code> :     </p>
<blockquote>
<p>在Mac终端登陆到iPhone后，利用Clutch脱壳</p>
<p><code>Clutch -i</code>    列举手机中已安装的应用中加密的应用。</p>
<p><code>Clutch -d  应用bundleid</code> 对加密的应用脱壳，脱壳成功后会生产新的<code>Match-O</code>文件。对这个新的文件进行<code>class-dump</code>操作即可。</p>
</blockquote>
<p>有时候使用<code>Clutch</code>脱壳，会出现失败的情况，比如脱壳微信的时候就会出现错误。这个时候就需要使用<code>dumpdecrypted</code>：    </p>
<blockquote>
<p>终端进入<code>dumpdecrypted.dylib</code>所在的目录 <code>var/root</code></p>
<p>使用环境变量 <code>DYLD_INSERT_LIBRARIES</code> 将 <code>dylib</code> 注入到需要脱壳的可执行文件（可执行文件路径可以通过<code>ps -A</code>查看获取）</p>
<p>执行命令 <code>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 可执行文件路径</code> 即可完成脱壳操作。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解以上逆向的流程后，你可以实现一些有趣的功能，比如:视频客户端去广告，修改微信运动步数，防止微信消息测回，微信自动抢红包等功能。同时，也会在自己客户端的开发过程中更注重信息的安全保护。研究逆向，一定要善于利用各种工具，并且做好不断失败的准备，愈挫愈勇，终会成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;Mac远程登录iP
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>半梦半醒之间</title>
    <link href="http://yoursite.com/2017/07/15/life-alone/"/>
    <id>http://yoursite.com/2017/07/15/life-alone/</id>
    <published>2017-07-15T13:48:10.000Z</published>
    <updated>2019-08-23T12:47:12.536Z</updated>
    
    <content type="html"><![CDATA[<p>我大清早起，<br>站在人家屋角上哑哑的啼，<br>人家讨厌我，<br>说我不吉利，<br>我不能呢呢喃喃的讨人家欢喜。        </p>
<pre><code>----胡适《乌鸦》
</code></pre><p>昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦鸣，再也无法入眠。        </p>
<p>微风拂来，撩动水波流淌，夜色安谧，远远的，这条无人问津充斥着人们欢娱后残余下的瓶瓶罐罐被迫散发着恶息的溪流，却在这座城市中勾勒出最为灿烂的一副景画，灯火延绵、十里金粉，周围楼宇檐牙鳞次栉比地伸展绵延开去，使得这一方水土宛若盘踞于地面的金龙，孕育出这座城市繁华的景象，也倒映着一个夜行人的孤寂与萧条。我捡起一块沾满泥土的石块，投向了水中落寞的身影，摇曳的月光仿佛在嘲笑一个无家可归的人，我笑着摇了摇头，拍了拍手上的尘土，愈行愈远。        </p>
<p>一念花开，一念花落，这山长水远的人世，终究是要自己走下去。            </p>
<p>世上最痛苦的事，不是生老病死，而是生命的旅程虽短，却充斥着永恒的孤寂；世上最痛苦的事，不是永恒的孤寂，而是明明看见温暖与生机，我却无能为力；世上最痛苦的事，不是我无能为力，而是当一切都触手可及，我却不愿伸出手去。后来我才知道，原来这便是生活。        </p>
<p>《这个杀手不太冷》里，马蒂尔德问里昂：生活是否永远艰辛，还是只有童年如此。里昂说：永远如此。所以我们才拼了命的读书学习，也不过是为了把自己变成更好的人，以便遇到更好的人，避开这种庸俗。        </p>
<p>罗曼·罗兰说：这世界上只有一种真正的英雄主义，就是在看清生活的真相之后，依然热爱生活。        </p>
<p>这便是真英雄吧！        </p>
<p>我想起了网上的一个场景，久久不能忘怀。那应该是一个风和日丽的午后，暖暖的阳光掠过湖水，带起一阵美丽的涟漪。我歪歪斜斜的靠在斑驳、苍老的石灰墙上，目光慵懒而且游移不定，我看见一只狗眯着眼睛淌着涎水安详的打着盹，一只花白母鸡和一只脊背上一撮毛剥掉了的大红公鸡在无聊的刨土。一辆破旧的板车，它的两只胳膊已经断了，它的下半身由于长期处于积水塘里而生出了苔藓。这时候，一阵稍微大一点的风夹杂着竹叶与竹叶摩擦的声音拂面而来，那一瞬间，我幼小的心灵就产生了怅然若失的感觉，一种莫名的、强大的、浓重的忧伤像冬天的大雾一样裹住了我。我像是被整个世界离弃了一般，全世界的人都离我而去了，只剩下我一个人独自咀嚼着孤独的滋味。人呢？人都哪里去了？我的目光再一次停留在那破旧的板车上，想象着自己总有一天会像那辆板车一样落魄、潦倒，心里就愈发沉重起来，我竟然不知不觉为那辆板车也为自己洒下了一行童年时忧伤的泪水。        </p>
<p>我抬头望向天空，原来天真的是空的！这一刻，深深的为自己的渺小与无能而感到不知所措。        </p>
<p>我抚摸着这半截老墙，不禁感叹：你刚建造的时候人们反对你，阻碍了人与人之间的距离，当人们习惯的时候又开始依赖你，把你建的又宽又高，直到最后人们渐渐的忽略了你的存在，就这样我们每个人都被你封闭在了自己的围墙里，慢慢地、一丝丝、一缕缕渗透到我们的一寸寸肌肤里，原来面对面的两个人，中间却有两座厚重的壁垒，横亘在彼此之间。我们都小心翼翼的蜷缩在自己构建的城堡里，偷窥着外面的世界，形单影只，不外如是。        </p>
<p>这一路，半梦半醒间，走走停停，却又无比的惬意和轻松。或许这就是张爱玲说的：我们都是寂寞惯了的人。        </p>
<p>于是执笔研墨，写下了这一纸寂寞。            </p>
<hr>
<p>这是一篇无病呻吟的文章，纯属是一次风格的练习尝试。大家还是应该看些正能量的文章，比如我之前写的：<a href="http://coderperson.com/2015/05/26/byeyouth/" target="_blank" rel="external">《再见-百度空间》</a>。        </p>
<p>晚安！        </p>
<p> &nbsp;</p>
<hr>
<center><br>扫描下面二维码关注公众号，干货大集合：<br><img src="https://corderguo.github.io/images/2.jpg" width="200" height="200" alt=" " align="center"><br></center>






]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我大清早起，&lt;br&gt;站在人家屋角上哑哑的啼，&lt;br&gt;人家讨厌我，&lt;br&gt;说我不吉利，&lt;br&gt;我不能呢呢喃喃的讨人家欢喜。        &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;----胡适《乌鸦》
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://yoursite.com/2017/01/02/life-2016summary/"/>
    <id>http://yoursite.com/2017/01/02/life-2016summary/</id>
    <published>2017-01-02T09:59:10.000Z</published>
    <updated>2017-01-02T10:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。</p>
<p>回首2016年，这一年是自己心态改变最大的一年，做事和考虑问题的方式和以前有了很大的不同。</p>
<p>这一年，由于工作原因和几个好朋友分开住了，所幸离得不是很远，每个星期都能聚聚，一起谈谈理想，扯扯人生，很幸运有这帮志同道合的朋友。</p>
<p>关于运动，今年坚持的还不错，从年初开始直到进入冬天，每周末至少会去奥森跑10公里或者去干部学院打一下午篮球。今年夏天还办了一张游泳卡，学会了游泳，游完泳后再去打篮球，也是累的不行。可惜进入冬天后，运动的次数明显是减少了，身体状态也不如以前了，引以为鉴。</p>
<p>今年冬天我更换了工作，这件事情对我的触动很大。我在这个项目上付出了很多，但是由于种种原因提出了离职，所幸的是后来我加入了一个很棒的团队，同时也在做一款伟大的产品。于是不爱加班的我开启了疯狂加班模式，理由很简单，我很看好这款产品。用老大的一句话就是：为了世界和平。</p>
<p>关于生活，仍然是一人吃饱全家不饿的状态。一个人过的很随便，直到周边朋友开始买车买房了，才给自己敲响了警钟，2017年该攒首付钱了。</p>
<p>关于读书，这块很惭愧，今年读的书比较少，2017年一定要多读书。日记也有半年没有写了，2017一定要坚持下来。</p>
<p>关于爱情，这块没有，略~~        </p>
<p>2016留下了很多遗憾，做错了很多事，总归是不断成长的。</p>
<p>展望2017，只有一个目标：努力提高自己！</p>
<p>再见，2016！<br>你好，2017！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。&lt;/p&gt;
&lt;p&gt;回首2016年，这一
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>访问坏内存Bug定位解决</title>
    <link href="http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/"/>
    <id>http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/</id>
    <published>2016-10-24T06:39:05.000Z</published>
    <updated>2016-10-24T06:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。</p>
<p>当对项目中的某一模块进行操作的时候遇到的错误是<code>EXC_BREAKPOINT (code=1, subcode=…)</code>而且没有任何错误log的打印。添加了<code>全局断点</code>还是没有定位到出错代码的位置，这时候就需要对xcode进行一些设置了。        </p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/EXC_BRECKPOINT.png" alt="EXC_BRECKPOINT.png"></p>
<p>xcode开启<code>僵尸模式</code>,如果遇到<code>The target process has no stack logs. Run it with the MallocStackLogging env</code>这种问题那么可以设置下<code>MallocStackLoggingNoCompact</code>为YES。</p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/malloc1.jpg" alt="zombie"></p>
<p>这个时候再对出问题的模块进行操作，会打印出<code>[testViewController retain]message sent to deallocated instance</code>的错误提示，这要就定位到了出问题的大体位置了,并且也知道了是坏内存访问的问题。</p>
<p>但是这个控制器中的代码有上千行，这个时候如何定位呢，既然是内存问题，这里就用到了内存调试工具<code>Zombies</code>了。<br>打开该工具，运行项目，当出现<code>message sent to deallocated instance</code>时候，工具会提示<code>An Objective-C message was sent to a deallocated object(zombie) at address:0x8b3b200</code>，点击提示，工具会提示可能存在内存问题的地方，然后自己看一下定位的具体代码，就能发现出现问题的地方了。    </p>
<p><img src="http://i.stack.imgur.com/qbfcb.png" alt=""></p>
<p><img src="http://i.stack.imgur.com/wpolZ.png" alt="">        </p>
<p>到这里你就应该定位到出问题代码的位置了，合理的利用调试工具，用助于我们高效率的开发。</p>
<blockquote>
<p>今天是1024，程序员的节日，祝大家节日快乐。</p>
</blockquote>
<p>参考资料在<a href="http://stackoverflow.com/questions/11170614/viewcontroller-respondstoselector-message-sent-to-deallocated-instance-crash" target="_blank" rel="external">这里</a>，欢迎大家转载，请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。&lt;/p&gt;
&lt;p&gt;当对项目中的某一模块进行操作的时候遇到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发实战</title>
    <link href="http://yoursite.com/2016/10/10/wx-progects/"/>
    <id>http://yoursite.com/2016/10/10/wx-progects/</id>
    <published>2016-10-10T03:10:55.000Z</published>
    <updated>2016-10-11T02:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信小程序做了几个小项目，感觉和以前学的ReactNavative开发有很多相似之处。</p>
<ul>
<li>骚客计算器</li>
</ul>
<p>用微信小程序搭建的简易计算器，一些计算逻辑可能还有一些问题，不过这不是重点，主要是通过这个项目练练手。里面涉及到的一些知识点：数据绑定、页面渲染、逻辑结构、事件响应、页面跳转等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-calculator.jpg" width="25%" height="25%"><br><br></center>



<ul>
<li>骚客天气</li>
</ul>
<p>用微信小程序搭建的简易天气界面，可以看到当天和未来三天的天气情况。里面涉及到的一些知识点：位置接口、网络通信、百度地图API、天气API、方法封装调用，Flex布局、模板处理、引用、列表渲染等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-weather.jpg" width="25%" height="25%"><br><br></center>        


<p>后续还会写一些简单的小应用。        </p>
<p>这些项目统一放在github上：<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">戳这里</a>，以后用微信小程序写的一些应用我也会统一放到<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="wx" scheme="http://yoursite.com/tags/wx/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天框架的搭建</title>
    <link href="http://yoursite.com/2016/09/28/iOS-weChat/"/>
    <id>http://yoursite.com/2016/09/28/iOS-weChat/</id>
    <published>2016-09-28T13:52:50.000Z</published>
    <updated>2019-01-21T07:45:55.847Z</updated>
    
    <content type="html"><![CDATA[<p><code>XZ_WeChat</code>高仿微信聊天框架的搭建，工程地址：<a href="https://github.com/corderguo/XZ_WeChat" target="_blank" rel="external">https://github.com/corderguo/XZ_WeChat</a>        </p>
<p>效果图展示：            </p>
<p><img src="https://img-blog.csdn.net/20160928230616321" alt="1"><br><img src="https://img-blog.csdn.net/20160928230519993" alt="2">        </p>
<p>做了两年IM相关工作了，去年是集成环信的SDK实现的IM功能，今年公司拥有自己的长连接服务器，于是从头自己定协议然后一步步实现了IM的整体功能，基本把微信IM有关的内容都实现了。最近开始整理过去的一些知识，于是先从聊天框架下手，整理出这个简易的聊天框架，方便大家学习交流。</p>
<p>该框架摘除了本地缓存的功能（这部分内容太多了），预留好缓存的方法，使得该框架尽可能的简洁实用，方便大家学习，我也会逐渐把该框架完善起来。    </p>
<p>由于作者的电脑环境被折腾坏了，不能安装cocoapods来管理一些用到的三方，所以直接导入进了该框架，这一点大家不要学习。</p>
<p>该框架目前支持的消息类型：文本消息（包含表情），图片消息，语音消息，视频消息，文件消息(pdf,word,excel,ppt,png,html等格式)。</p>
<p>如果你想展示文件消息，你需要把文件拷贝到沙盒的<code>/Library/Caches/Chat/File</code>目录下,由于我以前是从PC端发送文件到手机端进行的展示，所以目前只能你手动拷贝了。</p>
<p>项目中展示的视频已经转成了<code>mp4</code>类型，而且也经过了压缩，语音也转换成了<code>amr</code>格式，节省流量的同时，可以和安卓端兼容。</p>
<p>你能从该框架学习到什么：        </p>
<ul>
<li>聊天框架的搭建</li>
<li>表情键盘的实现</li>
<li>语音相关的知识</li>
<li>视频相关的知识</li>
<li>文件相关的功能</li>
<li>转场动画相关的知识</li>
<li>数据模型和尺寸模型分离</li>
<li>你能清楚的了解到在实战项目中IM的实现    </li>
</ul>
<p>目前该框架这是初步，我还有好多功能没有加入进去，后续会慢慢加入，包括：        </p>
<ul>
<li>消息的转发、拷贝、撤回</li>
<li>文章的分享</li>
<li>订阅号的功能</li>
<li>红包的功能</li>
<li>本地缓存的功能(其实很多功能都要基于数据库的，我把数据库去除掉后，很多功能就一块去除了)</li>
<li>草稿箱的功能</li>
<li>等等等还有好多好多</li>
</ul>
<hr>
<p><strong>更新日志</strong>：            </p>
<p>10月8日：添加了消息的拷贝、删除、撤回功能，由于转发功能需要用到数据库所以我只添加了转发的UI,等添加了数据库后再完善。<code>注意</code>这里的只有自己的消息并且是发送成功的消息才可以撤回，我这里限制的是<code>5分钟</code>内的消息可以撤回,超过规定时间不允许撤回。            </p>
<p>10月12日：添加了系统消息，当消息撤回的时候聊天界面上提示一条<code>你撤回了一条消息</code>的提示。当多人聊天的时候，如果一方撤回了一条消息，系统应该给你发送一条指令，根据这条指令你识别出是哪一条消息被撤回了，然后删除这条消息，并且插入一条<code>谁谁撤回了一条消息</code>。</p>
<p>10月12日：适配xcode8.0，解决bug，如果用xcode8.0的模拟器访问相册时崩溃，则换成真机即可，我也是在升级到xcode8.0后遇到的问题，问题如下：            </p>
<pre><code class="objc">objc[<span class="number">6777</span>]: Class PLBuildVersion is implemented 
<span class="keyword">in</span> both /Applications/Xcode.        
app/Contents/Developer/Platforms/iPhoneSimulator.            
platform/Developer/SDKs/iPhoneSimulator.            
sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.
framework/AssetsLibraryServices (<span class="number">0x1227c3910</span>) and        
/Applications/Xcode.app/Contents/Developer/Platforms
/iPhoneSimulator.platform/Developer/SDKs
/iPhoneSimulator.    
sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.
framework/PhotoLibraryServices (<span class="number">0x1225ed210</span>).                 
One of the two will be used. Which one is undefined.
</code></pre>
<p>奇怪的是我原项目中没有遇到该问题，而抽出来的这个聊天框架却遇到了问题，我猜想是我项目中使用了cocoapods来管理三方，而该聊天框架中我是直接导入的，稍后我会集成cocoapods，尝试问题的解决。大家若有解决方法可以给我留言，大家共同提高。</p>
<p>如果你在学习过程中有什么问题可以和我留言，大家共同提高。如果该框架能帮助到你，欢迎star，你的关注是我最大的动力，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;XZ_WeChat&lt;/code&gt;高仿微信聊天框架的搭建，工程地址：&lt;a href=&quot;https://github.com/corderguo/XZ_WeChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WeChat" scheme="http://yoursite.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>iOS之安全加密</title>
    <link href="http://yoursite.com/2016/09/02/iOS-security-encrypt/"/>
    <id>http://yoursite.com/2016/09/02/iOS-security-encrypt/</id>
    <published>2016-09-02T02:12:15.000Z</published>
    <updated>2016-09-20T08:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><hr>
<p>在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用<code>POST</code>请求提交用户的这些隐私数据。因为<code>GET</code>请求的所有参数都直接暴露在<code>URL</code>中。同时请求的<code>URL</code>一般会记录在服务器的访问日志中，服务器的访问日志是黑客攻击的重点对象之一。</p>
<p>仅仅用<code>POST</code>请求提交用户的隐私数据，还是不能完全解决数据安全的问题，我们可以利用软件（比如Charles）设置代理服务器，拦截查看手机的请求数据。因此：提交用户的隐私数据时，一定不要明文提交，要加密处理后再提交。</p>
<p>另外，我们也不应该在本地保存用户的隐私数据的<code>明文</code>。</p>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><hr>
<p>常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES。</p>
<p>针对上述加密算法，我把目前流行的几种加密方式做下分类：</p>
<ul>
<li><p>哈希（散列）函数</p>
<ul>
<li>MD5（Message Digest Algorithm 5，译为“消息摘要算法第5版”）</li>
<li>SHA1</li>
<li>SHA256            </li>
</ul>
</li>
<li><p>对称加密算法</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES(高级密码标准，美国国家安全局使用的)</li>
</ul>
</li>
<li><p>非对称加密算法</p>
<ul>
<li>RSA</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点说一下散列函数的特点：    </p>
</blockquote>
<ul>
<li>算法是公开的;</li>
<li>对相同的数据加密，得到的结果是一样的;</li>
<li>对不同的数据加密，得到的结果是定长的。例如:MD5对不同的数据进行加密，得到的结果都是32个字符长度的字符串;</li>
<li>信息摘要，信息”指纹”，是用来做数据识别的！比如:搜索;</li>
<li>不能反算的,即是不可逆的。</li>
</ul>
<p>利用这些特点，我们在项目中的应用:    </p>
<p><code>加密密码</code>：服务器并不需要知道用户真实的密码！        </p>
<p><code>搜索</code>：比如你要搜索“张老师 杨老师 苍老师”和“苍老师 张老师 杨老师”，其实这两个要搜索的内容所表达的意思是一样的，但是我们应该如何判断呢。我们可以对搜索的每个关键字进行散列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！<br>张老师            1bdf605991920db11cbdf8508204c4eb<br>杨老师             2d97fbce49977313c2aae15ea77fec0f<br>苍老师             692e92669c0ca340eff4fdcef32896ee</p>
<p><code>版权</code>: 版权保护，文件识别。例如可以对文件内容进行MD5，然后可以根据该MD5串判断文件内容是否被修改过。我以前做IM的文件上传功能就是这样判断的，如果文件内容的MD5相同，表示该文件已经在服务器存在了，就不用再次上传了。</p>
<p>由于<code>MD5</code>加密算法具有较好的安全性，而且免费，因此该加密算法被广泛使用。不过遗憾的是该加密算法已经被暴力破解了,<a href="http://www.cmd5.com" target="_blank" rel="external">http://www.cmd5.com</a>该网站记录超过24万亿条，共占用160T硬盘 的密码数据，通过对海量数据的搜索得到的结果！    </p>
<p>不过我们可以通过提升MD5加密的安全性，加大被破解的难度。    </p>
<p><code>1</code>. 加“盐”（佐料）。<br><code>2</code>. HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符。</p>
<h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><hr>
<p>RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙：使用publicKey可以对数据进行加密，使用Key才能对数据进行解密。    </p>
<p>特点：单方向传输<br>用公钥加密的数据，只有私钥能解开（可用于加密）；<br>同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍）；</p>
<p>公钥与私钥：            </p>
<p>1.权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。<br>2.私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。<br>3.公钥好比安全性极高的挂号信箱地址，公开。        </p>
<p>举例：若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤：        </p>
<ol>
<li>甲用乙的公钥对合同加密。        </li>
<li>密文从甲发送到乙。        </li>
<li>乙收到密文，并用自己的私钥对其解密。        </li>
<li>解密正确，经阅读，乙用自己的私钥对合同进行签署。        </li>
<li>乙用甲的公钥对已经签署的合同进行加密。            </li>
<li>乙将密文发给甲。        </li>
<li>甲用自己的私钥将已签署合同解密。        </li>
<li>解密正确，确认签署。        </li>
</ol>
<p>从以上步骤，我们知道：            </p>
<ol>
<li>用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。        </li>
<li>如果某份密文被解开，那么肯定是密文的目标信息主体解开的。        </li>
<li>私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。        </li>
</ol>
<h3 id="Base64补充"><a href="#Base64补充" class="headerlink" title="Base64补充"></a>Base64补充</h3><hr>
<p>1.Base64简单说明：<br>描述：Base64可以成为密码学的基石，非常重要。<br>特点：可以将任意的二进制数据进行Base64编码<br>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。<br>65字符：A~Z a~z 0~9 + / =<br>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。        </p>
<p>2.命令行进行Base64编码和解码：<br>编码：base64 123.png -o 123.txt<br>解码：base64 123.txt -o test.png -D        </p>
<p>3.Base64编码原理：<br>1)将所有字符转化为<code>ASCII</code>码；<br>2)将ASCII码转化为<code>8</code>位二进制；<br>3)将二进制<code>3</code>个归成一组(不足<code>3</code>个在后边补<code>0</code>)共<code>24</code>位，再拆分成<code>4</code>组，每组<code>6</code>位；<br>4)统一在<code>6</code>位二进制前补两个<code>0</code>凑足<code>8</code>位；<br>5)将补<code>0</code>后的二进制转为十进制；<br>6)从Base64编码表获取十进制对应的Base64编码；    </p>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个<code>24bit</code>的缓冲区中，先来的byte占高位。<br>    b.数据不足<code>3byte</code>的话，于缓冲区中剩下的bit用0补足。然后，每次取出<code>6</code>个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加<code>1</code>个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加<code>2</code>个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。        </p>
<p> 4.在项目中的应用：        </p>
<p>1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持<br>2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。</p>
<p>代码实现：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64EncodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先把字符串转换为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对base64编码后的字符串进行解码</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64DecodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.把二进制数据转换为字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终端测试命令：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n A | base64			</span><br><span class="line">$ <span class="built_in">echo</span> -n QQ== |base64 -D</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据安全&quot;&gt;&lt;a href=&quot;#数据安全&quot; class=&quot;headerlink&quot; title=&quot;数据安全&quot;&gt;&lt;/a&gt;数据安全&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用&lt;code&gt;POST&lt;/code&gt;请求提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
</feed>
