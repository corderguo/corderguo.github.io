<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客</title>
  <subtitle>菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-08T07:25:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信聊天框架的搭建</title>
    <link href="http://yoursite.com/2016/09/28/iOS-weChat/"/>
    <id>http://yoursite.com/2016/09/28/iOS-weChat/</id>
    <published>2016-09-28T13:52:50.000Z</published>
    <updated>2016-10-08T07:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>XZ_WeChat</code>高仿微信聊天框架的搭建，工程地址：<a href="https://github.com/corderguo/XZ_WeChat" target="_blank" rel="external">https://github.com/corderguo/XZ_WeChat</a>        </p>
<p>效果图展示：<img src="http://img.blog.csdn.net/20160928230616321" alt="1"><br><img src="http://img.blog.csdn.net/20160928230519993" alt="2">        </p>
<p>做了两年IM相关工作了，去年是集成环信的SDK实现的IM功能，今年公司拥有自己的长连接服务器，于是从头自己定协议然后一步步实现了IM的整体功能，基本把微信IM有关的内容都实现了。最近开始整理过去的一些知识，于是先从聊天框架下手，我从项目中抽出这个简易的聊天框架，方便大家学习交流。            </p>
<p>由于该框架是我用最快的时间从原项目中抽出来的，摘除了本地缓存的功能（这部分内容太多了），所以里面或多或少有一些我原项目中的业务逻辑，不过不要紧，这不会影响你对聊天框架的学习，我也会逐渐把该框架规范起来。        </p>
<p>由于作者的电脑环境被折腾坏了，不能安装cocoapods来管理一些用到的三方，所以直接导入进了该框架，这一点大家不要学习。</p>
<p>该框架目前支持的消息类型：文本消息（包含表情），图片消息，语音消息，视频消息，文件消息(pdf,word,excel,ppt,png,html等格式)。</p>
<p>如果你想展示文件消息，你需要把文件拷贝到沙盒的<code>/Library/Caches/Chat/File</code>目录下,由于我以前是从PC端发送文件到手机端进行的展示，所以目前只能你手动拷贝了。</p>
<p>项目中展示的视频已经转成了<code>mp4</code>类型，而且也经过了压缩，语音也转换成了<code>amr</code>格式，节省流量的同时，可以和安卓端兼容。</p>
<p>你能从该框架学习到什么：        </p>
<ul>
<li>聊天框架的搭建</li>
<li>表情键盘的实现</li>
<li>语音相关的知识</li>
<li>视频相关的知识</li>
<li>文件相关的功能</li>
<li>转场动画相关的知识</li>
<li>数据模型和尺寸模型分离</li>
<li>你能清楚的了解到在实战项目中IM的实现    </li>
</ul>
<p>目前该框架这是初步，我还有好多功能没有加入进去，后续会慢慢加入，包括：        </p>
<ul>
<li>消息的转发、拷贝、撤回</li>
<li>文章的分享</li>
<li>订阅号的功能</li>
<li>红包的功能</li>
<li>本地缓存的功能(其实很多功能都要基于数据库的，我把数据库去除掉后，很多功能就一块去除了)</li>
<li>草稿箱的功能</li>
<li>等等等还有好多好多</li>
</ul>
<hr>
<p><strong>更新日志</strong>：            </p>
<p>10月8日：添加了消息的拷贝、删除、撤回功能，由于转发功能需要用到数据库所以我只添加了转发的UI,等添加了数据库后再完善。<code>注意</code>这里的只有自己的消息并且是发送成功的消息才可以撤回，我这里限制的是<code>5分钟</code>内的消息可以撤回,超过规定时间不允许撤回。</p>
<p>如果你在学习过程中有什么问题可以和我留言，大家共同提高。如果该框架能帮助到你，欢迎star，你的关注是我最大的动力，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;XZ_WeChat&lt;/code&gt;高仿微信聊天框架的搭建，工程地址：&lt;a href=&quot;https://github.com/corderguo/XZ_WeChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WeChat" scheme="http://yoursite.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>iOS之安全加密</title>
    <link href="http://yoursite.com/2016/09/02/iOS-security-encrypt/"/>
    <id>http://yoursite.com/2016/09/02/iOS-security-encrypt/</id>
    <published>2016-09-02T02:12:15.000Z</published>
    <updated>2016-09-20T08:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><hr>
<p>在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用<code>POST</code>请求提交用户的这些隐私数据。因为<code>GET</code>请求的所有参数都直接暴露在<code>URL</code>中。同时请求的<code>URL</code>一般会记录在服务器的访问日志中，服务器的访问日志是黑客攻击的重点对象之一。</p>
<p>仅仅用<code>POST</code>请求提交用户的隐私数据，还是不能完全解决数据安全的问题，我们可以利用软件（比如Charles）设置代理服务器，拦截查看手机的请求数据。因此：提交用户的隐私数据时，一定不要明文提交，要加密处理后再提交。</p>
<p>另外，我们也不应该在本地保存用户的隐私数据的<code>明文</code>。</p>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><hr>
<p>常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES。</p>
<p>针对上述加密算法，我把目前流行的几种加密方式做下分类：</p>
<ul>
<li><p>哈希（散列）函数</p>
<ul>
<li>MD5（Message Digest Algorithm 5，译为“消息摘要算法第5版”）</li>
<li>SHA1</li>
<li>SHA256            </li>
</ul>
</li>
<li><p>对称加密算法</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES(高级密码标准，美国国家安全局使用的)</li>
</ul>
</li>
<li><p>非对称加密算法</p>
<ul>
<li>RSA</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点说一下散列函数的特点：    </p>
</blockquote>
<ul>
<li>算法是公开的;</li>
<li>对相同的数据加密，得到的结果是一样的;</li>
<li>对不同的数据加密，得到的结果是定长的。例如:MD5对不同的数据进行加密，得到的结果都是32个字符长度的字符串;</li>
<li>信息摘要，信息”指纹”，是用来做数据识别的！比如:搜索;</li>
<li>不能反算的,即是不可逆的。</li>
</ul>
<p>利用这些特点，我们在项目中的应用:    </p>
<p><code>加密密码</code>：服务器并不需要知道用户真实的密码！        </p>
<p><code>搜索</code>：比如你要搜索“张老师 杨老师 苍老师”和“苍老师 张老师 杨老师”，其实这两个要搜索的内容所表达的意思是一样的，但是我们应该如何判断呢。我们可以对搜索的每个关键字进行散列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！<br>张老师            1bdf605991920db11cbdf8508204c4eb<br>杨老师             2d97fbce49977313c2aae15ea77fec0f<br>苍老师             692e92669c0ca340eff4fdcef32896ee</p>
<p><code>版权</code>: 版权保护，文件识别。例如可以对文件内容进行MD5，然后可以根据该MD5串判断文件内容是否被修改过。我以前做IM的文件上传功能就是这样判断的，如果文件内容的MD5相同，表示该文件已经在服务器存在了，就不用再次上传了。</p>
<p>由于<code>MD5</code>加密算法具有较好的安全性，而且免费，因此该加密算法被广泛使用。不过遗憾的是该加密算法已经被暴力破解了,<a href="http://www.cmd5.com" target="_blank" rel="external">http://www.cmd5.com</a>该网站记录超过24万亿条，共占用160T硬盘 的密码数据，通过对海量数据的搜索得到的结果！    </p>
<p>不过我们可以通过提升MD5加密的安全性，加大被破解的难度。    </p>
<p><code>1</code>. 加“盐”（佐料）。<br><code>2</code>. HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符。</p>
<h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><hr>
<p>RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙：使用publicKey可以对数据进行加密，使用Key才能对数据进行解密。    </p>
<p>特点：单方向传输<br>用公钥加密的数据，只有私钥能解开（可用于加密）；<br>同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍）；</p>
<p>公钥与私钥：            </p>
<p>1.权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。<br>2.私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。<br>3.公钥好比安全性极高的挂号信箱地址，公开。        </p>
<p>举例：若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤：        </p>
<ol>
<li>甲用乙的公钥对合同加密。        </li>
<li>密文从甲发送到乙。        </li>
<li>乙收到密文，并用自己的私钥对其解密。        </li>
<li>解密正确，经阅读，乙用自己的私钥对合同进行签署。        </li>
<li>乙用甲的公钥对已经签署的合同进行加密。            </li>
<li>乙将密文发给甲。        </li>
<li>甲用自己的私钥将已签署合同解密。        </li>
<li>解密正确，确认签署。        </li>
</ol>
<p>从以上步骤，我们知道：            </p>
<ol>
<li>用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。        </li>
<li>如果某份密文被解开，那么肯定是密文的目标信息主体解开的。        </li>
<li>私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。        </li>
</ol>
<h3 id="Base64补充"><a href="#Base64补充" class="headerlink" title="Base64补充"></a>Base64补充</h3><hr>
<p>1.Base64简单说明：<br>描述：Base64可以成为密码学的基石，非常重要。<br>特点：可以将任意的二进制数据进行Base64编码<br>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。<br>65字符：A~Z a~z 0~9 + / =<br>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。        </p>
<p>2.命令行进行Base64编码和解码：<br>编码：base64 123.png -o 123.txt<br>解码：base64 123.txt -o test.png -D        </p>
<p>3.Base64编码原理：<br>1)将所有字符转化为<code>ASCII</code>码；<br>2)将ASCII码转化为<code>8</code>位二进制；<br>3)将二进制<code>3</code>个归成一组(不足<code>3</code>个在后边补<code>0</code>)共<code>24</code>位，再拆分成<code>4</code>组，每组<code>6</code>位；<br>4)统一在<code>6</code>位二进制前补两个<code>0</code>凑足<code>8</code>位；<br>5)将补<code>0</code>后的二进制转为十进制；<br>6)从Base64编码表获取十进制对应的Base64编码；    </p>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个<code>24bit</code>的缓冲区中，先来的byte占高位。<br>    b.数据不足<code>3byte</code>的话，于缓冲区中剩下的bit用0补足。然后，每次取出<code>6</code>个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加<code>1</code>个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加<code>2</code>个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。        </p>
<p> 4.在项目中的应用：        </p>
<p>1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持<br>2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。</p>
<p>代码实现：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64EncodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先把字符串转换为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对base64编码后的字符串进行解码</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64DecodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.把二进制数据转换为字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终端测试命令：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n A | base64			</span><br><span class="line">$ <span class="built_in">echo</span> -n QQ== |base64 -D</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据安全&quot;&gt;&lt;a href=&quot;#数据安全&quot; class=&quot;headerlink&quot; title=&quot;数据安全&quot;&gt;&lt;/a&gt;数据安全&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用&lt;code&gt;POST&lt;/code&gt;请求提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>关于委托代理的优化</title>
    <link href="http://yoursite.com/2016/08/20/iOS-delegate_optimized/"/>
    <id>http://yoursite.com/2016/08/20/iOS-delegate_optimized/</id>
    <published>2016-08-20T02:02:04.000Z</published>
    <updated>2016-09-06T06:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><hr>
<p>对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对象间的的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以发生相关事件时通知委托对象。</p>
<p>通常delegate对象中的方法名也一定要起得恰当才行。方法名应该准确描述当前发生的事件以及delegate对象为何要获知此事件。在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样，delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。若没有此信息，则委托对象在同一时间只能执行一套逻辑，这么做不太好。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><hr>
<p>在实现委托模式时，如果协议中的方法是可选得，那么就会写出一大批类似下面的代码来：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_delegate respondsToSelector:@selector(someClassDidSomething:)])</span><br><span class="line">&#123;</span><br><span class="line">	[_delegate someClassDidSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易用代码查出某个委托对象是否能响应特定的选择子，可是如果频繁执行此操作的话，那么除了第一次检测的结果有用之外，后续的检测可能都是多余的。如果委托对象本身没变，那么不太可能会突然响应某个原来不能响应的选择子，也不太会突然无法响应某个原来可以响应的选择子。鉴于此，我们可以把委托对象能否响应某个协议方法这一信息缓存起来，以优化程序效率。</p>
<p>将方法响应能力缓存起来的最佳途径是使用“位段”数据类型，我们可以把结构体中的字段占用的二进制位个数设为一个字节，从而用0和1表示方法是否被响应。</p>
<p>下面举个例子：</p>
<p>在“class-continuation分类”中新增实例变量，这个新增的实例变量是个结构体，用来缓存方法的响应与否。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	unsigned int didReceiveData     : 1;</span><br><span class="line">	unsigned int didFailWithError   : 1;</span><br><span class="line">&#125; _delegateFlags;</span><br></pre></td></tr></table></figure>
<p>这个结构体用来缓存委托对象是否能响应特定的选择子。实现缓存功能所用的代码可以写在delegate属性所对应的设置方法里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)<span class="built_in">set</span>Delegate:(id&lt;GXZNetWorkFetcher&gt;)delegate &#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData   = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</span><br><span class="line">	_delegateFlags.didFailWithError = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，每次调用delegate的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(_delegateFlags.didReceiveData) &#123;</span><br><span class="line">	[_dlegate networkFetcher:self didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相关方法要调用很多次时，值得进行这种优化。而是否需要优化，则应依照具体代码来定。这就需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。如果频繁的通过数据源协议从数据源中获取多份相互独立的数据，那么这项优化技术极有可能就会提高程序效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;委托模式&quot;&gt;&lt;a href=&quot;#委托模式&quot; class=&quot;headerlink&quot; title=&quot;委托模式&quot;&gt;&lt;/a&gt;委托模式&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用AVAudioPlayer遇到的奇葩问题</title>
    <link href="http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/"/>
    <id>http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/</id>
    <published>2016-08-10T13:16:15.000Z</published>
    <updated>2016-08-18T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工<br>具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    </p>
</blockquote>
<p>我开始播放音频的播放代码如下：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br><span class="line">    self.player.numberOfLoops = 0;</span><br><span class="line">    [self.player prepareToPlay];</span><br><span class="line">    self.player.delegate = self;</span><br><span class="line">    [self.player play];</span><br></pre></td></tr></table></figure>
<p>结果开始播放语音的时候，程序始终停在初始化这句：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br></pre></td></tr></table></figure>
<p>在这里你可以手动在Xcode上使程序强制运行过去，这样程序可以正常运行了，没有任何影响，这就奇了怪了。于是我在<font color="green">stackoverflow</font>上找到了一个解决方案:<br><img src="http://upload-images.jianshu.io/upload_images/1389022-a81ead68cba8f0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片">    </p>
<p>原来是我在XCode中设置了全局断点，导致audio无法播放，（但是我这里就有疑问了，同一个工具类为什么我播放IM中录音时没有问题，到这里就有问题了呢？）于是我把全局断点去掉后，程序果断正常运行了。        </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>以后遇到异常终止的情况（<strong>注意</strong>不是出错，可以手动使程序继续正常运行），可以尝试移除全局断点的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工&lt;br&gt;具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>沉痛悼念CSDN博主、年仅26岁的音视频专家雷霄骅</title>
    <link href="http://yoursite.com/2016/08/04/meidia-person/"/>
    <id>http://yoursite.com/2016/08/04/meidia-person/</id>
    <published>2016-08-04T04:30:07.000Z</published>
    <updated>2016-08-04T05:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160804134857626" alt=""></p>
<p>CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7月17日凌晨猝死在学校主楼五层，并于7月23号安葬。据相关报道称，事发前雷霄骅一直泡在实验室忙碌，怀疑其是劳累过度导致猝死。        </p>
<p>CSDN失去了一位亲密的友人，我们失去了一位深受网友爱戴的“雷大神”博主。最初当大家看到这则新闻时，除了不敢相信一再确认外，剩下的只有心痛。众多网友也自发地在多个平台表达了自己的悼念之情。<br><img src="http://img.blog.csdn.net/20160804085950156" alt=""></p>
<p>逝者的博客地址：<a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="external">http://blog.csdn.net/leixiaohua1020</a>,我很久以前就关注了雷神的博客，雷神的文章让我学到了很多东西。        </p>
<p>霄骅的博客为很多人所知，在他的博客上，有这样一段自我介绍「主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。」截止笔者发稿，这一刻CSDN上霄骅的博客数据为：    </p>
<ul>
<li>访问：4354295次</li>
<li>积分：43750</li>
<li>等级：8</li>
<li><p>排名：第52名</p>
</li>
<li><p>原创：375篇</p>
</li>
<li><p>转载：159篇</p>
</li>
<li>译文：28篇</li>
<li>评论：4985条    </li>
</ul>
<p>从此，这些数据将会灰色定格！<br>我们感谢霄骅做出的巨大贡献！而认识雷霄骅，还可以从他的相关专栏和开源项目中做更深入了解：<br>专栏:        </p>
<blockquote>
<p>FFmpeg（135篇）    </p>
<ul>
<li>开源多媒体项目源代码分析（91篇）        </li>
<li>视频质量评价（41篇）</li>
</ul>
</blockquote>
<p>开源项目列表 :            </p>
<blockquote>
<ul>
<li>[SourceForge]：<a href="https://sourceforge.net/u/leixiaohua1020/wiki/" target="_blank" rel="external">https://sourceforge.net/u/leixiaohua1020/wiki/</a><br>[Github]：<a href="http://leixiaohua1020.github.io/" target="_blank" rel="external">http://leixiaohua1020.github.io/</a></li>
<li>TIandSI：本工具用于计算视频的时间信息（TI，也称为时间复杂度），以及空间信息（SI，也称为空间复杂度），以上两个指标取自于ITU-R BT.1788标准。</li>
<li>VideoEye：一个开源的视频分析的软件。本软件可以播放和分析视频数据。它支持多种视频流输入方式：HTTP，RTMP，RTSP以及文件等等。该软件可以实时分析视频流并能以图形化的方式呈现其分析结果。目前该软件还处于完善阶段。</li>
</ul>
</blockquote>
<p>CSDN博客运营人员回忆：“一直以来，与霄骅的接触都在QQ上，第一次见面，是在CSDN老友记的活动上。在我的印象中，他是低调、内敛的男孩，他的笑容很真实，也能打动人，很真诚、乐于帮助别人的一位博客专家。”而霄骅也写了篇小短文做记录，表示不虚此行。        </p>
<p>霄骅在14年5月31日正式成为博客专家，他擅长的技术当时在CSDN上内容还不算很多，所以系列更新一下子吸引了很多人来浏览和讨论。他的博客帮助了很多人，除了在博客上回复大家的问题，以及还有自己的技术交流群，旨在为视音频技术同行方便交流提供一个平台。无论是实验室、电视台、互联网视频、安防、播放器、媒体中心等都可以加入讨论。他认为多交流可以更快的进步~        </p>
<p>乐于分享技术的他，在视音频技术做出了巨大贡献的他，当之无愧地连续两年获得CSDN年度博客之星称号。        </p>
<p>就在今年上半年，CSDN曾邀请霄骅成为其签约作者，当时霄骅提到最近要忙着写毕业设计，工作人员一直在等他忙完这阵子。结果，这个噩耗无情地到来。        </p>
<p>斯人已去，对于霄骅博文出书以及家人号召成立基金会事宜，CSDN表示都会全力支持协助。我们在沉痛悼念霄骅的同时，也呼吁所有技术开发者们，一定要照顾好自己的身体，远离病痛折磨！    </p>
<p>希望天堂里霄骅一切安好！    </p>
<p>希望从事IT行业的人员都要注重身体的健康！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160804134857626&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7
    
    </summary>
    
      <category term="资讯" scheme="http://yoursite.com/categories/%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="media" scheme="http://yoursite.com/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发各种权限问题(相机、录音等)</title>
    <link href="http://yoursite.com/2016/08/02/iOS-authorization/"/>
    <id>http://yoursite.com/2016/08/02/iOS-authorization/</id>
    <published>2016-08-02T09:13:02.000Z</published>
    <updated>2016-08-02T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，直接去调用了，这样会出现问题。        </p>
<h3 id="麦克风权限"><a href="#麦克风权限" class="headerlink" title="麦克风权限"></a>麦克风权限</h3><hr>
<p>我在项目中开发IM的录音功能的时候，没有判断当前APP是否拥有响应的权限，导致录制失败（录制出来是0kb，长度也是0毫秒）。为此我在工具类中，添加了麦克风权限的判断方法，当用户去录音的时候，如果检测到没有响应的麦克风权限，则提示用户到手机的设置页面打开麦克风的权限，当用权限的时候直接录制就可以了。   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecord</span><br><span class="line">&#123;</span><br><span class="line">    __block BOOL bCanRecord = YES;</span><br><span class="line">    <span class="keyword">if</span> ([[[UIDevice currentDevice] systemVersion] compare:@<span class="string">"7.0"</span>] != NSOrderedAscending)</span><br><span class="line">    &#123;</span><br><span class="line">        AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">        <span class="keyword">if</span> ([audioSession respondsToSelector:@selector(requestRecordPermission:)]) &#123;</span><br><span class="line">            [audioSession performSelector:@selector(requestRecordPermission:) withObject:^(BOOL granted) &#123;</span><br><span class="line">                bCanRecord = granted;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> bCanRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相机权限"><a href="#相机权限" class="headerlink" title="相机权限"></a>相机权限</h3><hr>
<p>同样在开发IM的小视屏(和微信小视屏一样)功能的时候也遇到了同样的问题，在没有判断相机权限的前提下，我手动关掉了APP的相机访问权限，则我录制视频的时候的预览页黑乎乎一片，什么也没有，同样没办法录制，这给用户的体验非常差，所以当我们调用系统资源的时候，一定要先判断是否拥有相应的权限。以下是我的判断相机权限的代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecordViedo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *mediaType = AVMediaTypeVideo;</span><br><span class="line">    AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType];</span><br><span class="line">    <span class="keyword">if</span> (authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h3><hr>
<p>其实该权限不去判断也可以，因为当你没有相册权限而去调用本机相册的时候，系统默认会pop出一个提示的页面，提示用户，没有相册权限，去手机的设置页面设置该权限。系统的这个页面还是可以的（不丑），所以我就用了系统的提示页面了。但是我还是在工具类中实现了相册权限的判断，方便以后归类。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)albumAuthority</span><br><span class="line">&#123;</span><br><span class="line">    ALAuthorizationStatus author = [ALAssetsLibrary authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (author == kCLAuthorizationStatusRestricted || author ==kCLAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h3><hr>
<p>当用户用到定位的功能的时候，也涉及到权限的问题，我顺便也实现了该功能权限的判断：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)locationAuthority</span><br><span class="line">&#123;</span><br><span class="line">    CLAuthorizationStatus status = [CLLocationManager authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (kCLAuthorizationStatusDenied == status || kCLAuthorizationStatusRestricted == status) &#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>当我们调用系统资源的时候，一定要先判断是否拥有相应的权限，做到代码的严谨性。        </p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><hr>
<p>扫码关注下面二维码，干货不断：<br><img src="http://img.blog.csdn.net/20160623095054012" alt="二维码"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于死锁的一点总结</title>
    <link href="http://yoursite.com/2016/07/23/iOS-gcd-deadlock/"/>
    <id>http://yoursite.com/2016/07/23/iOS-gcd-deadlock/</id>
    <published>2016-07-23T04:02:04.000Z</published>
    <updated>2016-09-12T10:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。        </p>
<p>例如：     </p>
<p>死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。    </p>
<h3 id="GCD导致死锁的例子"><a href="#GCD导致死锁的例子" class="headerlink" title="GCD导致死锁的例子"></a>GCD导致死锁的例子</h3><hr>
<p>比如下面的这个会产生死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以自己先分析一下该程序产生死锁的原因。    </p>
<p>我们首先要搞清楚<code>同步&amp;异步</code> <code>串行&amp;并发</code>这两组基本概念：    </p>
<blockquote>
<p>同步执行：比如dispatch_sync，这个函数会把一个block加入到指定的队列中，而且会一直等到执行完blcok，这个函数才返回。因此在block执行完之前，调用dispatch_sync方法的线程是阻塞的。        </p>
<p>异步执行：一般使用dispatch_async，这个函数也会把一个block加入到指定的队列中，但是和同步执行不同的是，这个函数把block加入队列后不等block的执行就立刻返回了。</p>
</blockquote>
<p>接下来是”串行和并行”：        </p>
<blockquote>
<p>串行队列：比如dispatch_get_main_queue,这个队列中所有任务，一定按照先来后到的顺序执行。不仅如此，还可以保证在执行某个任务时，在它前面进入队列的所有任务肯定执行完了。对于每一个不同的串行队列，系统会为这个队列建立唯一的线程来执行代码。            </p>
<p>并发队列：比如dispatch_get_global_queue,这个队列中的任务也是按照先来后到的顺序开始执行，注意是开始，但是它们的执行结束时间是不确定的，取决于每个任务的耗时。对于n个并发队列，GCD不会创建对应的n个线程而是进行适当的优化。</p>
</blockquote>
<p>理解清楚上面的两组概念后我们再来分析上面例子产生死锁的原因：        </p>
<p>该程序中在主线程中同步执行<code>dispatch_sync(queue,block)</code>任务，而该任务又被分发到了主线程<code>dispatch_get_main_queue()</code>中，这就产生了问题。程序在执行<code>dispatch_sync(queue,block)</code>时，会阻塞调用线程（在这里是主线程），等待block中的任务执行完后再返回阻塞线程继续进行执行，但是block中的任务在执行的时候又需要在主线程中执行，而现在主线程被阻塞，所以就会产生两者相互等待的情况，死锁就形成了。    </p>
<p>下面对比着总结一下<code>dispatch_sync</code>和<code>dispatch_async</code>的执行流程：        </p>
<p>（1）dispatch_sync的执行流程：</p>
<ul>
<li>将block添加到queue队列中</li>
<li>阻塞调用线程，等待block（）执行结束，回调到调用线程。</li>
</ul>
<p>（2）dispatch_async的执行流程：    </p>
<ul>
<li>将block添加到queue队列中</li>
<li>直接回到调用线程（不阻塞调用线程）,异步执行。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>下面我总结一下关于死锁的一些注意事项：    </p>
<ul>
<li>异步执行一定不会产生死锁，因为异步的执行，block会立刻返回，不会阻塞线程。所以在我们开发过程中如果遇到死锁的问题，很大可能是同步执行的原因，这样可以帮助我们快速定位。</li>
<li>不要把block任务同步派发到调用gcd所在线程的关联队列中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。   
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods更新遇redefinition问题及其它问题汇总</title>
    <link href="http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/"/>
    <id>http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/</id>
    <published>2016-07-11T08:20:30.000Z</published>
    <updated>2016-07-11T10:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。</p>
<h2 id="1、问题环境"><a href="#1、问题环境" class="headerlink" title="1、问题环境"></a>1、问题环境</h2><p>升级时所使用的命令为：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>升级后用”pod –version”查看版本号是0.39.0，升级前的版本我没记错的话应该是0.37.2.</p>
<h2 id="2、Redefinition问题"><a href="#2、Redefinition问题" class="headerlink" title="2、Redefinition问题"></a>2、Redefinition问题</h2><p>升级后遇到的最大的问题就是这个Redefinition问题了，具体情况是我的工作项目中需要增加一个新的pod引用，pod update后编译报出一大堆Redefinition问题，涉及到AFNetworking，SDWebImage等常用库，而以前都好好的，百思不得其解。        </p>
<p><a href="&quot;Redefinition of module X&quot; errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue">“Redefinition of module X” errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue</a>提到了这个问题，但我并不得要领。        </p>
<p>为了这个问题我把Pods文件夹、Podfild.lock文件删除重新更新，甚至把CocoaPods降级到0.38.2以及0.37.2版本都没有解决，然后这个过程中又遇到了其它的问题，问题怎么解决的后面再说。</p>
<p>静下心来再查看这个问题，发现错误日志里还是提供了一些关键要素，能显示重复定义在哪里。因为我一般情况下都是看默认显示在Xcode左侧栏里的错误日志列表就解决，很少展开日志详细信息。这次的关键要素就是在日志详细信息中，然后就发现了一些规律：以AFNetworking为例，我在pch文件中是这样引用的：#import &lt;AFNetworking/AFNetworking.h&gt;，然后在其它文件也做了这样的引用：#import “AFNetworking.h”。这两个引用同时存在就造成了Redefinition，去掉后者的引用方式就可以解决AFNetworking的Redefinition问题了。        </p>
<p>正常情况下肯定是用尖括号那种引用方式，但是由于历史原因，项目中使用后者那种引用方式也有不少，以前也从来没出问题，不知道现在为什么一下子就全部暴露出来了。这一改就要改不少，没办法就只能一个一个改了。        </p>
<blockquote>
<p>后记：根据最新回复，是必须得使用#import &lt; AFNetworking\/AFNetworking.h &gt;这种形式的头文件引用了，应该是检查更严格了。            </p>
</blockquote>
<p><em>我在这里遇到的问题是SDWebImage的Redefinition问题，是在pch中导入了#import &lt; SDWebImage\/UIImageView+WebCache.h &gt;，但是在其他的类中又导入了#import “UIImageView+WebCache.h”，从而引起了Redefinition问题</em>        </p>
<h2 id="3、undefined-method-project’-for-lt-Pod-Installer问题"><a href="#3、undefined-method-project’-for-lt-Pod-Installer问题" class="headerlink" title="3、undefined method `project’ for #&lt;Pod::Installer问题"></a>3、undefined method `project’ for #&lt;Pod::Installer问题</h2><p>旧版本的Podfile在升级Cocoapods后pod install就会遇到这个问题，根据这篇文章，是因为Cocoapods升级到0.38或0.39版本后installer_representation.project.targets.each中的project改名了，变成了pods_project，好在给了一个0.37——0.39都通用的办法，比如原来的Podfile是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line">post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">    installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">            config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>升级后就要改成：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.pods_project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="4、DVTAssertions-ASSERTION-FAILURE问题"><a href="#4、DVTAssertions-ASSERTION-FAILURE问题" class="headerlink" title="4、DVTAssertions: ASSERTION FAILURE问题"></a>4、DVTAssertions: ASSERTION FAILURE问题</h2><p>这是CocoaPods降级到0.37.2后pod install遇到的问题，记忆中当初好像就是因为这个问题而升级到0.39.0版本的。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[MT] DVTAssertions: ASSERTION FAILURE <span class="keyword">in</span> /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-8227/IDEFoundation/Initialization/IDEInitialization.m:590</span><br><span class="line">Details: Assertion failed: _initializationCompletedSuccessfully</span><br><span class="line">Function: BOOL IDEIsInitializedForUserInteraction()</span><br><span class="line">Thread: &#123;number = 1, name = main&#125;</span><br><span class="line">Hints: None</span><br><span class="line">Backtrace:</span><br><span class="line">0 0x000000010462aa5c -DVTAssertionHandler handleFailureInFunction:fileName:lineNumber:assertionSignature:messageFormat:arguments:</span><br><span class="line">1 0x000000010462a1e9 _DVTAssertionHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">2 0x000000010462a455 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">3 0x000000010462a3b7 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">4 0x0000000107191f5c IDEIsInitializedForUserInteraction (<span class="keyword">in</span> IDEFoundation)</span><br><span class="line">5 0x0000000109da8eb9 +PBXProject projectWithFile:errorHandler:<span class="built_in">read</span>Only:</span><br><span class="line">6 0x0000000109daaa3e +PBXProject projectWithFile:errorHandler:</span><br><span class="line">7 0x00007fff8bc68f44 ffi_call_unix64 (<span class="keyword">in</span> libffi.dylib)</span><br><span class="line">Abort <span class="built_in">trap</span>: 6</span><br></pre></td></tr></table></figure>
<p>网上大部分的帖子都说升级CocoaPods，比如这个<a href="https://github.com/CocoaPods/CocoaPods/issues/4209" target="_blank" rel="external">帖子</a>，然而具体问题具体分析好不好，我这个是降级时遇到的问题。</p>
<p>这个问题应该就是与Xcode版本有关了，实际就是与Developer的路径有关。我的Mac上同时存在有Xcode6.1.1版本与Xcode7.0版本，后者是默认的Xcode版本。</p>
<p>当CocoaPods为0.37.2版本时，对应的Developer路径应该是Xcode6.1.1版本的路径，因为这个之前一直都配合使用好好的。那么，就需要用到xcode-select问题了。通过xcode-select -p命令可以查看当前Developer路径，用xcode-select -s可以指定新的Developer路径。</p>
<p>我是这样指定的：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select <span class="_">-s</span> /Applications/Xcode6.1.1.app/Contents/Developer</span><br></pre></td></tr></table></figure>
<p>然后这个问题就不复存在了。注意当有必要使用CocoaPods 0.39.0版本时，必须得切换回来，要不然还是会遇到这个问题        </p>
<h2 id="5、CocoaPods多版本共存问题"><a href="#5、CocoaPods多版本共存问题" class="headerlink" title="5、CocoaPods多版本共存问题"></a>5、CocoaPods多版本共存问题</h2><p>本来我是想降级的，结果CocoaPods好像默认就是多版本共存了，比如我原来本来是0.37.2版本，用了本文开头的升级命令升级后，虽然用pod –version看是0.39.0版本，但是0.37.2版本并没有删除。这个可以用下面的命令查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem list --local | grep cocoapods</span><br></pre></td></tr></table></figure>
<p>如果你的只有一个版本，你可以再安装一个CocoaPods 0.38.2版本或者其它版本试试。比如安装0.38.2版本的命令就是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 0.38.2</span><br></pre></td></tr></table></figure>
<p>说是共存了，但到底是怎么共存使用呢？就比如说我的CocoaPods默认版本是0.39.0，有一个项目要用0.37.2版本的CocoaPods该怎么用呢？        </p>
<p><a href="http://stackoverflow.com/questions/28130938/how-to-switch-cocoapods-or-other-gem-version-on-command-line/28140522#28140522" target="_blank" rel="external">这里</a>有人提供了这样的一个方法，但我没有细研究，也没实践，需要用到rbenv：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rbenv global 2.1.0</span><br><span class="line">gem install cocoapods -v 0.34.4</span><br><span class="line">rbenv global 2.0.0-p0</span><br><span class="line">gem install cocoapods -v 0.33.1</span><br></pre></td></tr></table></figure>
<p>步骤:        </p>
<ul>
<li>在项目根目录下创建Gemfile，指定CocoaPods版本    </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">'~&gt; 0.37.2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行bundle install命令</li>
</ul>
<p>****************这是华丽丽的分割线o(╯□╰)o******************</p>
<p>我是在原<a href="http://www.jianshu.com/p/ee32eef74ba9" target="_blank" rel="external">文章</a>的基础上做了些许改动,总结了自己遇到的一些问题。</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之HTTPS</title>
    <link href="http://yoursite.com/2016/06/27/iOS-security-https/"/>
    <id>http://yoursite.com/2016/06/27/iOS-security-https/</id>
    <published>2016-06-27T01:42:55.000Z</published>
    <updated>2016-09-20T16:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能，屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS。        </p>
<h3 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h3><hr>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版，HTTPS = HTTP + SSL/TLS。即在HTTP下加入了SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。HTTPS的信任基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）,因此该网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。（苹果官网是强制安装证书的,不会询问用户）。</p>
<blockquote>
<p>HTTPS和HTTP的区别主要为以下四点：        </p>
</blockquote>
<p>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。        </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>如果是自己使用NSURLSession来封装网络请求，涉及代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line">   <span class="built_in">NSURLSessionDataTask</span> *task =  [session dataTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com"</span>] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [task resume];</span><br></pre></td></tr></table></figure></p>
<p>下面我们实现代理方法，在代理方法中处理证书。如果你的请求是HTTP而不是HTTPS是不走该代理方法的：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 我们需要在该方法中告诉系统, 是否信任服务器返回的证书</span><br><span class="line"> Challenge: 挑战 质问 (包含了受保护的区域)</span><br><span class="line"> protectionSpace : 受保护区域</span><br><span class="line"> NSURLAuthenticationMethodServerTrust : 证书的类型是 服务器信任</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span>, <span class="built_in">NSURLCredential</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断服务器返回的证书类型, 是否是服务器信任</span></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         NSURLSessionAuthChallengeUseCredential = 0,                   使用证书</span><br><span class="line">         NSURLSessionAuthChallengePerformDefaultHandling = 1,          忽略证书(默认的处理方式)</span><br><span class="line">         NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,   忽略书证, 并取消这次请求</span><br><span class="line">         NSURLSessionAuthChallengeRejectProtectionSpace = 3,      拒绝当前这一次, 下一次再询问</span><br><span class="line">         */</span></span><br><span class="line">        <span class="built_in">NSURLCredential</span> *card = [[<span class="built_in">NSURLCredential</span> alloc]initWithTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeUseCredential</span> , card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是使用<code>AFN</code>框架，那么我们不需要做任何额外的操作，AFN内部已经做了处理。但是对于对于自制证书的网站还需要进行一些设置：        </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line"><span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line"><span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line"><span class="comment">// 假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"><span class="comment">// 置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line"><span class="comment">// 如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 如果就是CA证书，则不需要设置上面两项，正常使用AFN即可</span></span><br><span class="line">[manager GET:url parameters:<span class="literal">nil</span> progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</span><br><span class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">	 <span class="comment">// 请求成功</span></span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>虽然HTTPS相比于HTTP来说，会有一定的性能上的劣势，但对于网络飞速发展，移动设备的性能成倍增长的今天，安全才是我们更应该去考虑的。全网HTTPS并不是那么遥远。        </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>继承的陷阱</title>
    <link href="http://yoursite.com/2016/06/20/iOS-inherit-trap/"/>
    <id>http://yoursite.com/2016/06/20/iOS-inherit-trap/</id>
    <published>2016-06-20T04:16:35.000Z</published>
    <updated>2016-09-02T02:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。</p>
<p>在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文件中去声明，而是直接在.m文件中去实现，也许为了区分，还会为方法加上类似于”xx_”这样的前缀，如图1所示，以这种方式定义”私有方法“。</p>
<p>但这只是一种障眼法，在外部调用时，确实是看不到，如果我们直接调用这些方法，编译器会报错，但如果用performSelector:来调用，依然可以正常执行。</p>
<p>上面这种问题通常可以避免。一个潜藏的问题是出现在继承体系里面。如果父类和子类的.m文件定义了两个同名的”私有方法“，则子类的方法会覆盖父类的方法，这样我们可能会在不经意间修改了父类的一些实现。</p>
<p>在继承第三方非开源库中的类时，如果遇到这种情况，会是一种很淡疼的感觉，那样你只能修改自己的方法名了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。&lt;/p&gt;
&lt;p&gt;在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift实现导航栏头像大小渐变和导航栏颜色渐变</title>
    <link href="http://yoursite.com/2016/04/12/iOS-ChangeNavImg/"/>
    <id>http://yoursite.com/2016/04/12/iOS-ChangeNavImg/</id>
    <published>2016-04-12T11:12:50.000Z</published>
    <updated>2016-08-17T06:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>github地址: <a href="https://github.com/corderguo/ChangeNavTitleImage" target="_blank" rel="external">https://github.com/corderguo/ChangeNavTitleImage</a><br>本文地址: <a href="http://coderperson.com/2016/04/12/iOS-ChangeNavImg/" target="_blank" rel="external">http://coderperson.com/2016/04/12/iOS-ChangeNavImg/</a><br>欢迎转载，请注明出处，谢谢。</p>
</blockquote>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://img.blog.csdn.net/20160702190808768" alt=""></p>
<h3 id="创建tableView"><a href="#创建tableView" class="headerlink" title="创建tableView"></a>创建tableView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 我是以懒加载的形式创建</span><br><span class="line">private lazy var tableView: UITableView = &#123;</span><br><span class="line">        <span class="built_in">let</span> tableView = UITableView(frame: self.view.bounds)</span><br><span class="line">        tableView.dataSource = self</span><br><span class="line">        tableView.delegate   = self</span><br><span class="line">        <span class="built_in">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">// 以extension的形式遵循代理 并在其中实现代理方法</span><br><span class="line">extension ViewController : UITableViewDataSource,UITableViewDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>协议的写法，不需要写&lt;&gt;        </li>
<li>刚遵循完协议的时候会报错，不用担心，那是因为还没实现代理方法</li>
<li>Swift中的懒加载和OC中的懒加载区别还是挺大的</li>
</ul>
<p>这里要注意，我是在viewDidLoad方法中注册cell的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableView.registerClass(UITableViewCell.self, <span class="keyword">for</span>CellReuseIdentifier: ID)</span><br></pre></td></tr></table></figure>
<h3 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">let</span> cell = tableView.dequeueReusableCellWithIdentifier(ID, <span class="keyword">for</span>IndexPath: indexPath)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"骚客--\(indexPath.row):http://coderperson.com"</span></span><br><span class="line">        <span class="built_in">return</span> cell</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止我们的基本界面搭建完成了，下面就是关键部分了。</p>
<h3 id="自定义titleView"><a href="#自定义titleView" class="headerlink" title="自定义titleView"></a>自定义titleView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义imageView的属性，用来操控图片的大小改变</span><br><span class="line">var imageV : UIImageView?</span><br><span class="line">// 创建</span><br><span class="line"><span class="built_in">let</span> titleV : UIView = UIView()</span><br><span class="line">navigationItem.titleView = titleV</span><br><span class="line">imageV = UIImageView(frame: CGRectMake(0, 0, 70, 70))</span><br><span class="line">imageV?.image = UIImage(named: <span class="string">"100.jpg"</span>)</span><br><span class="line">imageV?.layer.cornerRadius = 35</span><br><span class="line">imageV?.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">imageV?.center = CGPointMake(titleV.center.x, 0)</span><br><span class="line">titleV.addSubview(imageV!)</span><br></pre></td></tr></table></figure>
<p>这里不要自己单独向navigationBar上添加子控件，只需要修改titleView即可</p>
<h3 id="监听偏移量"><a href="#监听偏移量" class="headerlink" title="监听偏移量"></a>监听偏移量</h3><p>这里通过监听偏移量，实现的大小缩放动画<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        </span><br><span class="line">        // 偏移量，相对于contentView，你也可以不加scrollView.contentInset.top，即相对scrollView，然后适当调整即可</span><br><span class="line">        <span class="built_in">let</span> offsetY = scrollView.contentOffset.y + scrollView.contentInset.top</span><br><span class="line">        var scale:CGFloat = 1.0</span><br><span class="line">        <span class="keyword">if</span> offsetY &lt; 0  // 下拉</span><br><span class="line">        &#123;</span><br><span class="line">            scale = min(1.5, 1.0 - offsetY / 300.0) // 300值可以自己调整</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> offsetY &gt; 0</span><br><span class="line">        &#123;</span><br><span class="line">            // 为了防止缩小过度，给一个最小值为0.45，其中0.45 = 31.5 / 70.0，表示</span><br><span class="line">            // 头像最小是31.5像素</span><br><span class="line">            scale = max(0.45, 1 - offsetY / 300);</span><br><span class="line">        &#125;</span><br><span class="line">        // 保证缩放后y的坐标不会改变</span><br><span class="line">        imageV?.transform = CGAffineTransformMakeScale(scale, scale)</span><br><span class="line">        var frame = imageV?.frame</span><br><span class="line">        frame?.origin.y = -(imageV?.layer.cornerRadius)! / 2.0</span><br><span class="line">        imageV?.frame = frame!</span><br><span class="line">        </span><br><span class="line">        // 导航栏颜色渐变</span><br><span class="line">        changeNavColor(offsetY)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>单独抽出来的颜色渐变的方法<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private func changeNavColor(offsetY:CGFloat) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> offsetY &gt;= 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> offsetY &lt; 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0 - -offsetY / 300.0</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止你已经可以看到自己想要的效果了。        </p>
<p>Done！</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：      </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/corderguo/ChangeNavTitleImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/corde
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS中block的Strong-Weak Dance的思考</title>
    <link href="http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/"/>
    <id>http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/</id>
    <published>2016-03-24T02:10:18.000Z</published>
    <updated>2016-08-25T09:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak Dance”。        </p>
<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><hr>
<p>这是一种 强引用 –&gt; 弱引用 –&gt; 强引用 的变换过程。在弄明白为什么要如此大费周章之前，我们首先来看看一般的写法会有什么问题。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法可以避免循环引用，但是我们要考虑这样的问题：    </p>
<p><strong>假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 wself 是一个弱引用，因此会自动变为 nil。而在 KVO 中，这会导致崩溃。</strong>    </p>
<h3 id="Strong-Weak-Dance"><a href="#Strong-Weak-Dance" class="headerlink" title="Strong-Weak Dance"></a>Strong-Weak Dance</h3><hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    __strong __typeof(wself) sself = wself; // 强引用一次</span><br><span class="line">    [sself.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一来，self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁。        </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><hr>
<p>在和小伙伴的讨论过程中，他提出了几个问题。虽然都不难，但是有利于把各种知识融会贯通起来。</p>
<p>1.Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof(wself) sself = wself;</span><br></pre></td></tr></table></figure>
<p>A：会的。引用计数描述的是对象而不是指针。这句话的意思是：        </p>
<blockquote>
<p>sself 强引用 wself 指向的那个对象</p>
</blockquote>
<p>因此对象的引用计数会增加一个。</p>
<p>2.Q：block 内部定义了sself，会不会因此强引用了 sself？<br>A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题。<br>3.Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> __weak MyViewController *wself = self;</span><br><span class="line">wself.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wself) &#123; // 只有当 wself 不为 nil 时，才执行以下代码</span><br><span class="line">        [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了。</p>
<p>4.Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了。</p>
<p>A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行。另外，如果执行一个为 nil 的闭包会导致崩溃。        </p>
<p>5.Q：如果在执行 block 的过程中，block 被释放了怎么办？        </p>
<p>A：简单来说，block 还会继续执行，但是它捕获的指针会具有不确定的值，详细内容请参考<a href="http://stackoverflow.com/questions/12272783/what-happens-when-a-block-is-set-to-nil-during-its-execution" target="_blank" rel="external">这篇文章</a>    </p>
<h3 id="strongify-和-weakify"><a href="#strongify-和-weakify" class="headerlink" title="@strongify 和 @weakify"></a>@strongify 和 @weakify</h3><hr>
<p>这是<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> 中定义的一个宏。一般可以这样使用：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文并非分析它们的实现原理，所以就简单解释两点：        </p>
<ol>
<li><p>这里的“@”没有任何用处，仅表示强调，这个宏实际上包含了一个空的 AutoreleasePool，这也就是为什么一定要加上“@”。        </p>
</li>
<li><p>它的原理还是和之前一样，生成了一段形如 __weak MyViewController *wself = self; 这种格式的代码：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define rac_strongify_(INDEX, VAR) \\</span></span><br><span class="line">__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</span><br></pre></td></tr></table></figure>
<h3 id="Swift-中的情况"><a href="#Swift-中的情况" class="headerlink" title="Swift 中的情况"></a>Swift 中的情况</h3><hr>
<p>在 Swift 中也有 Strong-Weak Dance 的概念。最简单的方法就是直接沿用 OC 的思路：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">        /// ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法的缺点在于，我们不能写 if let self = self，因此需要重新定义一个变量 strongSelf，命名方式显得不够优雅。            </p>
<p>除此以外还可以使用 Swift 标准库提供的函数 withExtendedLifetime：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    withExtendedLifetime(self) &#123;</span><br><span class="line">        /// ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点在于，self 依然是可选类型的，还需要把它解封后才能使用。        </p>
<p>最后，还有一种解决方案是自定义 withExtendedLifetime函数：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Optional &#123;</span><br><span class="line">    func withExtendedLifetime(body: T -&gt; Void) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">            body(strongSelf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这种写法是否更加优雅，就见仁见智了：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    self.withExtendedLifetime &#123;</span><br><span class="line">        /// 这里用 <span class="variable">$0</span> 表示 self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于YYKit中block的细节"><a href="#关于YYKit中block的细节" class="headerlink" title="关于YYKit中block的细节"></a>关于YYKit中block的细节</h3><hr>
<p>下面是YYCache中的一段代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)_trimRecursively &#123;</span><br><span class="line">    __weak typeof(self) _self = self;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        __strong typeof(_self) self = _self;</span><br><span class="line">        <span class="keyword">if</span> (!self) <span class="built_in">return</span>;</span><br><span class="line">        [self _trimInBackground];</span><br><span class="line">        [self _trimRecursively];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：         </p>
<p>如果直接引用 strong self，那 block 创建时就会立刻强引用了 self；而如果先用 weak 引用，则 block 创建时对 self 是弱引用，而直到 block 开始执行时，self 才会被强引用。    </p>
<p>如果 block 提交到 queue 但还未执行的时候，整个 Cache 对象被释放了，那这时 weak self 就会变为 nil 了，而后 block 执行的时候 if (!self) return; 就会成立了。            </p>
<p>非常严谨！！！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><hr>
<p><a href="http://www.jianshu.com/p/4ec18161d790" target="_blank" rel="external">http://www.jianshu.com/p/4ec18161d790</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="block" scheme="http://yoursite.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发环境配置</title>
    <link href="http://yoursite.com/2016/03/20/reactNative-configure/"/>
    <id>http://yoursite.com/2016/03/20/reactNative-configure/</id>
    <published>2016-03-20T02:11:11.000Z</published>
    <updated>2016-08-26T02:46:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h3><hr>
<p>1.安装Homebrew:        </p>
<p>Homebrew是OS X的套件(包)管理器，我们可以通过它获取并且安装很多组件<br>安装方式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>2.安装npm 和 Node.js:        </p>
<p> Node.js最好安装4.0及其以上更高版本，node安装成功后npm自动也就有了，直接下载安装Node.js，网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a>        </p>
<p>3.安装WatchMan:</p>
<p>该插件用于监控bug文件和文件变化 ，并且可以触发指定的操作.        </p>
<p>安装方式:        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>4.安装Flow:</p>
<p>flow是一个JavaScript的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误.            </p>
<p>安装方式:                </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure>
<h3 id="React-Native安装"><a href="#React-Native安装" class="headerlink" title="React Native安装"></a>React Native安装</h3><hr>
<p>1.安装React Native：                    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>iOS开发环境需求:Xcode 7 及其以上更高版本.</p>
<h3 id="React-Native的第一个应用"><a href="#React-Native的第一个应用" class="headerlink" title="React Native的第一个应用"></a>React Native的第一个应用</h3><hr>
<p>1.执行命令,生成一个工程：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init 项目名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:由于众所周知的网络原因，需要等待一段时间（具体视网络情况而定）。react-native命令行从npm官方源拖代码时会遇上麻烦，可以将npm仓库源替换为国内镜像：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>
<p>2.目录结构分析:    </p>
<p>a）默认生成android和ios两个平台的原生项目；            </p>
<p>b）其中，index.android.js和index.ios.js文件为Android和iOS的空壳应用文件；</p>
<p>c）此外，node_modules文件夹，是为Node.js存放和管理npm包资源，也包含React Native框架文件。    </p>
<h3 id="管理React-Native库的版本"><a href="#管理React-Native库的版本" class="headerlink" title="管理React Native库的版本"></a>管理React Native库的版本</h3><hr>
<p>1.查看本地的React Native库的版本                               </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native --version</span><br></pre></td></tr></table></figure>
<p>2.更新本地的React Native的版本                   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>3.查询react-native的npm包最新版本                    </p>
<p>npm包地址 ：<a href="https://www.npmjs.com/package/react-native" target="_blank" rel="external">https://www.npmjs.com/package/react-native</a>         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react-native</span><br></pre></td></tr></table></figure>
<p>4.升级或者降级npm包的版本：                        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native@0.18</span><br></pre></td></tr></table></figure>
<p>5.更新项目templates文件（可选）：                 </p>
<p>新的npm包会包含更新在运行react-native init命令生成的一些动态文件，例如init创建项目的时候会生成iOS和Android的子项目，我们可以通过以下的命令进行获取最新的代码         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native upgrade</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境需求&quot;&gt;&lt;a href=&quot;#环境需求&quot; class=&quot;headerlink&quot; title=&quot;环境需求&quot;&gt;&lt;/a&gt;环境需求&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.安装Homebrew:        &lt;/p&gt;
&lt;p&gt;Homebrew是OS X的套件(包)管理器，我们可以通
    
    </summary>
    
      <category term="ReactNative" scheme="http://yoursite.com/categories/ReactNative/"/>
    
    
      <category term="RN" scheme="http://yoursite.com/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>三行代码搞定静态页面</title>
    <link href="http://yoursite.com/2016/03/15/iOS-staticPage/"/>
    <id>http://yoursite.com/2016/03/15/iOS-staticPage/</id>
    <published>2016-03-15T04:13:48.000Z</published>
    <updated>2016-06-29T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StaticPage"><a href="#StaticPage" class="headerlink" title="StaticPage"></a>StaticPage</h1><ul>
<li>静态页面大杀器，利用该库三行代码就能搞定通用静态页面</li>
<li>github地址：<a href="https://github.com/corderguo/StaticPage" target="_blank" rel="external">https://github.com/corderguo/StaticPage</a>             </li>
</ul>
<h1 id="如何使用StaticPage"><a href="#如何使用StaticPage" class="headerlink" title="如何使用StaticPage"></a>如何使用StaticPage</h1><p>首先先把你控制器中tableview的类型设置为UITableViewStyleGrouped类型      </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>只需要导入ICCommonItemCell.h头文件    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"ICCommonItemCell.h"</span></span><br></pre></td></tr></table></figure>
<p>然后在你的数据源中根据分组来设置响应的数据，例如demo中的代码:    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-(NSMutableArray *)dataArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nil == _dataArray) &#123;</span><br><span class="line">        _dataArray = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *friendItem  = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconShowAlbum"</span> title:@<span class="string">"朋友圈"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"朋友圈"</span>]; // 根据要跳转的控制器需要的参数类型，具体填写，我这里需要的是字符串类型，就传递的字符串</span><br><span class="line">        ICCommonGroup *friendGroup = [[ICCommonGroup alloc] init];</span><br><span class="line">        friendGroup.items          = @[friendItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *sweepItem    = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconQRCode"</span> title:@<span class="string">"扫一扫"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"扫一扫"</span>];</span><br><span class="line">        ICCommonItem *waveItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconShake"</span> title:@<span class="string">"摇一摇"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"摇一摇"</span>];</span><br><span class="line">        ICCommonGroup *sewaGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        sewaGroup.items            = @[sweepItem,waveItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *nearItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconLocationService"</span> title:@<span class="string">"附近的人"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"附近的人"</span>];</span><br><span class="line">        ICCommonItem *driftItem    = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconBottle"</span> title:@<span class="string">"漂流瓶"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"漂流瓶"</span>];</span><br><span class="line">        ICCommonGroup *nedrGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        nedrGroup.items            = @[nearItem,driftItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *shopItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconQRCode"</span> title:@<span class="string">"购物"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"购物"</span>];</span><br><span class="line">        ICCommonItem *gameItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"MoreGame"</span> title:@<span class="string">"游戏"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"游戏"</span>];</span><br><span class="line">        ICCommonGroup *shgaGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        shgaGroup.items            = @[shopItem,gameItem];</span><br><span class="line">        </span><br><span class="line">        [_dataArray addObject:friendGroup];</span><br><span class="line">        [_dataArray addObject:sewaGroup];</span><br><span class="line">        [_dataArray addObject:nedrGroup];</span><br><span class="line">        [_dataArray addObject:shgaGroup];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> _dataArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ICCommonGroup对应一组，而ICCommonItem又对应组中的每一个Item，每个Item有两种类型<br>，分别为ICSettingArrowItem和ICSettingSwitchItem；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)itemWithIcon:(NSString *)icon title:(NSString *)title destVcClass:(Class)destVcClass parameter:(id)parameter;</span><br></pre></td></tr></table></figure>
<p>这个方法中的参数含义：        </p>
<ul>
<li>icon：cell中左边图片的图片名        </li>
<li>title：cell的title显示的字符串内容        </li>
<li>destVcClass：点击cell时要跳转的控制器类型            </li>
<li>parameter：点击cell时要跳转时需要传递过去的参数               </li>
</ul>
<p>如果ICCommonItem中存在ICSettingSwitchItem，为了扑捉到UISwitch的开关事件，你需要遵守ICCommonItemCellDelegate，实现其中的代理方法：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)commonItemCell:(ICCommonItemCell *)cell</span><br><span class="line">                 swith:(UISwitch *)swith;</span><br></pre></td></tr></table></figure>
<p>如果想要改变每个组之间的间距（是组不是每个Item）你可以重写tableview的两个代理方法，返回自己想要的间距即可：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section</span><br><span class="line">&#123;&#125;</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>每个Item还可以在其对应的block中响应对应的事件，这样只需在tableview的didSelected方法中调用option这个block即可；         </p>
<p>如果你需要显示区头或者区尾，只需要在数据源中给对应的group设置header或footer即可：     </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ICCommonItem * discover    = [ICSettingSwitchItem itemWithIcon:nil title:@<span class="string">"置顶会话"</span> destVcClass:nil parameter:nil];</span><br><span class="line"> ICCommonItem *companyDoc   = [ICSettingSwitchItem itemWithIcon:nil title:@<span class="string">"消息免打扰"</span> destVcClass:nil parameter:nil];</span><br><span class="line">ICCommonGroup * mesGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">mesGroup.header            = @<span class="string">"来个区头玩玩"</span>;</span><br><span class="line">mesGroup.items = @[discover,companyDoc];</span><br></pre></td></tr></table></figure>
<p>然后在tableview的代理方法中调用即可：       </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    ICCommonGroup *group = self.dataArray[section];</span><br><span class="line">    <span class="built_in">return</span> group.header;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    ICCommonGroup *group = self.dataArray[section];</span><br><span class="line">    <span class="built_in">return</span> group.footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在使用过程中遇到什么问题您可以issues提问，如果你想贡献代码请pull Reques；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StaticPage&quot;&gt;&lt;a href=&quot;#StaticPage&quot; class=&quot;headerlink&quot; title=&quot;StaticPage&quot;&gt;&lt;/a&gt;StaticPage&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;静态页面大杀器，利用该库三行代码就能搞定通用静态页面&lt;/li&gt;

    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift中闭包详解</title>
    <link href="http://yoursite.com/2016/03/10/iOS-closure/"/>
    <id>http://yoursite.com/2016/03/10/iOS-closure/</id>
    <published>2016-03-10T11:12:50.000Z</published>
    <updated>2016-07-02T04:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>github地址: <a href="https://github.com/corderguo" target="_blank" rel="external">https://github.com/corderguo</a><br>本文地址: <a href="http://coderperson.com/2016/03/10/iOS-closure/" target="_blank" rel="external">http://coderperson.com/2016/03/10/iOS-closure/</a><br>欢迎转载，请注明出处，谢谢。</p>
</blockquote>
<h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><p>Swift 中闭包的概念就像是Objective-C中的block。OC中的block类似于匿名函数，闭包是用来定义函数， 同时闭包可以嵌套和作为参数传递。 在 Swift 中，函数也只不过是一种特殊的闭包         </p>
<h3 id="闭包与Block的对比"><a href="#闭包与Block的对比" class="headerlink" title="闭包与Block的对比"></a>闭包与Block的对比</h3><p>作用：</p>
<ul>
<li>Block是用来保存一段代码，在需要的时候执行 </li>
<li>闭包也是用来保存一段代码，在需要的时候执行</li>
<li>一般都是用来做耗时操作；</li>
</ul>
<p>风格：      </p>
<p>我们首先回顾一下OC中的Block写法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义block</span><br><span class="line">@property (nonatomic, copy) void(^myBlock)();</span><br><span class="line">// 定义block</span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">// 具体的回调操作</span><br><span class="line">&#125;</span><br><span class="line">// 调用block</span><br><span class="line">self.myBlock();</span><br></pre></td></tr></table></figure></p>
<p>通过回顾，我们可以想起来Block的定义格式为：     </p>
<p>Block格式：返回值类型(^block名称)(参数列表) </p>
<p>有的时候我们忘记了Block的书写格式，或者嫌这样写麻烦，我们可以直接在Xcode中敲inlineBlock<br>然后回车，系统会直接提醒你Block的样式；     </p>
<p>Swift中闭包的基本格式：         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (形参列表) -&gt; (返回值)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这些格式我们都没必要专门去记忆，我们可以直接敲系统的带有闭包或者Block的函数，然后就一目了然了；      </p>
<h4 id="闭包的几种格式"><a href="#闭包的几种格式" class="headerlink" title="闭包的几种格式"></a>闭包的几种格式</h4><p>第一种情况：        </p>
<ul>
<li>将闭包通过实参传递给函数</li>
<li>如果闭包是函数的最后一个参数，那么闭包可以写到函数{}的后面</li>
<li>如果函数只接受一个参数，并且这个参数是闭包，那么()可以省略</li>
</ul>
<p>例如下面这三种写法是一样的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义函数，参数为闭包</span><br><span class="line">func loadData(finished: () -&gt; ()) &#123;</span><br><span class="line">    //  操作</span><br><span class="line">&#125;</span><br><span class="line">// 调用（这是默认写法）</span><br><span class="line">loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">// 或者写成</span><br><span class="line">loadData (&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">// 还可以写成</span><br><span class="line"><span class="function"><span class="title">loadData</span></span>() &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况：闭包的简写  </p>
<ul>
<li>如果闭包没有参数也没有返回值，那么 in 之前的东西可以删除，包括 in</li>
</ul>
<p>例如上面闭包，还可以写成下面的形式：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其实这些格式，你在开发中只需要掌握一种即可，或者你只需要记住闭包的定义，然后敲回车，系统会为你补齐格式；</p>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><blockquote>
<p>关于闭包中的 self 问题 </p>
</blockquote>
<p>在Swift开发中，有一个原则就是能不写self就不写self，但是在闭包中必须写上self；   </p>
<p>这是因为闭包是用来保存一段代码，而且系统也不知道这段代码具体的调用时间，所以为了保证闭包中的对象不被释放，需要 self 进行一次强引用；这其实和Block中的原理差不多。   </p>
<p>所以以后看到self基本上都和闭包有关系。（这也是闭包中循环引用来源的原因）</p>
<p>下面我举一个简单的关于闭包循环引用的例子：      </p>
<p>你定义了两个控制器：OneController和TwoController，OneController只是负责push出TwoController,我们在TwoController中进行一些关于闭包的操作，然后在pop返回的时候查看该控制器是否被销毁了，来验证闭包是否发生了循环引用问题；<br>在TwoController中我们只需要简单写一些代码即可：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个闭包的属性 </span><br><span class="line">var finished: (() -&gt; ())?</span><br><span class="line">// 定义一个函数，参数为闭包</span><br><span class="line"> func loadData(finished: () -&gt; ()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"调用了"</span>)</span><br><span class="line">        self.finished = finished</span><br><span class="line">        finished();</span><br><span class="line">    &#125;</span><br><span class="line">// 函数调用</span><br><span class="line">loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">            // 这句又强引用self，导致循环引用</span><br><span class="line">            self.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;</span><br><span class="line">// 判断是否被销毁了</span><br><span class="line">deinit &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"控制器被销毁了"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行以上代码，并且从TwoController返回到OneController时，TwoController的deinit方法没有被调用，表明TwoController没有被销毁，闭包存在了循环引用的问题；     </p>
<p>这是因为：控制器通过闭包属性引用闭包，而闭包中又强引用着self(控制器),所以导致了循环引用的问题；        </p>
<blockquote>
<p>OC中关于循环引用的解决方案</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Swift中关于循环引用的解决方案</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak var weakSelf = self</span><br></pre></td></tr></table></figure>
<p>那么原先代码中只需要把self改成weakSelf即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 由于weakSelf为可选类型，这里必须保证有值，所以加上！号</span><br><span class="line">weakSelf!.view.backgroundColor = UIColor.redColor()</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><blockquote>
<p>关于定义闭包属性的问题      </p>
</blockquote>
<p>在Swift中，如果在某个类中定义一个属性，那么这个属性必须要初始化，否者会报错，如果暂时不想初始化，那么可以在后面写上一个 ? 号       </p>
<p>但是在定义闭包的属性时，一定要注意，以下这种写法是最常见的一种错误写法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 当前写法代表闭包的返回值可以是nil，而不是初始化的闭包 */</span><br><span class="line">var finished: () -&gt; ()?</span><br><span class="line"></span><br><span class="line">/** 正确写法：需要在整个闭包的后面加问号 */</span><br><span class="line">var finished: (() -&gt; ())?</span><br></pre></td></tr></table></figure>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：      </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/corderguo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/corderguo&lt;/a&gt;&lt;br&gt;本文地址: &lt;a
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>离屏渲染探究</title>
    <link href="http://yoursite.com/2015/11/28/iOS-offScreen/"/>
    <id>http://yoursite.com/2015/11/28/iOS-offScreen/</id>
    <published>2015-11-28T02:02:04.000Z</published>
    <updated>2016-07-11T10:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文地址: <a href="http://coderperson.com/2015/11/28/iOS-offScreen/" target="_blank" rel="external">http://coderperson.com/2015/11/28/iOS-offScreen/</a><br>欢迎转载，请注明出处，谢谢。    </p>
</blockquote>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>
<ul>
<li>On-Screen Rendering    </li>
</ul>
<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>
<ul>
<li>Off-Screen Rendering        </li>
</ul>
<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>GPU渲染机制：</p>
<p>CPU 计算好显示内容提交到 GPU，GPU<br>渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync<br>信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。</p>
<p>屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>
<h2 id="性能优劣"><a href="#性能优劣" class="headerlink" title="性能优劣"></a>性能优劣</h2><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<ul>
<li><p>创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>
</li>
<li><p>上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>
</li>
</ul>
<p>注意：触发离屏渲染后，上面两步会发生在每一帧，如果在界面的滚动过程中有大量的离屏渲染发生时会严重影响帧率。</p>
<h2 id="另一种特殊的“离屏渲染”"><a href="#另一种特殊的“离屏渲染”" class="headerlink" title="另一种特殊的“离屏渲染”"></a>另一种特殊的“离屏渲染”</h2><p>按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。</p>
<p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<h2 id="离屏渲染的触发机制"><a href="#离屏渲染的触发机制" class="headerlink" title="离屏渲染的触发机制"></a>离屏渲染的触发机制</h2><ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
<li>复杂形状设置圆角等</li>
<li>渐变</li>
</ul>
<p>其中shouldRasterize（光栅化）是比较特别的一种：<br>光栅化概念：将图转化为一个个栅格组成的图象。<br>光栅化特点：每个元素对应帧缓冲区中的一像素。</p>
<p>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。</p>
<p>相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。</p>
<p>当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。</p>
<p>如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。</p>
<blockquote>
<p>注意：   </p>
</blockquote>
<p>对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费</p>
<p>例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。</p>
<h2 id="官方优化"><a href="#官方优化" class="headerlink" title="官方优化"></a>官方优化</h2><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染</p>
<p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p>
<p>这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>UIImage加载图片方式一般有两种:</p>
<p>A：imagedNamed初始化</p>
<p>B：imageWithContentsOfFile初始化<br>二者不同之处在于,imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象.</p>
<p>而imageWithContentsOfFile则仅只加载图片,不缓存.</p>
<p>大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.</p>
<p>使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显.</p>
<h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><ol>
<li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li>
<li>使用ShadowPath指定layer阴影效果路径</li>
<li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li>
<li>设置layer的opaque值为YES，减少复杂图层合成</li>
<li>尽量使用不包含透明（alpha）通道的图片资源</li>
<li>尽量设置layer的大小值为整形值</li>
<li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li>
<li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li>
<li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当项目中需要离屏渲染的地方不多时，性能的影响并不是很大，基本也能保持在60fps左右，但<br>是一旦超过一定数目的圆角，滑动起来就会有明显的卡顿现象。所以，没必要为了不影响体验的情况下强行进行优化，这样做效果并不是很明显。只有当需要优化的时候采取一定的优化方案，才能得到最大的收益。            </p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文地址: &lt;a href=&quot;http://coderperson.com/2015/11/28/iOS-offScreen/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coderperson.com/2015/
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS零散知识点汇总</title>
    <link href="http://yoursite.com/2015/09/04/iOS-interview/"/>
    <id>http://yoursite.com/2015/09/04/iOS-interview/</id>
    <published>2015-09-04T04:02:04.000Z</published>
    <updated>2016-09-12T15:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runtime怎么添加属性、方法等"><a href="#runtime怎么添加属性、方法等" class="headerlink" title="runtime怎么添加属性、方法等"></a>runtime怎么添加属性、方法等</h3><ul>
<li>ivar表示成员变量</li>
<li>class_addIvar</li>
<li>class_addMethod</li>
<li>class_addProperty</li>
<li>class_addProtocol</li>
<li>class_replaceProperty</li>
</ul>
<h3 id="是否可以把比较耗时的操作放在NSNotificationCenter中"><a href="#是否可以把比较耗时的操作放在NSNotificationCenter中" class="headerlink" title="是否可以把比较耗时的操作放在NSNotificationCenter中"></a>是否可以把比较耗时的操作放在NSNotificationCenter中</h3><ul>
<li>首先必须<code>明确通知在哪个线程中发出</code>，那么处理接受到通知的方法也在这个线程中调用</li>
<li>如果在<code>异步</code>线程发的通知，那么<code>可以</code>执行比较耗时的操作；</li>
<li>如果在<code>主线程</code>发的通知，那么就<code>不可以</code>执行比较耗时的操作</li>
</ul>
<h3 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h3><ul>
<li>首先要搞清楚weak属性的特点</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span>策略表明该属性定义了一种“非拥有关系” (nonowning relationship)。</span><br><span class="line">为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同<span class="keyword">assign</span>类似;</span><br><span class="line">然而在属性所指的对象遭到摧毁时，属性值也会清空(<span class="literal">nil</span> <span class="keyword">out</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>那么runtime如何实现weak变量的自动置nil？</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime对注册的类，会进行布局，会将 <span class="keyword">weak</span> 对象放入一个 hash 表中。</span><br><span class="line">用 <span class="keyword">weak</span> 指向的对象内存地址作为 key，当此对象的引用计数为<span class="number">0</span>的时候会调用对象的 dealloc 方法，</span><br><span class="line">假设 <span class="keyword">weak</span> 指向的对象内存地址是a，那么就会以a为key，在这个 <span class="keyword">weak</span> hash表中搜索，找到所有以a为key的 <span class="keyword">weak</span> 对象，从而设置为 <span class="literal">nil</span>。</span><br></pre></td></tr></table></figure>
<h3 id="weak属性需要在dealloc中置nil么"><a href="#weak属性需要在dealloc中置nil么" class="headerlink" title="weak属性需要在dealloc中置nil么"></a>weak属性需要在dealloc中置nil么</h3><ul>
<li>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</li>
<li>即便是编译器不帮我们做这些，weak也不需要在dealloc中置nil</li>
<li>在属性所指的对象遭到摧毁时，属性值也会清空</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟下weak的setter方法，大致如下</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"object"</span>, object, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    [object cyl_runAtDealloc:^&#123;</span><br><span class="line">        _object = <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个Objective-C对象如何进行内存布局？（考虑有父类的情况）"><a href="#一个Objective-C对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="一个Objective-C对象如何进行内存布局？（考虑有父类的情况）"></a>一个Objective-C对象如何进行内存布局？（考虑有父类的情况）</h3><ul>
<li>所有<code>父类的</code>成员变量和<code>自己的</code>成员变量都会存放在该对象所对应的存储空间中</li>
<li>父类的方法和自己的方法都会缓存在类对象的方法缓存中，类方法是缓存在元类对象中</li>
<li>每一个对象内部都有一个<code>isa指针</code>,指向他的<code>类对象</code>,类对象中存放着本对象的如下信息<ul>
<li>对象方法列表</li>
<li>成员变量的列表</li>
<li>属性列表</li>
</ul>
</li>
<li>每个 Objective-C 对象都有相同的结构，如下图所示</li>
</ul>
<table>
<thead>
<tr>
<th>Objective-C 对象的结构图</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISA指针</td>
</tr>
<tr>
<td>根类(NSObject)的实例变量</td>
</tr>
<tr>
<td>倒数第二层父类的实例变量</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>父类的实例变量</td>
</tr>
<tr>
<td>类的实例变量</td>
</tr>
</tbody>
</table>
<ul>
<li>根类对象就是NSObject，它的super class指针指向nil</li>
<li>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是<code>类方法</code>列表，<code>根元类的isa指针指向自己，superclass指针指向NSObject类</code></li>
</ul>
<h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h3><ul>
<li>每一个对象内部都有一个isa指针，这个指针是指向它的真实类型</li>
<li>根据这个指针就能知道将来调用哪个类的方法</li>
</ul>
<h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>答案：都输出 Son</li>
<li><p>这个题目主要是考察关于objc中对 self 和 super 的理解：</p>
<ul>
<li>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 本质是一个<code>编译器标示符</code>，和 self 是指向的同一个消息接受者</li>
<li>当使用 self 调用方法时，会从<code>当前类</code>的方法列表中开始找，<code>如果没有</code>，就从<code>父类中再找</code>；</li>
<li>而当使用 super时，则从父类的方法列表中开始找。然后调用父类的这个方法</li>
<li><p>调用[self class] 时，会转化成 objc_msgSend函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 [super class]时，会转化成 objc_msgSendSuper函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __unsafe_unretained <span class="keyword">id</span> receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self</p>
</li>
<li>第二个成员是记录当前类的父类是什么，告诉程序从父类中开始找方法，找到方法后，最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son</li>
<li><p>objc Runtime开源代码对- (Class)class方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(Class)class &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><ul>
<li>每一个类对象中都一个对象方法列表（对象方法缓存）</li>
<li>类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）</li>
<li>方法列表中每个方法结构体中记录着方法的<code>名称</code>,<code>方法实现</code>,以及<code>参数类型</code>，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</li>
<li>当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找</li>
<li>当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</li>
</ul>
<h3 id="objc中的类方法和实例方法有什么本质区别和联系"><a href="#objc中的类方法和实例方法有什么本质区别和联系" class="headerlink" title="objc中的类方法和实例方法有什么本质区别和联系"></a>objc中的类方法和实例方法有什么本质区别和联系</h3><ul>
<li>类方法：<ul>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中<code>不能</code>访问成员变量</li>
<li>类方法中<code>不能</code>直接调用对象方法</li>
<li>类方法是存储在元类对象的方法缓存中</li>
</ul>
</li>
<li>实例方法：<ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中<code>可以调用类方法(通过类名)</code></li>
<li>实例方法是存放在类对象的方法缓存中</li>
</ul>
</li>
</ul>
<h3 id="使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>使用<code>runtime Associate</code>方法关联的对象，需要在主对象dealloc的时候释放么？</h3><ul>
<li>无论在MRC下还是ARC下<code>均不需要</code></li>
<li>被关联的对象在生命周期内要比对象本身释放的<code>晚很多</code>，它们会在被 NSObject -dealloc 调用的 <code>object_dispose()</code>方法中释放</li>
<li>补充：对象的内存销毁时间表，分四个步骤</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用 -release ：引用计数变为零</span><br><span class="line"> * 对象正在被销毁，生命周期即将结束.</span><br><span class="line"> * 不能再有新的 __<span class="keyword">weak</span> 弱引用，否则将指向 <span class="literal">nil</span>.</span><br><span class="line"> * 调用 [<span class="keyword">self</span> dealloc]</span><br><span class="line"><span class="number">2.</span> 父类调用 -dealloc</span><br><span class="line"> * 继承关系中最直接继承的父类再调用 -dealloc</span><br><span class="line"> * 如果是 MRC 代码 则会手动释放实例变量们（iVars）</span><br><span class="line"> * 继承关系中每一层的父类 都再调用 -dealloc</span><br><span class="line"><span class="number">3.</span> <span class="built_in">NSObject</span> 调 -dealloc</span><br><span class="line"> * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法</span><br><span class="line"><span class="number">4.</span> 调用 object_dispose()</span><br><span class="line"> * 为 C++ 的实例变量们（iVars）调用 destructors</span><br><span class="line"> * 为 ARC 状态下的 实例变量们（iVars） 调用 -release</span><br><span class="line"> * 解除所有使用 runtime Associate方法关联的对象</span><br><span class="line"> * 解除所有 __<span class="keyword">weak</span> 引用</span><br><span class="line"> * 调用 free()</span><br></pre></td></tr></table></figure>
<h3 id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>能否向编译后得到的类中增加<code>实例变量</code>？能否向运行时创建的类中添加<code>实例变量</code>？为什么？</h3><ul>
<li><code>不能</code>向编译后得到的类中增加<code>实例变量</code>；</li>
<li><code>能</code>向运行时创建的类中添加<code>实例变量</code>；</li>
<li>分析如下：<ul>
<li>因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list 实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime 会调用class_setIvarLayout 或 class_setWeakIvarLayout来处理strong weak引用，所以<code>不能</code>向存在的类中添加<code>实例变量</code></li>
<li>运行时创建的类是<code>可以</code>添加<code>实例变量</code>，调用 class_addIvar函数，但是得在调用objc_allocateClassPair<code>之后</code>，objc_registerClassPair<code>之前</code>，原因同上。</li>
</ul>
</li>
</ul>
<h3 id="runloop和线程有什么关系？"><a href="#runloop和线程有什么关系？" class="headerlink" title="runloop和线程有什么关系？"></a>runloop和线程有什么关系？</h3><ul>
<li>每条线程都有<code>唯一</code>的一个RunLoop对象与之对应的</li>
<li>主线程的RunLoop是<code>自动创建并启动</code></li>
<li>子线程的RunLoop需要<code>手动创建</code></li>
<li><p>子线程的RunLoop创建步骤如下：</p>
<ul>
<li>在子线程中调用[NSRunLoop currentRunLoop]创建RunLoop对象（<code>懒加载，只创建一次</code>）</li>
<li><p>获得RunLoop对象后要调用<code>run</code>方法来启动一个运行循环</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动RunLoop</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure>
</li>
<li><p>RunLoop的其他启动方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：指定运行模式</span></span><br><span class="line"><span class="comment">// 第二个参数：指定RunLoop的过期时间，即：到了这个时间后RunLoop就失效了</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:kCFRunLoopDefaultMode beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>### runloop的mode作用是什么？
</code></pre><ul>
<li>用来控制一些特殊操作只能在指定模式下运行，一般可以通过指定操作的运行mode来控制执行时机，以提高用户体验</li>
<li>系统默认注册了5个Mode<ul>
<li><code>kCFRunLoopDefaultMode</code>：App的<code>默认Mode</code>，<code>通常主线程</code>是在这个Mode下运行，对应OC中的：<code>NSDefaultRunLoopMode</code></li>
<li><code>UITrackingRunLoopMode</code>：<code>界面跟踪</code> Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li><code>kCFRunLoopCommonModes</code>:这是一个<code>标记</code>Mode，不是一种真正的Mode，事件可以运行在所有标有common modes标记的模式中，对应OC中的<code>NSRunLoopCommonModes</code>，带有common modes标记的模式有：UITrackingRunLoopMode和kCFRunLoopDefaultMode</li>
<li>UIInitializationRunLoopMode：在<code>启动</code> App时进入的第一个 Mode，<code>启动完成后就不再使用</code></li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部Mode，通常用不到</li>
</ul>
</li>
</ul>
<h3 id="以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="以+scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>以+scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><ul>
<li>这里强调一点：在主线程中以+scheduledTimerWithTimeInterval…的方式触发的timer默认是运行在<code>NSDefaultRunLoopMode</code>模式下的，当滑动页面上的列表时，进入了<code>UITrackingRunLoopMode</code>模式，这时候timer就会停止</li>
<li><p>可以修改timer的运行模式为<code>NSRunLoopCommonModes</code>，这样定时器就可以一直运行了</p>
</li>
<li><p>以下是我的笔记补充：</p>
<ul>
<li>在<code>子线程</code>中通过<code>scheduledTimerWithTimeInterval:...方法</code>来构建NSTimer<ul>
<li>方法内部已经创建NSTimer对象，并加入到RunLoop中，运行模式为NSDefaultRunLoopMode</li>
<li>由于Mode有timer对象，所以RunLoop就开始监听定时器事件了，从而开始进入运行循环</li>
<li>这个方法<code>仅仅</code>是创建RunLoop对象，并<code>不会</code>主动启动RunLoop，需要再<code>调用run方法</code>来启动</li>
</ul>
</li>
<li><p>如果在<code>主线程</code>中通过<code>scheduledTimerWithTimeInterval:...方法</code>来构建NSTimer，就不需要主动启动RunLoop对象，因为主线程的RunLoop对象在程序运行起来就已经被启动了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userInfo参数：用来给NSTimer的userInfo属性赋值，userInfo是只读的，只能在构建NSTimer对象时赋值</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="string">@"guoxianzhuang"</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// scheduledTimer...方法创建出来NSTimer虽然已经指定了默认模式，但是【允许你修改模式】</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="comment">// 【仅在子线程】需要手动启动RunLoop对象，进入运行循环</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="猜想runloop内部是如何实现的？"><a href="#猜想runloop内部是如何实现的？" class="headerlink" title="猜想runloop内部是如何实现的？"></a>猜想runloop内部是如何实现的？</h3><ul>
<li>从字面意思看：运行循环、跑圈；</li>
<li><strong><code>本质：</code></strong>内部就是<code>do-while循环</code>，在这个循环内部不断地处理各种事件(任务)，比如：Source、Timer、Observer；</li>
<li>每条线程都有<code>唯一</code>一个RunLoop对象与之对应，主线程的RunLoop默认已经启动，子线程的RunLoop需要<code>手动启动</code>；</li>
<li>每次RunLoop启动时，<code>只能</code>指定其中一个 Mode，这个Mode被称作 CurrentMode，如果需要切换Mode，只能<code>退出</code>Loop，再<code>重新指定</code>一个Mode进入，这样做主要是为了隔离不同Mode中的Source、Timer、Observer，让其互不影响；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runtime怎么添加属性、方法等&quot;&gt;&lt;a href=&quot;#runtime怎么添加属性、方法等&quot; class=&quot;headerlink&quot; title=&quot;runtime怎么添加属性、方法等&quot;&gt;&lt;/a&gt;runtime怎么添加属性、方法等&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ivar
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>iOS中使用正则表达式</title>
    <link href="http://yoursite.com/2015/08/25/iOS-regex2/"/>
    <id>http://yoursite.com/2015/08/25/iOS-regex2/</id>
    <published>2015-08-25T07:30:32.000Z</published>
    <updated>2016-08-11T15:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><hr>
<p><a href="http://coderperson.com/2015/08/14/iOS-regex/" target="_blank" rel="external">上一篇</a>已经对正则表达式做了详细的讲解，如果对正则的作用和语法不是很了解的同学可以看看。下面我们来学习在iOS中使用正则表达式。        </p>
<h3 id="方法一：谓词（NSPredicate）创建正则表达式"><a href="#方法一：谓词（NSPredicate）创建正则表达式" class="headerlink" title="方法一：谓词（NSPredicate）创建正则表达式"></a>方法一：谓词（NSPredicate）创建正则表达式</h3><hr>
<p>使用它来判断用户输入的字符串是否为合法的：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 编写正则表达式：只能是数字或英文，或两者都存在</span><br><span class="line">NSString *regex = @<span class="string">"^[a-z0－9A-Z]*$"</span>;</span><br><span class="line">// 创建谓词对象并设定条件的表达式</span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@<span class="string">"SELF MATCHES %@"</span>, regex];</span><br><span class="line">// 判断的字符串</span><br><span class="line">NSString *str = @<span class="string">"Hello100"</span>;</span><br><span class="line">// 对字符串进行判断</span><br><span class="line"><span class="keyword">if</span> ([predicate evaluateWithObject:str]) &#123;</span><br><span class="line">    NSLog(@<span class="string">"Match"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串Hello100是符合规则的，因此此例子会在日志输出”Match”。假如我们把“Hello100”换成其它字符（例如是“－、＝”），以上例子将不会输出任何东西。    </p>
<h3 id="方法二、NSString实例方法"><a href="#方法二、NSString实例方法" class="headerlink" title="方法二、NSString实例方法"></a>方法二、NSString实例方法</h3><hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *phoneNo = @<span class="string">"13143503442"</span>;</span><br><span class="line">NSRange range = [phoneNo rangeOfString:@<span class="string">"^1[3]\\d&#123;9&#125;$"</span> options:NSRegularExpressionSearch];</span><br><span class="line"><span class="keyword">if</span> (range.location != NSNotFound) &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, [phoneNo substringWithRange:range]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rangeOfString:options:会返回一个NSRange，用来接收匹配的范围，当匹配不到结果时，将会返回一个NSIntegerMax最大值，也就是NSNotFound，因此我们可以用它来判断用户输入的内容是否符合规则。        </p>
<h3 id="方法三、NSRegularExpression类创建正则表达式"><a href="#方法三、NSRegularExpression类创建正则表达式" class="headerlink" title="方法三、NSRegularExpression类创建正则表达式"></a>方法三、NSRegularExpression类创建正则表达式</h3><hr>
<p>在前言里也说过，我们可以使用正则来过滤并获取我们想要的特定部分，实现方法也很简单，可以用到NSRegularExpression这个类实现：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSString *url = @<span class="string">"1229436624@qq.com"</span>;</span><br><span class="line">NSError *error;</span><br><span class="line">// 创建NSRegularExpression对象并指定正则表达式</span><br><span class="line">NSRegularExpression *regex = [NSRegularExpression</span><br><span class="line">                              regularExpressionWithPattern:@<span class="string">"[^@]*\\."</span></span><br><span class="line">                              options:0</span><br><span class="line">                              error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!error) &#123; // 如果没有错误</span><br><span class="line">    // 获取特特定字符串的范围</span><br><span class="line">    NSTextCheckingResult *match = [regex firstMatchInString:url</span><br><span class="line">                                                    options:0</span><br><span class="line">                                                      range:NSMakeRange(0, [url length])];</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        // 截获特定的字符串</span><br><span class="line">        NSString *result = [url substringWithRange:match.range];</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; // 如果有错误，则把错误打印出来</span><br><span class="line">    NSLog(@<span class="string">"error - %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是从字符串里检索出不包含“@”并且以“.”结尾的区间字符串，最后检索出来的字符串结尾包括“.”，因此此例子最终输出结果为“qq.”        </p>
<h3 id="方法四、NSRegularExpression类之抓取多个结果"><a href="#方法四、NSRegularExpression类之抓取多个结果" class="headerlink" title="方法四、NSRegularExpression类之抓取多个结果"></a>方法四、NSRegularExpression类之抓取多个结果</h3><hr>
<p>当一个字符串有多个符合特定规则的字符，我们可以分别获取到符合特定规则的字符：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSString *regex = @<span class="string">"\\-\\d*\\."</span>;</span><br><span class="line">NSString *str = @<span class="string">"-34023242.-34203020."</span>;</span><br><span class="line">NSError *error;</span><br><span class="line">NSRegularExpression *regular = [NSRegularExpression regularExpressionWithPattern:regex</span><br><span class="line">                                                                         options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                           error:&amp;error];</span><br><span class="line">// 对str字符串进行匹配</span><br><span class="line">NSArray *matches = [regular matchesInString:str</span><br><span class="line">                                    options:0</span><br><span class="line">                                      range:NSMakeRange(0, str.length)];</span><br><span class="line">// 遍历匹配后的每一条记录</span><br><span class="line"><span class="keyword">for</span> (NSTextCheckingResult *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line">    NSRange range = [match range];</span><br><span class="line">    NSString *mStr = [str substringWithRange:range];</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, mStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从指定字符串中获取以“-”开头以“.”结尾的字符，因为可能有多个符合特定规则的字符串，因此我们需要把它们遍历出来，具体输出结果如下：        </p>
<pre><code class="sh">-34023242.        
-34203020.
</code></pre>
<p>下面列出<font color="red"><strong>matchesInString:</strong></font>方法中的<font color="green"><strong>options</strong></font>参数：    </p>
<pre><code class="sh">typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
   NSRegularExpressionCaseInsensitive             = 1 &lt;&lt; 0, //不区分字母大小写的模式
   NSRegularExpressionAllowCommentsAndWhitespace  = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和<span class="comment">#号之后的字符</span>
   NSRegularExpressionIgnoreMetacharacters        = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理
   NSRegularExpressionDotMatchesLineSeparators    = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符  
   NSRegularExpressionAnchorsMatchLines           = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾
   NSRegularExpressionUseUnixLineSeparators       = 1 &lt;&lt; 5, //设置\n为唯一的行分隔符，否则所有的都有效。
   NSRegularExpressionUseUnicodeWordBoundaries    = 1 &lt;&lt; 6 //使用Unicode TR<span class="comment">#29标准作为词的边界，否则所有传统正则表达式的词边界都有效</span>
};
</code></pre>
<p>关于匹配过程有<font color="green"><strong>四</strong></font>种方法：    </p>
<pre><code class="sh">// 返回所有匹配结果的集合
- (NSArray *)matchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;  
// 返回正确匹配的个数
- (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;  
// 返回第一个匹配的结果。注意，匹配的结果保存在  NSTextCheckingResult 类型中
- (NSTextCheckingResult *)firstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;  
// 返回第一个正确匹配结果字符串的NSRange
- (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range;
</code></pre>
<p>我们可根据具体要求选择合适的方法。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>一般来说，判断用户输入的字符是否合法，只需要使用方法一就可以了。如果是需要捕获用户输入的特定内容，可以用方法二或方法三，如果是可能有多个捕获结果，那么可以使用方法四，否则使用方法二或三。<br>针对方法三和四（<u><em>这是我最喜欢的方法</em></u>）我总结出步骤如下：    </p>
<ul>
<li>1.定义正则表达式规则</li>
<li>2.通过规则,创建正则表达式对象</li>
<li>3.利用正则表达式对象匹配字符串</li>
</ul>
<blockquote>
<p>注意:正则表达式通常缩写成“regex”    </p>
</blockquote>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><hr>
<p>首先罗列一下常见的语法：        </p>
<pre><code class="sh">@<span class="string">"^[0-9]+$"</span>
　　它代表了字符串中只能包含&gt;=1个0-9的数字，语法是不是有一些怪异？
　　下面我们先撇开iOS中的正则表达式的语法，用通俗的正则表达式语法来为介绍一下。（iOS语法与通俗的正则表达式语法相同，不同在于对转义字符的处理上(语言类的都相同)）
　　语法：
　　首先，特殊符号<span class="string">'^'</span>和<span class="string">'$'</span>。他们的作用是分别指出一个字符串的开始和结束。eg：
　　“^one”：表示所有以”one”开始的字符串（”one cat”，”one123″，·····）；
　　类似于:- (BOOL)hasPrefix:(NSString )aString;
　　“a dog$”：表示所以以”a dog”结尾的字符串（”it is a dog”，·····）；
　　类似于:- (BOOL)hasSuffix:(NSString )aString;
　　“^apple$”：表示开始和结尾都是”apple”的字符串，这个是唯一的~；
　　“banana”：表示任何包含”banana”的字符串。
　　类似于 iOS8的新方法- (BOOL)containsString:(NSString )aString,搜索子串用的。
　　‘<span class="string">'，'</span>+<span class="string">'和'</span>?<span class="string">'这三个符号，表示一个或N个字符重复出现的次数。它们分别表示“没有或更多”（[0,+∞]取整），“一次或更多”（[1,+∞]取整），“没有或一次”（[0,1]取整）。下面是几个例子：
　　“ab”：表示一个字符串有一个a后面跟着零个或若干个b（”a”, “ab”, “abbb”,……）；
　　“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多（ ”ab”, “abbb”,……）；
　　“ab?”：表示一个字符串有一个a后面跟着零个或者一个b（ ”a”, “ab”）；
　　“a?b+$”：表示在字符串的末尾有零个或一个a跟着一个或几个b（ ”b”, “ab”,”bb”,”abb”,……）。
　　可以用大括号括起来（{}），表示一个重复的具体范围。例如
　　“ab{4}”：表示一个字符串有一个a跟着4个b（”abbbb”）；
　　“ab{1,}”：表示一个字符串有一个a跟着至少1个b（”ab”,”abb”,”abbb”,……)；
　　“ab{3,4}”：表示一个字符串有一个a跟着3到4个b（”abbb”,”abbbb”)。
　　那么，“”可以用{0，}表示，“+”可以用{1，}表示，“?”可以用{0，1}表示
　　注意：可以没有下限，但是不能没有上限！例如“ab{,5}”是错误的写法
　　“ | ”表示“或”操作：
　　“a|b”：表示一个字符串里有”a”或者”b”；
　　“(a|bcd)ef”：表示”aef”或”bcdef”；
　　“(a|b)*c”：表示一串”a”"b”混合的字符串后面跟一个”c”；
　　方括号”[ ]“表示在括号内的众多字符中，选择1-N个括号内的符合语法的字符作为结果，例如
　　“[ab]“：表示一个字符串有一个”a”或”b”（相当于”a|b”）；
　　“[a-d]“：表示一个字符串包含小写的'</span>a<span class="string">'到'</span>d<span class="string">'中的一个（相当于”a|b|c|d”或者”[abcd]“）；
　　“^[a-zA-Z]“：表示一个以字母开头的字符串；
　　“[0-9]a”：表示a前有一位的数字；
　　“[a-zA-Z0-9]$”：表示一个字符串以一个字母或数字结束。
　　“.”匹配除“\r\n”之外的任何单个字符：
　　“a.[a-z]“：表示一个字符串有一个”a”后面跟着一个任意字符和一个小写字母；
　　“^.{5}$”：表示任意1个长度为5的字符串；
　　“\num” 其中num是一个正整数。表示”\num”之前的字符出现相同的个数，例如
　　“(.)\1″：表示两个连续的相同字符。
　　“10{1,2}” : 表示数字1后面跟着1或者2个0 (“10″,”100″)。
　　” 0{3,} ” 表示数字为至少3个连续的0 （“000”，“0000”，······）。
　　在方括号里用'</span>^<span class="string">'表示不希望出现的字符，'</span>^<span class="string">'应在方括号里的第一位。
　　“@[^a-zA-Z]4@”表示两个”@”中不应该出现字母）。
　　常用的还有：
　　“ \d ”匹配一个数字字符。等价于[0-9]。
　　“ \D”匹配一个非数字字符。等价于[^0-9]。
　　“ \w ”匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。
　　“ \W ”匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
　　iOS中书写正则表达式，碰到转义字符，多加一个“\”,例如：
　　全数字字符：@”^\d+$”</span>
</code></pre>
<font color="orange"><strong>常用的正则表达式:</strong></font>    


<pre><code class="sh">1.验证用户名和密码：”^[a-zA-Z]\w{5,15}$”
　　2.验证电话号码：（”^([\\d{3,4}-)\\d{7,8}$](file:///d%7B3,4%7D-)//d%7B7,8%7D$)”）
　　eg：021-68686868  0511-6868686；
　　3.验证手机号码：”^1[3|4|5|7|8][0-9]\\d{8}$”；
　　4.验证身份证号（15位或18位数字）：”\\d{14}[[0-9],0-9xX]”；
　　5.验证Email地址：(“^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$”)；
　　6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ;
　　7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$
　　8.只能输入数字：”^[0-9]*$”。
　　9.只能输入n位的数字：”^\\d{n}$”。
　　10.只能输入至少n位的数字：”^\\d{n,}$”。
　　11.只能输入m~n位的数字：”^\\d{m,n}$”。
　　12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。
　　13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。
　　14.只能输入有1~3位小数的正实数：”^[0-9]+(\.[0-9]{1,3})?$”。
　　15.只能输入非零的正整数：”^\+?[1-9][0-9]*$”。
　　16.只能输入非零的负整数：”^\-[1-9][]0-9″*$。
　　17.只能输入长度为3的字符：”^.{3}$”。
　　18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。
　　19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。
　　20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。
　　21.验证是否含有^%&amp;<span class="string">',;=?$\”等字符：”[^%&amp;'</span>,;=?$\x22]+”。
　　22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。
　　23.验证URL：<span class="string">"http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"</span>。
　　24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”10″～”12″。
　　25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″、”10″～”29″和“30”~“31”。
　　26.获取日期正则表达式：[\\d{4](file:///d%7B4)}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日?
　　评注：可用来匹配大多数年月日信息。
　　27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]
　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
　　28.匹配空白行的正则表达式：\n\s*\r
　　评注：可以用来删除空白行
　　29.匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt;
　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
　　30.匹配首尾空白字符的正则表达式：^\s*|\s*$
　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
　　31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求
　　32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
　　评注：表单验证时很实用
　　33.匹配腾讯QQ号：[1-9][0-9]\{4,\}
　　评注：腾讯QQ号从10 000 开始
　　34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)
　　评注：中国邮政编码为6位数字
　　35.匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。
</code></pre>
<h3 id="简单练习"><a href="#简单练习" class="headerlink" title="简单练习"></a>简单练习</h3><hr>
<pre><code class="sh">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
 {
    NSString *str = @<span class="string">"@jack12:【动物尖叫合辑】#肥猪流#猫头鹰这么尖叫[偷笑]、@船长: 老鼠这么尖叫、兔子这么尖叫[吃惊]、@花满楼: 莫名奇#小笼包#妙的笑到最后[好爱哦]！~ http://www.jianshu.com 电话: 17334332342"</span>;
    // 1.匹配@名字:
    // NSString *pattern = @<span class="string">"@.*?:"</span>;
    // 2.匹配URL
   // NSString *pattern = @<span class="string">"http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"</span>;
    // 3.匹配话题 <span class="comment">#....#</span>
   // NSString *pattern = @<span class="string">"#.*?#"</span>;
    // 4.手机号码匹配
    NSString *pattern = @<span class="string">"1[3578]\\d{9}$"</span>;
    NSError *error = nil;
 /*
typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) {
   NSRegularExpressionCaseInsensitive             = 1 &lt;&lt; 0, //不区分字母大小写的模式
   NSRegularExpressionAllowCommentsAndWhitespace  = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和<span class="comment">#号之后的字符</span>
   NSRegularExpressionIgnoreMetacharacters        = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理
   NSRegularExpressionDotMatchesLineSeparators    = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符  
   NSRegularExpressionAnchorsMatchLines           = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾
   NSRegularExpressionUseUnixLineSeparators       = 1 &lt;&lt; 5, //设置\n为唯一的行分隔符，否则所有的都有效。
   NSRegularExpressionUseUnicodeWordBoundaries    = 1 &lt;&lt; 6 //使用Unicode TR<span class="comment">#29标准作为词的边界，否则所有传统正则表达式的词边界都有效</span>
};
*/
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:NSRegularExpressionCaseInsensitive error:&amp;error];
    NSArray&lt;NSTextCheckingResult *&gt; *result = [regex matchesInString:str options:0 range:NSMakeRange(0, str.length)];
    <span class="keyword">if</span> (result) {
        <span class="keyword">for</span> (int i = 0; i&lt;result.count; i++) {
            NSTextCheckingResult *res = result[i];
            NSLog(@<span class="string">"str == %@"</span>, [str substringWithRange:res.range]);
        }
    }<span class="keyword">else</span>{
        NSLog(@<span class="string">"error == %@"</span>,error.description);
    }
}
</code></pre>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><hr>
<p><a href="http://www.cnblogs.com/GarveyCalvin/p/4250145.html" target="_blank" rel="external">http://www.cnblogs.com/GarveyCalvin/p/4250145.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://coderperson.com/2015/08/14/iOS-regex/&quot; target=&quot;_b
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="regex" scheme="http://yoursite.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式详解</title>
    <link href="http://yoursite.com/2015/08/14/iOS-regex/"/>
    <id>http://yoursite.com/2015/08/14/iOS-regex/</id>
    <published>2015-08-14T01:24:20.000Z</published>
    <updated>2016-08-11T10:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式到底是什么东西"><a href="#正则表达式到底是什么东西" class="headerlink" title="正则表达式到底是什么东西"></a>正则表达式到底是什么东西</h3><hr>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。    </p>
<p>很可能你使用过Windows/Dos下用于文件查找的<strong>通配符</strong>(wildcard)，也就是<font color="blue">*</font>和<font color="blue">?</font>。如果你想查找某个目录下的所有的Word文档的话，你会搜索<font color="blue">*.doc</font>。在这里，<font color="blue">*</font>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找<u>所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串</u>(像010-12345678或0376-7654321)。        </p>
<p>注解：<strong>字符</strong>是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。<strong>文本</strong>也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。        </p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><hr>
<p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。        </p>
<p>假设你在一篇英文小说里查找<u>hi</u>，你可以使用正则表达式<font color="red">hi</font>。        </p>
<p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：<u>由两个字符组成，前一个字符是h,后一个是i</u>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<em>hi,HI,Hi,hI</em>这四种情况中的任意一种。        </p>
<p>不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要<u>精确地查找hi这个单词</u>的话，我们应该使用<font color="red">\bhi\b</font>。        </p>
<p><font color="green">\b</font>是正则表达式规定的一个特殊代码（好吧，某些人叫它<strong>元字符</strong>，metacharacter），代表着<u>单词的开头或结尾，也就是单词的分界处</u>。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是<font color="blue">\b</font>并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。        </p>
<p>假如你要找的是<u>hi后面不远处跟着一个Lucy</u>，你应该用<font color="red">\bhi\b.*\bLucy\b</font>。        </p>
<p>这里，.是另一个元字符，匹配除了换行符以外的任意字符。<font color="green">*</font>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*<u>前边的内容可以连续重复使用任意次以使整个表达式得到匹配</u>。因此，.*连在一起就意味着<u>任意数量的不包含换行的字符</u>。现在<font color="red">\bhi\b.*\bLucy\b</font>的意思就很明显了：<u>先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词</u>。        </p>
<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子:        </p>
<p><font color="red">0\d\d-\d\d\d\d\d\d\d\d</font>匹配这样的字符串：<u>以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字</u>(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。        </p>
<p>这里的<font color="green">\d</font>是个新的元字符，匹配<u>一位数字(0，或1，或2，或……)</u>。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。        </p>
<p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：<font color="red">0\d{2}-\d{8}</font>。这里\d后面的{2}({8})的意思是前面\d<u>必须连续重复匹配2次(8次)</u>。        </p>
<h3 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h3><hr>
<p>推荐作者的<a href="http://deerchao.net/tools/regex_tester/index.htm" target="_blank" rel="external">正则表达式测试器</a>        </p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><hr>
<p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。        </p>
<p>下面来看看更多的例子        </p>
<p>\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。        </p>
<p>\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。            </p>
<p>\b\w{6}\b 匹配刚好6个字符的单词。        </p>
<p>常用的元字符：    </p>
<ul>
<li>.    匹配除换行符以外的任意字符    </li>
<li>\w    匹配字母或数字或下划线或汉字    </li>
<li>\s    匹配任意的空白符    </li>
<li>\d    匹配数字    </li>
<li>\b    匹配单词的开始或结束    </li>
<li>^    匹配字符串的开始    </li>
<li>$    匹配字符串的结束    </li>
</ul>
<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。        </p>
<p>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。        </p>
<p>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。        </p>
<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。        </p>
<h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><hr>
<p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。        </p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><hr>
<p>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：        </p>
<p>常用的限定符:    </p>
<ul>
<li>*    重复零次或更多次</li>
<li>+    重复一次或更多次</li>
<li>?    重复零次或一次</li>
<li>{n}    重复n次</li>
<li>{n,}    重复n次或更多次</li>
<li>{n,m}    重复n到m次        </li>
</ul>
<p>下面是一些使用重复的例子：<br>Windows\d+匹配Windows后面跟1个或更多数字<br>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)        </p>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><hr>
<p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？        </p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。        </p>
<p>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。        </p>
<p>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。        </p>
<h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><hr>
<p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：        </p>
<p>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。        </p>
<p>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。            </p>
<p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。        </p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><hr>
<p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。        </p>
<p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。        </p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。        </p>
<p>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。        </p>
<h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><hr>
<p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：        </p>
<p>常用的反义代码：        </p>
<ul>
<li>\W    匹配任意不是字母，数字，下划线，汉字的字符</li>
<li>\S    匹配任意不是空白符的字符</li>
<li>\D    匹配任意非数字的字符</li>
<li>\B    匹配不是单词开头或结束的位置</li>
<li>[^x]    匹配除了x以外的任意字符</li>
<li>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符        </li>
</ul>
<p>例子：\S+匹配不包含空白符的字符串。<br><a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串。        </a[^></p>
<h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><hr>
<p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。        </p>
<p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：        </p>
<p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。        </p>
<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：\b(?<word>\w+)\b\s+\k<word>\b。        </word></word></word></word></p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：<br>捕获<br>(exp)    匹配exp,并捕获文本到自动命名的组里<br>(?<name>exp)    匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br>(?:exp)    匹配exp,不捕获匹配的文本，也不给此分组分配组号            </name></p>
<p>零宽断言<br>(?=exp)    匹配exp前面的位置<br>(?&lt;=exp)    匹配exp后面的位置<br>(?!exp)    匹配后面跟的不是exp的位置<br>(?&lt;!exp)    匹配前面不是exp的位置            </p>
<p>注释<br>(?#comment)    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读    </p>
<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？        </p>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><hr>
<p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。        </p>
<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：        </p>
<p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。        </p>
<p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。        </p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。        </p>
<p>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><hr>
<p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：        </p>
<p>\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。        </p>
<p>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。        </p>
<p>同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。        </p>
<p>一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是\<b\>)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是\<b\>的话，后缀就是\</b\>了。整个表达式匹配的是\<b\>和\</b\>之间的内容(再次提醒，不包括前缀和后缀本身)。        </b\></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><hr>
<p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。        </p>
<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：        </p>
<p>(?&lt;=   # 断言要匹配的文本的前缀<br>      &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br>      )       # 前缀结束<br>      .*      # 匹配任意文本<br>      (?=     # 断言要匹配的文本的后缀<br>      &lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br>      )       # 后缀结束    </p>
<h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><hr>
<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。        </p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：        </p>
<p>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。          </p>
<p>懒惰限定符:    </p>
<ul>
<li>*?    重复任意次，但尽可能少重复</li>
<li>+?    重复1次或更多次，但尽可能少重复</li>
<li>??    重复0次或1次，但尽可能少重复</li>
<li>{n,m}?    重复n到m次，但尽可能少重复</li>
<li>{n,}?    重复n次以上，但尽可能少重复</li>
</ul>
<h3 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h3><hr>
<p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？        </p>
<p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb=""> <bbb> aa&gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？        </bbb></aa></p>
<p>这里需要用到以下的语法构造：        </p>
<ul>
<li>(?’group’) 把捕获的内容命名为group,并压入堆栈(Stack)</li>
<li>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>
<li>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>
<li>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败        </li>
</ul>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。        </p>
<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]*&gt;[^&lt;&gt;]*(((?’Open’<div[^>]*&gt;)[^&lt;&gt;]*)+((?’-Open’</div[^></div[^></div>)[^&lt;&gt;]*)+)*(?(Open)(?!))</p>
<blockquote>
<p>本文引用之<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">这里</a>，感谢作者的付出。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正则表达式到底是什么东西&quot;&gt;&lt;a href=&quot;#正则表达式到底是什么东西&quot; class=&quot;headerlink&quot; title=&quot;正则表达式到底是什么东西&quot;&gt;&lt;/a&gt;正则表达式到底是什么东西&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="regex" scheme="http://yoursite.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>读书系列-《别让情绪失控害了你》</title>
    <link href="http://yoursite.com/2015/07/26/book-mood/"/>
    <id>http://yoursite.com/2015/07/26/book-mood/</id>
    <published>2015-07-26T09:59:12.000Z</published>
    <updated>2016-08-26T04:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>沙场点兵，卧品书香！        </p>
<p>昨天在公司看到这本书《别让情绪失控害了你》，感觉不错，今天上午躺在床上读了几章，获益匪浅！虽然有些大道理我们都懂，但是当我们在生活中真正遇到事情的时候，真正做到坐怀不乱的又有几人？！静下心来好好读书，想想发生在自己身上的一些事情，当时的做法和看法现在想来多半是不正确甚至是不理智的。        </p>
<p>人非圣贤，孰能无过！我们都是在经历和错误中逐渐提高的，控制自己的情绪，修炼自己的素养，无需山崩于眼前我自岿然不动，但却要有长坂坡前一声吼的气势！      </p>
<p>幸福是自找的，麻烦也是自找的。运气不会青睐悲观失意的人，当我们认为生活很不幸，那么我们就真的陷入了不幸之中。事实上，我们最大的敌人就是错误的发挥自己的想象力，我们总是觉得自己不幸福、不快乐，被忽视了，被议论了，被生活抛弃了，这些错觉，正是导致我们陷入无边无际的痛苦原因。        </p>
<p>积极的行动可以带动观念的转变。只要将一个人的心态由恐惧转化为昂扬向上，就能克服任何障碍。只要一个的动作和表情表现出勇敢而非恐惧，他就能勇敢奋进起来。      </p>
<p>保持心境平和，内心才会充满喜悦。在这个追名逐利浮躁的当下，能保持一个平常心，实属难能可贵！        </p>
<p>入睡前花点时间想一下自己这一天都干了什么，这种习惯可以帮助我们更好地与人与己相处。但是入睡前盯着手机麻醉自己仿佛成了我们生活的规律。      </p>
<p>学会正面思维，你可以反败为胜。人具有反败为胜的力量。同一个窗口，一个人看到泥泞满地，一个人看到的是星辰漫天，这便值得我们思考。        </p>
<p>好事多磨！     </p>
<p>学会乐观，多数担忧都是多余的！      </p>
<p>不应该抱怨生活，你所寻求的安慰话语中，很少包含着你需要的东西。      </p>
<p>从不浪费时间的人，没有功夫抱怨时间的不够！      </p>
<p>世界并无好坏之分，只是我们如何去想！改变认知，就能管住情绪不失控。    </p>
<blockquote>
<p>好脑袋不如一个烂笔头，记录下此时此刻的感想感知，不断的鞭策自己，也希望对大家有所帮助。                    </p>
</blockquote>
<hr>
<p>扫描下面二维码关注公众号，时不时的会有惊喜：<br><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;沙场点兵，卧品书香！        &lt;/p&gt;
&lt;p&gt;昨天在公司看到这本书《别让情绪失控害了你》，感觉不错，今天上午躺在床上读了几章，获益匪浅！虽然有些大道理我们都懂，但是当我们在生活中真正遇到事情的时候，真正做到坐怀不乱的又有几人？！静下心来好好读书，想想发生在自己身上的一
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
