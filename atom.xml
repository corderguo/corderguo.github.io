<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客</title>
  <subtitle>菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-02T09:53:14.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/01/02/life-2016summary/"/>
    <id>http://yoursite.com/2017/01/02/life-2016summary/</id>
    <published>2017-01-02T08:02:33.000Z</published>
    <updated>2017-01-02T09:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 2016年度总结<br>date: 2017-01-02 17:49:10<br>categories: 生活</p>
<h2 id="tags-情感"><a href="#tags-情感" class="headerlink" title="tags: 情感"></a>tags: 情感</h2><p>今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。</p>
<p>回首2016年，这一年是自己心态改变最大的一年，做事和考虑问题的方式和以前有了很大的不同。</p>
<p>这一年，由于工作原因和几个好朋友分开住了，所幸离得不是很远，每个星期都能聚聚，一起谈谈理想，扯扯人生，很幸运有这帮志同道合的朋友。</p>
<p>关于运动，今年坚持的还不错，从年初开始直到进入冬天，每周末至少会去奥森跑10公里或者去干部学院打一下午篮球。今年夏天还办了一张游泳卡，学会了游泳，游完泳后再去打篮球，也是累的不行。可惜进入冬天后，运动的次数明显是减少了，身体状态也不如以前了，引以为鉴。</p>
<p>今年冬天我更换了工作，这件事情对我的触动很大。我在这个项目上付出了很多，但是由于种种原因提出了离职，所幸的是后来我加入了一个很棒的团队，同时也在做一款伟大的产品。于是不爱加班的我开启了疯狂加班模式，理由很简单，我很看好这款产品。用老大的一句话就是：为了世界和平。</p>
<p>关于生活，仍然是一人吃饱全家不饿的状态。一个人过的很随便，直到周边朋友开始买车买房了，才给自己敲响了警钟，2017年该攒首付钱了。</p>
<p>关于读书，这块很惭愧，今年读的书比较少，2017年一定要多读书。日记也有半年没有写了，2017一定要坚持下来。</p>
<p>关于爱情，这块没有，略~~        </p>
<p>2016留下了很多遗憾，做错了很多事，总归是不断成长的。</p>
<p>展望2017，只有一个目标：努力提高自己！</p>
<p>再见，2016！<br>你好，2017！</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 2016年度总结&lt;br&gt;date: 2017-01-02 17:49:10&lt;br&gt;categories: 生活&lt;/p&gt;
&lt;h2 id=&quot;tags-情感&quot;&gt;&lt;a href=&quot;#tags-情感&quot; class=&quot;headerlink&quot; title=&quot;tag
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>访问坏内存Bug定位解决</title>
    <link href="http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/"/>
    <id>http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/</id>
    <published>2016-10-24T06:39:05.000Z</published>
    <updated>2016-10-24T06:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。</p>
<p>当对项目中的某一模块进行操作的时候遇到的错误是<code>EXC_BREAKPOINT (code=1, subcode=…)</code>而且没有任何错误log的打印。添加了<code>全局断点</code>还是没有定位到出错代码的位置，这时候就需要对xcode进行一些设置了。        </p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/EXC_BRECKPOINT.png" alt="EXC_BRECKPOINT.png"></p>
<p>xcode开启<code>僵尸模式</code>,如果遇到<code>The target process has no stack logs. Run it with the MallocStackLogging env</code>这种问题那么可以设置下<code>MallocStackLoggingNoCompact</code>为YES。</p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/malloc1.jpg" alt="zombie"></p>
<p>这个时候再对出问题的模块进行操作，会打印出<code>[testViewController retain]message sent to deallocated instance</code>的错误提示，这要就定位到了出问题的大体位置了,并且也知道了是坏内存访问的问题。</p>
<p>但是这个控制器中的代码有上千行，这个时候如何定位呢，既然是内存问题，这里就用到了内存调试工具<code>Zombies</code>了。<br>打开该工具，运行项目，当出现<code>message sent to deallocated instance</code>时候，工具会提示<code>An Objective-C message was sent to a deallocated object(zombie) at address:0x8b3b200</code>，点击提示，工具会提示可能存在内存问题的地方，然后自己看一下定位的具体代码，就能发现出现问题的地方了。    </p>
<p><img src="http://i.stack.imgur.com/qbfcb.png" alt=""></p>
<p><img src="http://i.stack.imgur.com/wpolZ.png" alt="">        </p>
<p>到这里你就应该定位到出问题代码的位置了，合理的利用调试工具，用助于我们高效率的开发。</p>
<blockquote>
<p>今天是1024，程序员的节日，祝大家节日快乐。</p>
</blockquote>
<p>参考资料在<a href="http://stackoverflow.com/questions/11170614/viewcontroller-respondstoselector-message-sent-to-deallocated-instance-crash" target="_blank" rel="external">这里</a>，欢迎大家转载，请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。&lt;/p&gt;
&lt;p&gt;当对项目中的某一模块进行操作的时候遇到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发实战</title>
    <link href="http://yoursite.com/2016/10/10/wx-progects/"/>
    <id>http://yoursite.com/2016/10/10/wx-progects/</id>
    <published>2016-10-10T03:10:55.000Z</published>
    <updated>2016-10-11T02:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信小程序做了几个小项目，感觉和以前学的ReactNavative开发有很多相似之处。</p>
<ul>
<li>骚客计算器</li>
</ul>
<p>用微信小程序搭建的简易计算器，一些计算逻辑可能还有一些问题，不过这不是重点，主要是通过这个项目练练手。里面涉及到的一些知识点：数据绑定、页面渲染、逻辑结构、事件响应、页面跳转等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-calculator.jpg" width="25%" height="25%"><br><br></center>



<ul>
<li>骚客天气</li>
</ul>
<p>用微信小程序搭建的简易天气界面，可以看到当天和未来三天的天气情况。里面涉及到的一些知识点：位置接口、网络通信、百度地图API、天气API、方法封装调用，Flex布局、模板处理、引用、列表渲染等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-weather.jpg" width="25%" height="25%"><br><br></center>        


<p>后续还会写一些简单的小应用。        </p>
<p>这些项目统一放在github上：<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">戳这里</a>，以后用微信小程序写的一些应用我也会统一放到<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="wx" scheme="http://yoursite.com/tags/wx/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天框架的搭建</title>
    <link href="http://yoursite.com/2016/09/28/iOS-weChat/"/>
    <id>http://yoursite.com/2016/09/28/iOS-weChat/</id>
    <published>2016-09-28T13:52:50.000Z</published>
    <updated>2016-10-12T07:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>XZ_WeChat</code>高仿微信聊天框架的搭建，工程地址：<a href="https://github.com/corderguo/XZ_WeChat" target="_blank" rel="external">https://github.com/corderguo/XZ_WeChat</a>        </p>
<p>效果图展示：            </p>
<p><img src="http://img.blog.csdn.net/20160928230616321" alt="1"><br><img src="http://img.blog.csdn.net/20160928230519993" alt="2">        </p>
<p>做了两年IM相关工作了，去年是集成环信的SDK实现的IM功能，今年公司拥有自己的长连接服务器，于是从头自己定协议然后一步步实现了IM的整体功能，基本把微信IM有关的内容都实现了。最近开始整理过去的一些知识，于是先从聊天框架下手，我从项目中抽出这个简易的聊天框架，方便大家学习交流。            </p>
<p>由于该框架是我用最快的时间从原项目中抽出来的，摘除了本地缓存的功能（这部分内容太多了），所以里面或多或少有一些我原项目中的业务逻辑，不过不要紧，这不会影响你对聊天框架的学习，我也会逐渐把该框架规范起来。        </p>
<p>由于作者的电脑环境被折腾坏了，不能安装cocoapods来管理一些用到的三方，所以直接导入进了该框架，这一点大家不要学习。</p>
<p>该框架目前支持的消息类型：文本消息（包含表情），图片消息，语音消息，视频消息，文件消息(pdf,word,excel,ppt,png,html等格式)。</p>
<p>如果你想展示文件消息，你需要把文件拷贝到沙盒的<code>/Library/Caches/Chat/File</code>目录下,由于我以前是从PC端发送文件到手机端进行的展示，所以目前只能你手动拷贝了。</p>
<p>项目中展示的视频已经转成了<code>mp4</code>类型，而且也经过了压缩，语音也转换成了<code>amr</code>格式，节省流量的同时，可以和安卓端兼容。</p>
<p>你能从该框架学习到什么：        </p>
<ul>
<li>聊天框架的搭建</li>
<li>表情键盘的实现</li>
<li>语音相关的知识</li>
<li>视频相关的知识</li>
<li>文件相关的功能</li>
<li>转场动画相关的知识</li>
<li>数据模型和尺寸模型分离</li>
<li>你能清楚的了解到在实战项目中IM的实现    </li>
</ul>
<p>目前该框架这是初步，我还有好多功能没有加入进去，后续会慢慢加入，包括：        </p>
<ul>
<li>消息的转发、拷贝、撤回</li>
<li>文章的分享</li>
<li>订阅号的功能</li>
<li>红包的功能</li>
<li>本地缓存的功能(其实很多功能都要基于数据库的，我把数据库去除掉后，很多功能就一块去除了)</li>
<li>草稿箱的功能</li>
<li>等等等还有好多好多</li>
</ul>
<hr>
<p><strong>更新日志</strong>：            </p>
<p>10月8日：添加了消息的拷贝、删除、撤回功能，由于转发功能需要用到数据库所以我只添加了转发的UI,等添加了数据库后再完善。<code>注意</code>这里的只有自己的消息并且是发送成功的消息才可以撤回，我这里限制的是<code>5分钟</code>内的消息可以撤回,超过规定时间不允许撤回。            </p>
<p>10月12日：添加了系统消息，当消息撤回的时候聊天界面上提示一条<code>你撤回了一条消息</code>的提示。当多人聊天的时候，如果一方撤回了一条消息，系统应该给你发送一条指令，根据这条指令你识别出是哪一条消息被撤回了，然后删除这条消息，并且插入一条<code>谁谁撤回了一条消息</code>。</p>
<p>10月12日：适配xcode8.0，解决bug，如果用xcode8.0的模拟器访问相册时崩溃，则换成真机即可，我也是在升级到xcode8.0后遇到的问题，问题如下：            </p>
<pre><code class="objc">objc[<span class="number">6777</span>]: Class PLBuildVersion is implemented 
<span class="keyword">in</span> both /Applications/Xcode.        
app/Contents/Developer/Platforms/iPhoneSimulator.            
platform/Developer/SDKs/iPhoneSimulator.            
sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.
framework/AssetsLibraryServices (<span class="number">0x1227c3910</span>) and        
/Applications/Xcode.app/Contents/Developer/Platforms
/iPhoneSimulator.platform/Developer/SDKs
/iPhoneSimulator.    
sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.
framework/PhotoLibraryServices (<span class="number">0x1225ed210</span>).                 
One of the two will be used. Which one is undefined.
</code></pre>
<p>奇怪的是我原项目中没有遇到该问题，而抽出来的这个聊天框架却遇到了问题，我猜想是我项目中使用了cocoapods来管理三方，而该聊天框架中我是直接导入的，稍后我会集成cocoapods，尝试问题的解决。大家若有解决方法可以给我留言，大家共同提高。</p>
<p>如果你在学习过程中有什么问题可以和我留言，大家共同提高。如果该框架能帮助到你，欢迎star，你的关注是我最大的动力，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;XZ_WeChat&lt;/code&gt;高仿微信聊天框架的搭建，工程地址：&lt;a href=&quot;https://github.com/corderguo/XZ_WeChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WeChat" scheme="http://yoursite.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>iOS之安全加密</title>
    <link href="http://yoursite.com/2016/09/02/iOS-security-encrypt/"/>
    <id>http://yoursite.com/2016/09/02/iOS-security-encrypt/</id>
    <published>2016-09-02T02:12:15.000Z</published>
    <updated>2016-09-20T08:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><hr>
<p>在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用<code>POST</code>请求提交用户的这些隐私数据。因为<code>GET</code>请求的所有参数都直接暴露在<code>URL</code>中。同时请求的<code>URL</code>一般会记录在服务器的访问日志中，服务器的访问日志是黑客攻击的重点对象之一。</p>
<p>仅仅用<code>POST</code>请求提交用户的隐私数据，还是不能完全解决数据安全的问题，我们可以利用软件（比如Charles）设置代理服务器，拦截查看手机的请求数据。因此：提交用户的隐私数据时，一定不要明文提交，要加密处理后再提交。</p>
<p>另外，我们也不应该在本地保存用户的隐私数据的<code>明文</code>。</p>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><hr>
<p>常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES。</p>
<p>针对上述加密算法，我把目前流行的几种加密方式做下分类：</p>
<ul>
<li><p>哈希（散列）函数</p>
<ul>
<li>MD5（Message Digest Algorithm 5，译为“消息摘要算法第5版”）</li>
<li>SHA1</li>
<li>SHA256            </li>
</ul>
</li>
<li><p>对称加密算法</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES(高级密码标准，美国国家安全局使用的)</li>
</ul>
</li>
<li><p>非对称加密算法</p>
<ul>
<li>RSA</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点说一下散列函数的特点：    </p>
</blockquote>
<ul>
<li>算法是公开的;</li>
<li>对相同的数据加密，得到的结果是一样的;</li>
<li>对不同的数据加密，得到的结果是定长的。例如:MD5对不同的数据进行加密，得到的结果都是32个字符长度的字符串;</li>
<li>信息摘要，信息”指纹”，是用来做数据识别的！比如:搜索;</li>
<li>不能反算的,即是不可逆的。</li>
</ul>
<p>利用这些特点，我们在项目中的应用:    </p>
<p><code>加密密码</code>：服务器并不需要知道用户真实的密码！        </p>
<p><code>搜索</code>：比如你要搜索“张老师 杨老师 苍老师”和“苍老师 张老师 杨老师”，其实这两个要搜索的内容所表达的意思是一样的，但是我们应该如何判断呢。我们可以对搜索的每个关键字进行散列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！<br>张老师            1bdf605991920db11cbdf8508204c4eb<br>杨老师             2d97fbce49977313c2aae15ea77fec0f<br>苍老师             692e92669c0ca340eff4fdcef32896ee</p>
<p><code>版权</code>: 版权保护，文件识别。例如可以对文件内容进行MD5，然后可以根据该MD5串判断文件内容是否被修改过。我以前做IM的文件上传功能就是这样判断的，如果文件内容的MD5相同，表示该文件已经在服务器存在了，就不用再次上传了。</p>
<p>由于<code>MD5</code>加密算法具有较好的安全性，而且免费，因此该加密算法被广泛使用。不过遗憾的是该加密算法已经被暴力破解了,<a href="http://www.cmd5.com" target="_blank" rel="external">http://www.cmd5.com</a>该网站记录超过24万亿条，共占用160T硬盘 的密码数据，通过对海量数据的搜索得到的结果！    </p>
<p>不过我们可以通过提升MD5加密的安全性，加大被破解的难度。    </p>
<p><code>1</code>. 加“盐”（佐料）。<br><code>2</code>. HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符。</p>
<h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><hr>
<p>RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙：使用publicKey可以对数据进行加密，使用Key才能对数据进行解密。    </p>
<p>特点：单方向传输<br>用公钥加密的数据，只有私钥能解开（可用于加密）；<br>同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍）；</p>
<p>公钥与私钥：            </p>
<p>1.权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。<br>2.私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。<br>3.公钥好比安全性极高的挂号信箱地址，公开。        </p>
<p>举例：若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤：        </p>
<ol>
<li>甲用乙的公钥对合同加密。        </li>
<li>密文从甲发送到乙。        </li>
<li>乙收到密文，并用自己的私钥对其解密。        </li>
<li>解密正确，经阅读，乙用自己的私钥对合同进行签署。        </li>
<li>乙用甲的公钥对已经签署的合同进行加密。            </li>
<li>乙将密文发给甲。        </li>
<li>甲用自己的私钥将已签署合同解密。        </li>
<li>解密正确，确认签署。        </li>
</ol>
<p>从以上步骤，我们知道：            </p>
<ol>
<li>用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。        </li>
<li>如果某份密文被解开，那么肯定是密文的目标信息主体解开的。        </li>
<li>私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。        </li>
</ol>
<h3 id="Base64补充"><a href="#Base64补充" class="headerlink" title="Base64补充"></a>Base64补充</h3><hr>
<p>1.Base64简单说明：<br>描述：Base64可以成为密码学的基石，非常重要。<br>特点：可以将任意的二进制数据进行Base64编码<br>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。<br>65字符：A~Z a~z 0~9 + / =<br>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。        </p>
<p>2.命令行进行Base64编码和解码：<br>编码：base64 123.png -o 123.txt<br>解码：base64 123.txt -o test.png -D        </p>
<p>3.Base64编码原理：<br>1)将所有字符转化为<code>ASCII</code>码；<br>2)将ASCII码转化为<code>8</code>位二进制；<br>3)将二进制<code>3</code>个归成一组(不足<code>3</code>个在后边补<code>0</code>)共<code>24</code>位，再拆分成<code>4</code>组，每组<code>6</code>位；<br>4)统一在<code>6</code>位二进制前补两个<code>0</code>凑足<code>8</code>位；<br>5)将补<code>0</code>后的二进制转为十进制；<br>6)从Base64编码表获取十进制对应的Base64编码；    </p>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个<code>24bit</code>的缓冲区中，先来的byte占高位。<br>    b.数据不足<code>3byte</code>的话，于缓冲区中剩下的bit用0补足。然后，每次取出<code>6</code>个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加<code>1</code>个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加<code>2</code>个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。        </p>
<p> 4.在项目中的应用：        </p>
<p>1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持<br>2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。</p>
<p>代码实现：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64EncodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先把字符串转换为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对base64编码后的字符串进行解码</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64DecodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.把二进制数据转换为字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终端测试命令：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n A | base64			</span><br><span class="line">$ <span class="built_in">echo</span> -n QQ== |base64 -D</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据安全&quot;&gt;&lt;a href=&quot;#数据安全&quot; class=&quot;headerlink&quot; title=&quot;数据安全&quot;&gt;&lt;/a&gt;数据安全&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用&lt;code&gt;POST&lt;/code&gt;请求提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>关于委托代理的优化</title>
    <link href="http://yoursite.com/2016/08/20/iOS-delegate_optimized/"/>
    <id>http://yoursite.com/2016/08/20/iOS-delegate_optimized/</id>
    <published>2016-08-20T02:02:04.000Z</published>
    <updated>2016-09-06T06:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><hr>
<p>对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对象间的的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以发生相关事件时通知委托对象。</p>
<p>通常delegate对象中的方法名也一定要起得恰当才行。方法名应该准确描述当前发生的事件以及delegate对象为何要获知此事件。在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样，delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。若没有此信息，则委托对象在同一时间只能执行一套逻辑，这么做不太好。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><hr>
<p>在实现委托模式时，如果协议中的方法是可选得，那么就会写出一大批类似下面的代码来：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_delegate respondsToSelector:@selector(someClassDidSomething:)])</span><br><span class="line">&#123;</span><br><span class="line">	[_delegate someClassDidSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易用代码查出某个委托对象是否能响应特定的选择子，可是如果频繁执行此操作的话，那么除了第一次检测的结果有用之外，后续的检测可能都是多余的。如果委托对象本身没变，那么不太可能会突然响应某个原来不能响应的选择子，也不太会突然无法响应某个原来可以响应的选择子。鉴于此，我们可以把委托对象能否响应某个协议方法这一信息缓存起来，以优化程序效率。</p>
<p>将方法响应能力缓存起来的最佳途径是使用“位段”数据类型，我们可以把结构体中的字段占用的二进制位个数设为一个字节，从而用0和1表示方法是否被响应。</p>
<p>下面举个例子：</p>
<p>在“class-continuation分类”中新增实例变量，这个新增的实例变量是个结构体，用来缓存方法的响应与否。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	unsigned int didReceiveData     : 1;</span><br><span class="line">	unsigned int didFailWithError   : 1;</span><br><span class="line">&#125; _delegateFlags;</span><br></pre></td></tr></table></figure>
<p>这个结构体用来缓存委托对象是否能响应特定的选择子。实现缓存功能所用的代码可以写在delegate属性所对应的设置方法里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)<span class="built_in">set</span>Delegate:(id&lt;GXZNetWorkFetcher&gt;)delegate &#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData   = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</span><br><span class="line">	_delegateFlags.didFailWithError = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，每次调用delegate的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(_delegateFlags.didReceiveData) &#123;</span><br><span class="line">	[_dlegate networkFetcher:self didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相关方法要调用很多次时，值得进行这种优化。而是否需要优化，则应依照具体代码来定。这就需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。如果频繁的通过数据源协议从数据源中获取多份相互独立的数据，那么这项优化技术极有可能就会提高程序效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;委托模式&quot;&gt;&lt;a href=&quot;#委托模式&quot; class=&quot;headerlink&quot; title=&quot;委托模式&quot;&gt;&lt;/a&gt;委托模式&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用AVAudioPlayer遇到的奇葩问题</title>
    <link href="http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/"/>
    <id>http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/</id>
    <published>2016-08-10T13:16:15.000Z</published>
    <updated>2016-08-18T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工<br>具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    </p>
</blockquote>
<p>我开始播放音频的播放代码如下：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br><span class="line">    self.player.numberOfLoops = 0;</span><br><span class="line">    [self.player prepareToPlay];</span><br><span class="line">    self.player.delegate = self;</span><br><span class="line">    [self.player play];</span><br></pre></td></tr></table></figure>
<p>结果开始播放语音的时候，程序始终停在初始化这句：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br></pre></td></tr></table></figure>
<p>在这里你可以手动在Xcode上使程序强制运行过去，这样程序可以正常运行了，没有任何影响，这就奇了怪了。于是我在<font color="green">stackoverflow</font>上找到了一个解决方案:<br><img src="http://upload-images.jianshu.io/upload_images/1389022-a81ead68cba8f0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片">    </p>
<p>原来是我在XCode中设置了全局断点，导致audio无法播放，（但是我这里就有疑问了，同一个工具类为什么我播放IM中录音时没有问题，到这里就有问题了呢？）于是我把全局断点去掉后，程序果断正常运行了。        </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>以后遇到异常终止的情况（<strong>注意</strong>不是出错，可以手动使程序继续正常运行），可以尝试移除全局断点的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工&lt;br&gt;具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>沉痛悼念CSDN博主、年仅26岁的音视频专家雷霄骅</title>
    <link href="http://yoursite.com/2016/08/04/meidia-person/"/>
    <id>http://yoursite.com/2016/08/04/meidia-person/</id>
    <published>2016-08-04T04:30:07.000Z</published>
    <updated>2016-08-04T05:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160804134857626" alt=""></p>
<p>CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7月17日凌晨猝死在学校主楼五层，并于7月23号安葬。据相关报道称，事发前雷霄骅一直泡在实验室忙碌，怀疑其是劳累过度导致猝死。        </p>
<p>CSDN失去了一位亲密的友人，我们失去了一位深受网友爱戴的“雷大神”博主。最初当大家看到这则新闻时，除了不敢相信一再确认外，剩下的只有心痛。众多网友也自发地在多个平台表达了自己的悼念之情。<br><img src="http://img.blog.csdn.net/20160804085950156" alt=""></p>
<p>逝者的博客地址：<a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="external">http://blog.csdn.net/leixiaohua1020</a>,我很久以前就关注了雷神的博客，雷神的文章让我学到了很多东西。        </p>
<p>霄骅的博客为很多人所知，在他的博客上，有这样一段自我介绍「主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。」截止笔者发稿，这一刻CSDN上霄骅的博客数据为：    </p>
<ul>
<li>访问：4354295次</li>
<li>积分：43750</li>
<li>等级：8</li>
<li><p>排名：第52名</p>
</li>
<li><p>原创：375篇</p>
</li>
<li><p>转载：159篇</p>
</li>
<li>译文：28篇</li>
<li>评论：4985条    </li>
</ul>
<p>从此，这些数据将会灰色定格！<br>我们感谢霄骅做出的巨大贡献！而认识雷霄骅，还可以从他的相关专栏和开源项目中做更深入了解：<br>专栏:        </p>
<blockquote>
<p>FFmpeg（135篇）    </p>
<ul>
<li>开源多媒体项目源代码分析（91篇）        </li>
<li>视频质量评价（41篇）</li>
</ul>
</blockquote>
<p>开源项目列表 :            </p>
<blockquote>
<ul>
<li>[SourceForge]：<a href="https://sourceforge.net/u/leixiaohua1020/wiki/" target="_blank" rel="external">https://sourceforge.net/u/leixiaohua1020/wiki/</a><br>[Github]：<a href="http://leixiaohua1020.github.io/" target="_blank" rel="external">http://leixiaohua1020.github.io/</a></li>
<li>TIandSI：本工具用于计算视频的时间信息（TI，也称为时间复杂度），以及空间信息（SI，也称为空间复杂度），以上两个指标取自于ITU-R BT.1788标准。</li>
<li>VideoEye：一个开源的视频分析的软件。本软件可以播放和分析视频数据。它支持多种视频流输入方式：HTTP，RTMP，RTSP以及文件等等。该软件可以实时分析视频流并能以图形化的方式呈现其分析结果。目前该软件还处于完善阶段。</li>
</ul>
</blockquote>
<p>CSDN博客运营人员回忆：“一直以来，与霄骅的接触都在QQ上，第一次见面，是在CSDN老友记的活动上。在我的印象中，他是低调、内敛的男孩，他的笑容很真实，也能打动人，很真诚、乐于帮助别人的一位博客专家。”而霄骅也写了篇小短文做记录，表示不虚此行。        </p>
<p>霄骅在14年5月31日正式成为博客专家，他擅长的技术当时在CSDN上内容还不算很多，所以系列更新一下子吸引了很多人来浏览和讨论。他的博客帮助了很多人，除了在博客上回复大家的问题，以及还有自己的技术交流群，旨在为视音频技术同行方便交流提供一个平台。无论是实验室、电视台、互联网视频、安防、播放器、媒体中心等都可以加入讨论。他认为多交流可以更快的进步~        </p>
<p>乐于分享技术的他，在视音频技术做出了巨大贡献的他，当之无愧地连续两年获得CSDN年度博客之星称号。        </p>
<p>就在今年上半年，CSDN曾邀请霄骅成为其签约作者，当时霄骅提到最近要忙着写毕业设计，工作人员一直在等他忙完这阵子。结果，这个噩耗无情地到来。        </p>
<p>斯人已去，对于霄骅博文出书以及家人号召成立基金会事宜，CSDN表示都会全力支持协助。我们在沉痛悼念霄骅的同时，也呼吁所有技术开发者们，一定要照顾好自己的身体，远离病痛折磨！    </p>
<p>希望天堂里霄骅一切安好！    </p>
<p>希望从事IT行业的人员都要注重身体的健康！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160804134857626&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7
    
    </summary>
    
      <category term="资讯" scheme="http://yoursite.com/categories/%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="media" scheme="http://yoursite.com/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发各种权限问题(相机、录音等)</title>
    <link href="http://yoursite.com/2016/08/02/iOS-authorization/"/>
    <id>http://yoursite.com/2016/08/02/iOS-authorization/</id>
    <published>2016-08-02T09:13:02.000Z</published>
    <updated>2016-08-02T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，直接去调用了，这样会出现问题。        </p>
<h3 id="麦克风权限"><a href="#麦克风权限" class="headerlink" title="麦克风权限"></a>麦克风权限</h3><hr>
<p>我在项目中开发IM的录音功能的时候，没有判断当前APP是否拥有响应的权限，导致录制失败（录制出来是0kb，长度也是0毫秒）。为此我在工具类中，添加了麦克风权限的判断方法，当用户去录音的时候，如果检测到没有响应的麦克风权限，则提示用户到手机的设置页面打开麦克风的权限，当用权限的时候直接录制就可以了。   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecord</span><br><span class="line">&#123;</span><br><span class="line">    __block BOOL bCanRecord = YES;</span><br><span class="line">    <span class="keyword">if</span> ([[[UIDevice currentDevice] systemVersion] compare:@<span class="string">"7.0"</span>] != NSOrderedAscending)</span><br><span class="line">    &#123;</span><br><span class="line">        AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">        <span class="keyword">if</span> ([audioSession respondsToSelector:@selector(requestRecordPermission:)]) &#123;</span><br><span class="line">            [audioSession performSelector:@selector(requestRecordPermission:) withObject:^(BOOL granted) &#123;</span><br><span class="line">                bCanRecord = granted;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> bCanRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相机权限"><a href="#相机权限" class="headerlink" title="相机权限"></a>相机权限</h3><hr>
<p>同样在开发IM的小视屏(和微信小视屏一样)功能的时候也遇到了同样的问题，在没有判断相机权限的前提下，我手动关掉了APP的相机访问权限，则我录制视频的时候的预览页黑乎乎一片，什么也没有，同样没办法录制，这给用户的体验非常差，所以当我们调用系统资源的时候，一定要先判断是否拥有相应的权限。以下是我的判断相机权限的代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecordViedo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *mediaType = AVMediaTypeVideo;</span><br><span class="line">    AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType];</span><br><span class="line">    <span class="keyword">if</span> (authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h3><hr>
<p>其实该权限不去判断也可以，因为当你没有相册权限而去调用本机相册的时候，系统默认会pop出一个提示的页面，提示用户，没有相册权限，去手机的设置页面设置该权限。系统的这个页面还是可以的（不丑），所以我就用了系统的提示页面了。但是我还是在工具类中实现了相册权限的判断，方便以后归类。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)albumAuthority</span><br><span class="line">&#123;</span><br><span class="line">    ALAuthorizationStatus author = [ALAssetsLibrary authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (author == kCLAuthorizationStatusRestricted || author ==kCLAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h3><hr>
<p>当用户用到定位的功能的时候，也涉及到权限的问题，我顺便也实现了该功能权限的判断：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)locationAuthority</span><br><span class="line">&#123;</span><br><span class="line">    CLAuthorizationStatus status = [CLLocationManager authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (kCLAuthorizationStatusDenied == status || kCLAuthorizationStatusRestricted == status) &#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>当我们调用系统资源的时候，一定要先判断是否拥有相应的权限，做到代码的严谨性。        </p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><hr>
<p>扫码关注下面二维码，干货不断：<br><img src="http://img.blog.csdn.net/20160623095054012" alt="二维码"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于死锁的一点总结</title>
    <link href="http://yoursite.com/2016/07/23/iOS-gcd-deadlock/"/>
    <id>http://yoursite.com/2016/07/23/iOS-gcd-deadlock/</id>
    <published>2016-07-23T04:02:04.000Z</published>
    <updated>2016-09-12T10:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。        </p>
<p>例如：     </p>
<p>死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。    </p>
<h3 id="GCD导致死锁的例子"><a href="#GCD导致死锁的例子" class="headerlink" title="GCD导致死锁的例子"></a>GCD导致死锁的例子</h3><hr>
<p>比如下面的这个会产生死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以自己先分析一下该程序产生死锁的原因。    </p>
<p>我们首先要搞清楚<code>同步&amp;异步</code> <code>串行&amp;并发</code>这两组基本概念：    </p>
<blockquote>
<p>同步执行：比如dispatch_sync，这个函数会把一个block加入到指定的队列中，而且会一直等到执行完blcok，这个函数才返回。因此在block执行完之前，调用dispatch_sync方法的线程是阻塞的。        </p>
<p>异步执行：一般使用dispatch_async，这个函数也会把一个block加入到指定的队列中，但是和同步执行不同的是，这个函数把block加入队列后不等block的执行就立刻返回了。</p>
</blockquote>
<p>接下来是”串行和并行”：        </p>
<blockquote>
<p>串行队列：比如dispatch_get_main_queue,这个队列中所有任务，一定按照先来后到的顺序执行。不仅如此，还可以保证在执行某个任务时，在它前面进入队列的所有任务肯定执行完了。对于每一个不同的串行队列，系统会为这个队列建立唯一的线程来执行代码。            </p>
<p>并发队列：比如dispatch_get_global_queue,这个队列中的任务也是按照先来后到的顺序开始执行，注意是开始，但是它们的执行结束时间是不确定的，取决于每个任务的耗时。对于n个并发队列，GCD不会创建对应的n个线程而是进行适当的优化。</p>
</blockquote>
<p>理解清楚上面的两组概念后我们再来分析上面例子产生死锁的原因：        </p>
<p>该程序中在主线程中同步执行<code>dispatch_sync(queue,block)</code>任务，而该任务又被分发到了主线程<code>dispatch_get_main_queue()</code>中，这就产生了问题。程序在执行<code>dispatch_sync(queue,block)</code>时，会阻塞调用线程（在这里是主线程），等待block中的任务执行完后再返回阻塞线程继续进行执行，但是block中的任务在执行的时候又需要在主线程中执行，而现在主线程被阻塞，所以就会产生两者相互等待的情况，死锁就形成了。    </p>
<p>下面对比着总结一下<code>dispatch_sync</code>和<code>dispatch_async</code>的执行流程：        </p>
<p>（1）dispatch_sync的执行流程：</p>
<ul>
<li>将block添加到queue队列中</li>
<li>阻塞调用线程，等待block（）执行结束，回调到调用线程。</li>
</ul>
<p>（2）dispatch_async的执行流程：    </p>
<ul>
<li>将block添加到queue队列中</li>
<li>直接回到调用线程（不阻塞调用线程）,异步执行。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>下面我总结一下关于死锁的一些注意事项：    </p>
<ul>
<li>异步执行一定不会产生死锁，因为异步的执行，block会立刻返回，不会阻塞线程。所以在我们开发过程中如果遇到死锁的问题，很大可能是同步执行的原因，这样可以帮助我们快速定位。</li>
<li>不要把block任务同步派发到调用gcd所在线程的关联队列中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。   
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods更新遇redefinition问题及其它问题汇总</title>
    <link href="http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/"/>
    <id>http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/</id>
    <published>2016-07-11T08:20:30.000Z</published>
    <updated>2016-07-11T10:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。</p>
<h2 id="1、问题环境"><a href="#1、问题环境" class="headerlink" title="1、问题环境"></a>1、问题环境</h2><p>升级时所使用的命令为：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>升级后用”pod –version”查看版本号是0.39.0，升级前的版本我没记错的话应该是0.37.2.</p>
<h2 id="2、Redefinition问题"><a href="#2、Redefinition问题" class="headerlink" title="2、Redefinition问题"></a>2、Redefinition问题</h2><p>升级后遇到的最大的问题就是这个Redefinition问题了，具体情况是我的工作项目中需要增加一个新的pod引用，pod update后编译报出一大堆Redefinition问题，涉及到AFNetworking，SDWebImage等常用库，而以前都好好的，百思不得其解。        </p>
<p><a href="&quot;Redefinition of module X&quot; errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue">“Redefinition of module X” errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue</a>提到了这个问题，但我并不得要领。        </p>
<p>为了这个问题我把Pods文件夹、Podfild.lock文件删除重新更新，甚至把CocoaPods降级到0.38.2以及0.37.2版本都没有解决，然后这个过程中又遇到了其它的问题，问题怎么解决的后面再说。</p>
<p>静下心来再查看这个问题，发现错误日志里还是提供了一些关键要素，能显示重复定义在哪里。因为我一般情况下都是看默认显示在Xcode左侧栏里的错误日志列表就解决，很少展开日志详细信息。这次的关键要素就是在日志详细信息中，然后就发现了一些规律：以AFNetworking为例，我在pch文件中是这样引用的：#import &lt;AFNetworking/AFNetworking.h&gt;，然后在其它文件也做了这样的引用：#import “AFNetworking.h”。这两个引用同时存在就造成了Redefinition，去掉后者的引用方式就可以解决AFNetworking的Redefinition问题了。        </p>
<p>正常情况下肯定是用尖括号那种引用方式，但是由于历史原因，项目中使用后者那种引用方式也有不少，以前也从来没出问题，不知道现在为什么一下子就全部暴露出来了。这一改就要改不少，没办法就只能一个一个改了。        </p>
<blockquote>
<p>后记：根据最新回复，是必须得使用#import &lt; AFNetworking\/AFNetworking.h &gt;这种形式的头文件引用了，应该是检查更严格了。            </p>
</blockquote>
<p><em>我在这里遇到的问题是SDWebImage的Redefinition问题，是在pch中导入了#import &lt; SDWebImage\/UIImageView+WebCache.h &gt;，但是在其他的类中又导入了#import “UIImageView+WebCache.h”，从而引起了Redefinition问题</em>        </p>
<h2 id="3、undefined-method-project’-for-lt-Pod-Installer问题"><a href="#3、undefined-method-project’-for-lt-Pod-Installer问题" class="headerlink" title="3、undefined method `project’ for #&lt;Pod::Installer问题"></a>3、undefined method `project’ for #&lt;Pod::Installer问题</h2><p>旧版本的Podfile在升级Cocoapods后pod install就会遇到这个问题，根据这篇文章，是因为Cocoapods升级到0.38或0.39版本后installer_representation.project.targets.each中的project改名了，变成了pods_project，好在给了一个0.37——0.39都通用的办法，比如原来的Podfile是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line">post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">    installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">            config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>升级后就要改成：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.pods_project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="4、DVTAssertions-ASSERTION-FAILURE问题"><a href="#4、DVTAssertions-ASSERTION-FAILURE问题" class="headerlink" title="4、DVTAssertions: ASSERTION FAILURE问题"></a>4、DVTAssertions: ASSERTION FAILURE问题</h2><p>这是CocoaPods降级到0.37.2后pod install遇到的问题，记忆中当初好像就是因为这个问题而升级到0.39.0版本的。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[MT] DVTAssertions: ASSERTION FAILURE <span class="keyword">in</span> /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-8227/IDEFoundation/Initialization/IDEInitialization.m:590</span><br><span class="line">Details: Assertion failed: _initializationCompletedSuccessfully</span><br><span class="line">Function: BOOL IDEIsInitializedForUserInteraction()</span><br><span class="line">Thread: &#123;number = 1, name = main&#125;</span><br><span class="line">Hints: None</span><br><span class="line">Backtrace:</span><br><span class="line">0 0x000000010462aa5c -DVTAssertionHandler handleFailureInFunction:fileName:lineNumber:assertionSignature:messageFormat:arguments:</span><br><span class="line">1 0x000000010462a1e9 _DVTAssertionHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">2 0x000000010462a455 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">3 0x000000010462a3b7 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">4 0x0000000107191f5c IDEIsInitializedForUserInteraction (<span class="keyword">in</span> IDEFoundation)</span><br><span class="line">5 0x0000000109da8eb9 +PBXProject projectWithFile:errorHandler:<span class="built_in">read</span>Only:</span><br><span class="line">6 0x0000000109daaa3e +PBXProject projectWithFile:errorHandler:</span><br><span class="line">7 0x00007fff8bc68f44 ffi_call_unix64 (<span class="keyword">in</span> libffi.dylib)</span><br><span class="line">Abort <span class="built_in">trap</span>: 6</span><br></pre></td></tr></table></figure>
<p>网上大部分的帖子都说升级CocoaPods，比如这个<a href="https://github.com/CocoaPods/CocoaPods/issues/4209" target="_blank" rel="external">帖子</a>，然而具体问题具体分析好不好，我这个是降级时遇到的问题。</p>
<p>这个问题应该就是与Xcode版本有关了，实际就是与Developer的路径有关。我的Mac上同时存在有Xcode6.1.1版本与Xcode7.0版本，后者是默认的Xcode版本。</p>
<p>当CocoaPods为0.37.2版本时，对应的Developer路径应该是Xcode6.1.1版本的路径，因为这个之前一直都配合使用好好的。那么，就需要用到xcode-select问题了。通过xcode-select -p命令可以查看当前Developer路径，用xcode-select -s可以指定新的Developer路径。</p>
<p>我是这样指定的：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select <span class="_">-s</span> /Applications/Xcode6.1.1.app/Contents/Developer</span><br></pre></td></tr></table></figure>
<p>然后这个问题就不复存在了。注意当有必要使用CocoaPods 0.39.0版本时，必须得切换回来，要不然还是会遇到这个问题        </p>
<h2 id="5、CocoaPods多版本共存问题"><a href="#5、CocoaPods多版本共存问题" class="headerlink" title="5、CocoaPods多版本共存问题"></a>5、CocoaPods多版本共存问题</h2><p>本来我是想降级的，结果CocoaPods好像默认就是多版本共存了，比如我原来本来是0.37.2版本，用了本文开头的升级命令升级后，虽然用pod –version看是0.39.0版本，但是0.37.2版本并没有删除。这个可以用下面的命令查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem list --local | grep cocoapods</span><br></pre></td></tr></table></figure>
<p>如果你的只有一个版本，你可以再安装一个CocoaPods 0.38.2版本或者其它版本试试。比如安装0.38.2版本的命令就是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 0.38.2</span><br></pre></td></tr></table></figure>
<p>说是共存了，但到底是怎么共存使用呢？就比如说我的CocoaPods默认版本是0.39.0，有一个项目要用0.37.2版本的CocoaPods该怎么用呢？        </p>
<p><a href="http://stackoverflow.com/questions/28130938/how-to-switch-cocoapods-or-other-gem-version-on-command-line/28140522#28140522" target="_blank" rel="external">这里</a>有人提供了这样的一个方法，但我没有细研究，也没实践，需要用到rbenv：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rbenv global 2.1.0</span><br><span class="line">gem install cocoapods -v 0.34.4</span><br><span class="line">rbenv global 2.0.0-p0</span><br><span class="line">gem install cocoapods -v 0.33.1</span><br></pre></td></tr></table></figure>
<p>步骤:        </p>
<ul>
<li>在项目根目录下创建Gemfile，指定CocoaPods版本    </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">'~&gt; 0.37.2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行bundle install命令</li>
</ul>
<p>****************这是华丽丽的分割线o(╯□╰)o******************</p>
<p>我是在原<a href="http://www.jianshu.com/p/ee32eef74ba9" target="_blank" rel="external">文章</a>的基础上做了些许改动,总结了自己遇到的一些问题。</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之HTTPS</title>
    <link href="http://yoursite.com/2016/06/27/iOS-security-https/"/>
    <id>http://yoursite.com/2016/06/27/iOS-security-https/</id>
    <published>2016-06-27T01:42:55.000Z</published>
    <updated>2016-09-20T16:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App Transport Security安全功能。App Transport Security（ATS）是苹果在iOS 9中引入的一项隐私保护功能，屏蔽明文HTTP资源加载，连接必须经过更安全的HTTPS。苹果目前允许开发者暂时关闭ATS，可以继续使用HTTP连接，但到年底所有官方商店的应用都必须强制性使用ATS。        </p>
<h3 id="HTTPS和HTTP"><a href="#HTTPS和HTTP" class="headerlink" title="HTTPS和HTTP"></a>HTTPS和HTTP</h3><hr>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版，HTTPS = HTTP + SSL/TLS。即在HTTP下加入了SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护。HTTPS的信任基于预先安装在浏览器中的证书颁发机构（如VeriSign、Microsoft等）（意即“我信任证书颁发机构告诉我应该信任的”）,因此该网站的HTTPS连接可被信任，如果服务器搭建自己的https 也就是说采用自认证的方式来建立https信道，这样一般在客户端是不被信任的。所以我们一般在浏览器访问一些https站点的时候会有一个提示，问你是否继续。（苹果官网是强制安装证书的,不会询问用户）。</p>
<blockquote>
<p>HTTPS和HTTP的区别主要为以下四点：        </p>
</blockquote>
<p>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。        </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr>
<p>如果是自己使用NSURLSession来封装网络请求，涉及代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line">   <span class="built_in">NSURLSessionDataTask</span> *task =  [session dataTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://www.apple.com"</span>] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [task resume];</span><br></pre></td></tr></table></figure></p>
<p>下面我们实现代理方法，在代理方法中处理证书。如果你的请求是HTTP而不是HTTPS是不走该代理方法的：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 我们需要在该方法中告诉系统, 是否信任服务器返回的证书</span><br><span class="line"> Challenge: 挑战 质问 (包含了受保护的区域)</span><br><span class="line"> protectionSpace : 受保护区域</span><br><span class="line"> NSURLAuthenticationMethodServerTrust : 证书的类型是 服务器信任</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span>, <span class="built_in">NSURLCredential</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断服务器返回的证书类型, 是否是服务器信任</span></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         NSURLSessionAuthChallengeUseCredential = 0,                   使用证书</span><br><span class="line">         NSURLSessionAuthChallengePerformDefaultHandling = 1,          忽略证书(默认的处理方式)</span><br><span class="line">         NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2,   忽略书证, 并取消这次请求</span><br><span class="line">         NSURLSessionAuthChallengeRejectProtectionSpace = 3,      拒绝当前这一次, 下一次再询问</span><br><span class="line">         */</span></span><br><span class="line">        <span class="built_in">NSURLCredential</span> *card = [[<span class="built_in">NSURLCredential</span> alloc]initWithTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeUseCredential</span> , card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是使用<code>AFN</code>框架，那么我们不需要做任何额外的操作，AFN内部已经做了处理。但是对于对于自制证书的网站还需要进行一些设置：        </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line"><span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line"><span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line"><span class="comment">// 假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"><span class="comment">// 置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line"><span class="comment">// 如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">securityPolicy.validatesDomainName = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 如果就是CA证书，则不需要设置上面两项，正常使用AFN即可</span></span><br><span class="line">[manager GET:url parameters:<span class="literal">nil</span> progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</span><br><span class="line">&#125; success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">	 <span class="comment">// 请求成功</span></span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>虽然HTTPS相比于HTTP来说，会有一定的性能上的劣势，但对于网络飞速发展，移动设备的性能成倍增长的今天，安全才是我们更应该去考虑的。全网HTTPS并不是那么遥远。        </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在WWDC 2016开发者大会上，苹果宣布了一个最后期限：到2017年1月1日 App Store中的所有应用都必须启用 App 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>继承的陷阱</title>
    <link href="http://yoursite.com/2016/06/20/iOS-inherit-trap/"/>
    <id>http://yoursite.com/2016/06/20/iOS-inherit-trap/</id>
    <published>2016-06-20T04:16:35.000Z</published>
    <updated>2016-09-02T02:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。</p>
<p>在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文件中去声明，而是直接在.m文件中去实现，也许为了区分，还会为方法加上类似于”xx_”这样的前缀，如图1所示，以这种方式定义”私有方法“。</p>
<p>但这只是一种障眼法，在外部调用时，确实是看不到，如果我们直接调用这些方法，编译器会报错，但如果用performSelector:来调用，依然可以正常执行。</p>
<p>上面这种问题通常可以避免。一个潜藏的问题是出现在继承体系里面。如果父类和子类的.m文件定义了两个同名的”私有方法“，则子类的方法会覆盖父类的方法，这样我们可能会在不经意间修改了父类的一些实现。</p>
<p>在继承第三方非开源库中的类时，如果遇到这种情况，会是一种很淡疼的感觉，那样你只能修改自己的方法名了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C本身并没有私有方法的概念。一个类中定义的方法–不管是类本身定义的还是Category中定义的–最终都会出现在objc_class结构体的objc_method_list链表中。&lt;/p&gt;
&lt;p&gt;在开发中，经常有些方法我们不希望暴露给外界，所以并不会在头文
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift实现导航栏头像大小渐变和导航栏颜色渐变</title>
    <link href="http://yoursite.com/2016/04/12/iOS-ChangeNavImg/"/>
    <id>http://yoursite.com/2016/04/12/iOS-ChangeNavImg/</id>
    <published>2016-04-12T11:12:50.000Z</published>
    <updated>2016-08-17T06:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>github地址: <a href="https://github.com/corderguo/ChangeNavTitleImage" target="_blank" rel="external">https://github.com/corderguo/ChangeNavTitleImage</a><br>本文地址: <a href="http://coderperson.com/2016/04/12/iOS-ChangeNavImg/" target="_blank" rel="external">http://coderperson.com/2016/04/12/iOS-ChangeNavImg/</a><br>欢迎转载，请注明出处，谢谢。</p>
</blockquote>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://img.blog.csdn.net/20160702190808768" alt=""></p>
<h3 id="创建tableView"><a href="#创建tableView" class="headerlink" title="创建tableView"></a>创建tableView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 我是以懒加载的形式创建</span><br><span class="line">private lazy var tableView: UITableView = &#123;</span><br><span class="line">        <span class="built_in">let</span> tableView = UITableView(frame: self.view.bounds)</span><br><span class="line">        tableView.dataSource = self</span><br><span class="line">        tableView.delegate   = self</span><br><span class="line">        <span class="built_in">return</span> tableView</span><br><span class="line">    &#125;()</span><br><span class="line">// 以extension的形式遵循代理 并在其中实现代理方法</span><br><span class="line">extension ViewController : UITableViewDataSource,UITableViewDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>协议的写法，不需要写&lt;&gt;        </li>
<li>刚遵循完协议的时候会报错，不用担心，那是因为还没实现代理方法</li>
<li>Swift中的懒加载和OC中的懒加载区别还是挺大的</li>
</ul>
<p>这里要注意，我是在viewDidLoad方法中注册cell的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableView.registerClass(UITableViewCell.self, <span class="keyword">for</span>CellReuseIdentifier: ID)</span><br></pre></td></tr></table></figure>
<h3 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> 30</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">let</span> cell = tableView.dequeueReusableCellWithIdentifier(ID, <span class="keyword">for</span>IndexPath: indexPath)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"骚客--\(indexPath.row):http://coderperson.com"</span></span><br><span class="line">        <span class="built_in">return</span> cell</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止我们的基本界面搭建完成了，下面就是关键部分了。</p>
<h3 id="自定义titleView"><a href="#自定义titleView" class="headerlink" title="自定义titleView"></a>自定义titleView</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 首先定义imageView的属性，用来操控图片的大小改变</span><br><span class="line">var imageV : UIImageView?</span><br><span class="line">// 创建</span><br><span class="line"><span class="built_in">let</span> titleV : UIView = UIView()</span><br><span class="line">navigationItem.titleView = titleV</span><br><span class="line">imageV = UIImageView(frame: CGRectMake(0, 0, 70, 70))</span><br><span class="line">imageV?.image = UIImage(named: <span class="string">"100.jpg"</span>)</span><br><span class="line">imageV?.layer.cornerRadius = 35</span><br><span class="line">imageV?.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">imageV?.center = CGPointMake(titleV.center.x, 0)</span><br><span class="line">titleV.addSubview(imageV!)</span><br></pre></td></tr></table></figure>
<p>这里不要自己单独向navigationBar上添加子控件，只需要修改titleView即可</p>
<h3 id="监听偏移量"><a href="#监听偏移量" class="headerlink" title="监听偏移量"></a>监听偏移量</h3><p>这里通过监听偏移量，实现的大小缩放动画<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        </span><br><span class="line">        // 偏移量，相对于contentView，你也可以不加scrollView.contentInset.top，即相对scrollView，然后适当调整即可</span><br><span class="line">        <span class="built_in">let</span> offsetY = scrollView.contentOffset.y + scrollView.contentInset.top</span><br><span class="line">        var scale:CGFloat = 1.0</span><br><span class="line">        <span class="keyword">if</span> offsetY &lt; 0  // 下拉</span><br><span class="line">        &#123;</span><br><span class="line">            scale = min(1.5, 1.0 - offsetY / 300.0) // 300值可以自己调整</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> offsetY &gt; 0</span><br><span class="line">        &#123;</span><br><span class="line">            // 为了防止缩小过度，给一个最小值为0.45，其中0.45 = 31.5 / 70.0，表示</span><br><span class="line">            // 头像最小是31.5像素</span><br><span class="line">            scale = max(0.45, 1 - offsetY / 300);</span><br><span class="line">        &#125;</span><br><span class="line">        // 保证缩放后y的坐标不会改变</span><br><span class="line">        imageV?.transform = CGAffineTransformMakeScale(scale, scale)</span><br><span class="line">        var frame = imageV?.frame</span><br><span class="line">        frame?.origin.y = -(imageV?.layer.cornerRadius)! / 2.0</span><br><span class="line">        imageV?.frame = frame!</span><br><span class="line">        </span><br><span class="line">        // 导航栏颜色渐变</span><br><span class="line">        changeNavColor(offsetY)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>单独抽出来的颜色渐变的方法<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private func changeNavColor(offsetY:CGFloat) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> offsetY &gt;= 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> offsetY &lt; 0</span><br><span class="line">       &#123;</span><br><span class="line">           self.navigationController?.navigationBar.alpha = 1.0 - -offsetY / 300.0</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止你已经可以看到自己想要的效果了。        </p>
<p>Done！</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：      </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/corderguo/ChangeNavTitleImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/corde
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS中block的Strong-Weak Dance的思考</title>
    <link href="http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/"/>
    <id>http://yoursite.com/2016/03/24/iOS-block-strong-weak-dance/</id>
    <published>2016-03-24T02:10:18.000Z</published>
    <updated>2016-08-25T09:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak Dance”。        </p>
<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><hr>
<p>这是一种 强引用 –&gt; 弱引用 –&gt; 强引用 的变换过程。在弄明白为什么要如此大费周章之前，我们首先来看看一般的写法会有什么问题。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法可以避免循环引用，但是我们要考虑这样的问题：    </p>
<p><strong>假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 wself 是一个弱引用，因此会自动变为 nil。而在 KVO 中，这会导致崩溃。</strong>    </p>
<h3 id="Strong-Weak-Dance"><a href="#Strong-Weak-Dance" class="headerlink" title="Strong-Weak Dance"></a>Strong-Weak Dance</h3><hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak MyViewController *wself = self;</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    __strong __typeof(wself) sself = wself; // 强引用一次</span><br><span class="line">    [sself.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一来，self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁。        </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><hr>
<p>在和小伙伴的讨论过程中，他提出了几个问题。虽然都不难，但是有利于把各种知识融会贯通起来。</p>
<p>1.Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof(wself) sself = wself;</span><br></pre></td></tr></table></figure>
<p>A：会的。引用计数描述的是对象而不是指针。这句话的意思是：        </p>
<blockquote>
<p>sself 强引用 wself 指向的那个对象</p>
</blockquote>
<p>因此对象的引用计数会增加一个。</p>
<p>2.Q：block 内部定义了sself，会不会因此强引用了 sself？<br>A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题。<br>3.Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> __weak MyViewController *wself = self;</span><br><span class="line">wself.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wself) &#123; // 只有当 wself 不为 nil 时，才执行以下代码</span><br><span class="line">        [wself.property removeObserver: wself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了。</p>
<p>4.Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了。</p>
<p>A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行。另外，如果执行一个为 nil 的闭包会导致崩溃。        </p>
<p>5.Q：如果在执行 block 的过程中，block 被释放了怎么办？        </p>
<p>A：简单来说，block 还会继续执行，但是它捕获的指针会具有不确定的值，详细内容请参考<a href="http://stackoverflow.com/questions/12272783/what-happens-when-a-block-is-set-to-nil-during-its-execution" target="_blank" rel="external">这篇文章</a>    </p>
<h3 id="strongify-和-weakify"><a href="#strongify-和-weakify" class="headerlink" title="@strongify 和 @weakify"></a>@strongify 和 @weakify</h3><hr>
<p>这是<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a> 中定义的一个宏。一般可以这样使用：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.completionHandler = ^(NSInteger result) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self.property removeObserver: sself <span class="keyword">for</span>KeyPath:@<span class="string">"pathName"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文并非分析它们的实现原理，所以就简单解释两点：        </p>
<ol>
<li><p>这里的“@”没有任何用处，仅表示强调，这个宏实际上包含了一个空的 AutoreleasePool，这也就是为什么一定要加上“@”。        </p>
</li>
<li><p>它的原理还是和之前一样，生成了一段形如 __weak MyViewController *wself = self; 这种格式的代码：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define rac_strongify_(INDEX, VAR) \\</span></span><br><span class="line">__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</span><br></pre></td></tr></table></figure>
<h3 id="Swift-中的情况"><a href="#Swift-中的情况" class="headerlink" title="Swift 中的情况"></a>Swift 中的情况</h3><hr>
<p>在 Swift 中也有 Strong-Weak Dance 的概念。最简单的方法就是直接沿用 OC 的思路：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">        /// ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法的缺点在于，我们不能写 if let self = self，因此需要重新定义一个变量 strongSelf，命名方式显得不够优雅。            </p>
<p>除此以外还可以使用 Swift 标准库提供的函数 withExtendedLifetime：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    withExtendedLifetime(self) &#123;</span><br><span class="line">        /// ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点在于，self 依然是可选类型的，还需要把它解封后才能使用。        </p>
<p>最后，还有一种解决方案是自定义 withExtendedLifetime函数：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Optional &#123;</span><br><span class="line">    func withExtendedLifetime(body: T -&gt; Void) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">let</span> strongSelf = self &#123;</span><br><span class="line">            body(strongSelf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这种写法是否更加优雅，就见仁见智了：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.completionHandler = &#123; [weak self] <span class="keyword">in</span></span><br><span class="line">    self.withExtendedLifetime &#123;</span><br><span class="line">        /// 这里用 <span class="variable">$0</span> 表示 self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于YYKit中block的细节"><a href="#关于YYKit中block的细节" class="headerlink" title="关于YYKit中block的细节"></a>关于YYKit中block的细节</h3><hr>
<p>下面是YYCache中的一段代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)_trimRecursively &#123;</span><br><span class="line">    __weak typeof(self) _self = self;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        __strong typeof(_self) self = _self;</span><br><span class="line">        <span class="keyword">if</span> (!self) <span class="built_in">return</span>;</span><br><span class="line">        [self _trimInBackground];</span><br><span class="line">        [self _trimRecursively];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：         </p>
<p>如果直接引用 strong self，那 block 创建时就会立刻强引用了 self；而如果先用 weak 引用，则 block 创建时对 self 是弱引用，而直到 block 开始执行时，self 才会被强引用。    </p>
<p>如果 block 提交到 queue 但还未执行的时候，整个 Cache 对象被释放了，那这时 weak self 就会变为 nil 了，而后 block 执行的时候 if (!self) return; 就会成立了。            </p>
<p>非常严谨！！！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><hr>
<p><a href="http://www.jianshu.com/p/4ec18161d790" target="_blank" rel="external">http://www.jianshu.com/p/4ec18161d790</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在使用 Block 时，除了使用 __weak 修饰符避免循环引用外，还有一点经常容易忘记。苹果把它称为：“Strong-Weak
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="block" scheme="http://yoursite.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发环境配置</title>
    <link href="http://yoursite.com/2016/03/20/reactNative-configure/"/>
    <id>http://yoursite.com/2016/03/20/reactNative-configure/</id>
    <published>2016-03-20T02:11:11.000Z</published>
    <updated>2016-08-26T02:46:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h3><hr>
<p>1.安装Homebrew:        </p>
<p>Homebrew是OS X的套件(包)管理器，我们可以通过它获取并且安装很多组件<br>安装方式:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>2.安装npm 和 Node.js:        </p>
<p> Node.js最好安装4.0及其以上更高版本，node安装成功后npm自动也就有了，直接下载安装Node.js，网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a>        </p>
<p>3.安装WatchMan:</p>
<p>该插件用于监控bug文件和文件变化 ，并且可以触发指定的操作.        </p>
<p>安装方式:        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami` /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>4.安装Flow:</p>
<p>flow是一个JavaScript的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误.            </p>
<p>安装方式:                </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure>
<h3 id="React-Native安装"><a href="#React-Native安装" class="headerlink" title="React Native安装"></a>React Native安装</h3><hr>
<p>1.安装React Native：                    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>iOS开发环境需求:Xcode 7 及其以上更高版本.</p>
<h3 id="React-Native的第一个应用"><a href="#React-Native的第一个应用" class="headerlink" title="React Native的第一个应用"></a>React Native的第一个应用</h3><hr>
<p>1.执行命令,生成一个工程：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init 项目名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:由于众所周知的网络原因，需要等待一段时间（具体视网络情况而定）。react-native命令行从npm官方源拖代码时会遇上麻烦，可以将npm仓库源替换为国内镜像：    </p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure>
<p>2.目录结构分析:    </p>
<p>a）默认生成android和ios两个平台的原生项目；            </p>
<p>b）其中，index.android.js和index.ios.js文件为Android和iOS的空壳应用文件；</p>
<p>c）此外，node_modules文件夹，是为Node.js存放和管理npm包资源，也包含React Native框架文件。    </p>
<h3 id="管理React-Native库的版本"><a href="#管理React-Native库的版本" class="headerlink" title="管理React Native库的版本"></a>管理React Native库的版本</h3><hr>
<p>1.查看本地的React Native库的版本                               </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native --version</span><br></pre></td></tr></table></figure>
<p>2.更新本地的React Native的版本                   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g react-native-cli</span><br></pre></td></tr></table></figure>
<p>3.查询react-native的npm包最新版本                    </p>
<p>npm包地址 ：<a href="https://www.npmjs.com/package/react-native" target="_blank" rel="external">https://www.npmjs.com/package/react-native</a>         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react-native</span><br></pre></td></tr></table></figure>
<p>4.升级或者降级npm包的版本：                        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native@0.18</span><br></pre></td></tr></table></figure>
<p>5.更新项目templates文件（可选）：                 </p>
<p>新的npm包会包含更新在运行react-native init命令生成的一些动态文件，例如init创建项目的时候会生成iOS和Android的子项目，我们可以通过以下的命令进行获取最新的代码         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native upgrade</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境需求&quot;&gt;&lt;a href=&quot;#环境需求&quot; class=&quot;headerlink&quot; title=&quot;环境需求&quot;&gt;&lt;/a&gt;环境需求&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.安装Homebrew:        &lt;/p&gt;
&lt;p&gt;Homebrew是OS X的套件(包)管理器，我们可以通
    
    </summary>
    
      <category term="ReactNative" scheme="http://yoursite.com/categories/ReactNative/"/>
    
    
      <category term="RN" scheme="http://yoursite.com/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>三行代码搞定静态页面</title>
    <link href="http://yoursite.com/2016/03/15/iOS-staticPage/"/>
    <id>http://yoursite.com/2016/03/15/iOS-staticPage/</id>
    <published>2016-03-15T04:13:48.000Z</published>
    <updated>2016-06-29T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StaticPage"><a href="#StaticPage" class="headerlink" title="StaticPage"></a>StaticPage</h1><ul>
<li>静态页面大杀器，利用该库三行代码就能搞定通用静态页面</li>
<li>github地址：<a href="https://github.com/corderguo/StaticPage" target="_blank" rel="external">https://github.com/corderguo/StaticPage</a>             </li>
</ul>
<h1 id="如何使用StaticPage"><a href="#如何使用StaticPage" class="headerlink" title="如何使用StaticPage"></a>如何使用StaticPage</h1><p>首先先把你控制器中tableview的类型设置为UITableViewStyleGrouped类型      </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>只需要导入ICCommonItemCell.h头文件    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"ICCommonItemCell.h"</span></span><br></pre></td></tr></table></figure>
<p>然后在你的数据源中根据分组来设置响应的数据，例如demo中的代码:    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-(NSMutableArray *)dataArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nil == _dataArray) &#123;</span><br><span class="line">        _dataArray = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *friendItem  = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconShowAlbum"</span> title:@<span class="string">"朋友圈"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"朋友圈"</span>]; // 根据要跳转的控制器需要的参数类型，具体填写，我这里需要的是字符串类型，就传递的字符串</span><br><span class="line">        ICCommonGroup *friendGroup = [[ICCommonGroup alloc] init];</span><br><span class="line">        friendGroup.items          = @[friendItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *sweepItem    = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconQRCode"</span> title:@<span class="string">"扫一扫"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"扫一扫"</span>];</span><br><span class="line">        ICCommonItem *waveItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconShake"</span> title:@<span class="string">"摇一摇"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"摇一摇"</span>];</span><br><span class="line">        ICCommonGroup *sewaGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        sewaGroup.items            = @[sweepItem,waveItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *nearItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconLocationService"</span> title:@<span class="string">"附近的人"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"附近的人"</span>];</span><br><span class="line">        ICCommonItem *driftItem    = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconBottle"</span> title:@<span class="string">"漂流瓶"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"漂流瓶"</span>];</span><br><span class="line">        ICCommonGroup *nedrGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        nedrGroup.items            = @[nearItem,driftItem];</span><br><span class="line">        </span><br><span class="line">        ICCommonItem *shopItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"ff_IconQRCode"</span> title:@<span class="string">"购物"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"购物"</span>];</span><br><span class="line">        ICCommonItem *gameItem     = [ICSettingArrowItem itemWithIcon:@<span class="string">"MoreGame"</span> title:@<span class="string">"游戏"</span> destVcClass:[ICTestViewController class] parameter:@<span class="string">"游戏"</span>];</span><br><span class="line">        ICCommonGroup *shgaGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">        shgaGroup.items            = @[shopItem,gameItem];</span><br><span class="line">        </span><br><span class="line">        [_dataArray addObject:friendGroup];</span><br><span class="line">        [_dataArray addObject:sewaGroup];</span><br><span class="line">        [_dataArray addObject:nedrGroup];</span><br><span class="line">        [_dataArray addObject:shgaGroup];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> _dataArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ICCommonGroup对应一组，而ICCommonItem又对应组中的每一个Item，每个Item有两种类型<br>，分别为ICSettingArrowItem和ICSettingSwitchItem；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)itemWithIcon:(NSString *)icon title:(NSString *)title destVcClass:(Class)destVcClass parameter:(id)parameter;</span><br></pre></td></tr></table></figure>
<p>这个方法中的参数含义：        </p>
<ul>
<li>icon：cell中左边图片的图片名        </li>
<li>title：cell的title显示的字符串内容        </li>
<li>destVcClass：点击cell时要跳转的控制器类型            </li>
<li>parameter：点击cell时要跳转时需要传递过去的参数               </li>
</ul>
<p>如果ICCommonItem中存在ICSettingSwitchItem，为了扑捉到UISwitch的开关事件，你需要遵守ICCommonItemCellDelegate，实现其中的代理方法：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)commonItemCell:(ICCommonItemCell *)cell</span><br><span class="line">                 swith:(UISwitch *)swith;</span><br></pre></td></tr></table></figure>
<p>如果想要改变每个组之间的间距（是组不是每个Item）你可以重写tableview的两个代理方法，返回自己想要的间距即可：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section</span><br><span class="line">&#123;&#125;</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>每个Item还可以在其对应的block中响应对应的事件，这样只需在tableview的didSelected方法中调用option这个block即可；         </p>
<p>如果你需要显示区头或者区尾，只需要在数据源中给对应的group设置header或footer即可：     </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ICCommonItem * discover    = [ICSettingSwitchItem itemWithIcon:nil title:@<span class="string">"置顶会话"</span> destVcClass:nil parameter:nil];</span><br><span class="line"> ICCommonItem *companyDoc   = [ICSettingSwitchItem itemWithIcon:nil title:@<span class="string">"消息免打扰"</span> destVcClass:nil parameter:nil];</span><br><span class="line">ICCommonGroup * mesGroup   = [[ICCommonGroup alloc] init];</span><br><span class="line">mesGroup.header            = @<span class="string">"来个区头玩玩"</span>;</span><br><span class="line">mesGroup.items = @[discover,companyDoc];</span><br></pre></td></tr></table></figure>
<p>然后在tableview的代理方法中调用即可：       </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    ICCommonGroup *group = self.dataArray[section];</span><br><span class="line">    <span class="built_in">return</span> group.header;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    ICCommonGroup *group = self.dataArray[section];</span><br><span class="line">    <span class="built_in">return</span> group.footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在使用过程中遇到什么问题您可以issues提问，如果你想贡献代码请pull Reques；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;StaticPage&quot;&gt;&lt;a href=&quot;#StaticPage&quot; class=&quot;headerlink&quot; title=&quot;StaticPage&quot;&gt;&lt;/a&gt;StaticPage&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;静态页面大杀器，利用该库三行代码就能搞定通用静态页面&lt;/li&gt;

    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift中闭包详解</title>
    <link href="http://yoursite.com/2016/03/10/iOS-closure/"/>
    <id>http://yoursite.com/2016/03/10/iOS-closure/</id>
    <published>2016-03-10T11:12:50.000Z</published>
    <updated>2016-07-02T04:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>github地址: <a href="https://github.com/corderguo" target="_blank" rel="external">https://github.com/corderguo</a><br>本文地址: <a href="http://coderperson.com/2016/03/10/iOS-closure/" target="_blank" rel="external">http://coderperson.com/2016/03/10/iOS-closure/</a><br>欢迎转载，请注明出处，谢谢。</p>
</blockquote>
<h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><p>Swift 中闭包的概念就像是Objective-C中的block。OC中的block类似于匿名函数，闭包是用来定义函数， 同时闭包可以嵌套和作为参数传递。 在 Swift 中，函数也只不过是一种特殊的闭包         </p>
<h3 id="闭包与Block的对比"><a href="#闭包与Block的对比" class="headerlink" title="闭包与Block的对比"></a>闭包与Block的对比</h3><p>作用：</p>
<ul>
<li>Block是用来保存一段代码，在需要的时候执行 </li>
<li>闭包也是用来保存一段代码，在需要的时候执行</li>
<li>一般都是用来做耗时操作；</li>
</ul>
<p>风格：      </p>
<p>我们首先回顾一下OC中的Block写法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义block</span><br><span class="line">@property (nonatomic, copy) void(^myBlock)();</span><br><span class="line">// 定义block</span><br><span class="line">self.myBlock = ^&#123;</span><br><span class="line">// 具体的回调操作</span><br><span class="line">&#125;</span><br><span class="line">// 调用block</span><br><span class="line">self.myBlock();</span><br></pre></td></tr></table></figure></p>
<p>通过回顾，我们可以想起来Block的定义格式为：     </p>
<p>Block格式：返回值类型(^block名称)(参数列表) </p>
<p>有的时候我们忘记了Block的书写格式，或者嫌这样写麻烦，我们可以直接在Xcode中敲inlineBlock<br>然后回车，系统会直接提醒你Block的样式；     </p>
<p>Swift中闭包的基本格式：         </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (形参列表) -&gt; (返回值)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这些格式我们都没必要专门去记忆，我们可以直接敲系统的带有闭包或者Block的函数，然后就一目了然了；      </p>
<h4 id="闭包的几种格式"><a href="#闭包的几种格式" class="headerlink" title="闭包的几种格式"></a>闭包的几种格式</h4><p>第一种情况：        </p>
<ul>
<li>将闭包通过实参传递给函数</li>
<li>如果闭包是函数的最后一个参数，那么闭包可以写到函数{}的后面</li>
<li>如果函数只接受一个参数，并且这个参数是闭包，那么()可以省略</li>
</ul>
<p>例如下面这三种写法是一样的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义函数，参数为闭包</span><br><span class="line">func loadData(finished: () -&gt; ()) &#123;</span><br><span class="line">    //  操作</span><br><span class="line">&#125;</span><br><span class="line">// 调用（这是默认写法）</span><br><span class="line">loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">// 或者写成</span><br><span class="line">loadData (&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">// 还可以写成</span><br><span class="line"><span class="function"><span class="title">loadData</span></span>() &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况：闭包的简写  </p>
<ul>
<li>如果闭包没有参数也没有返回值，那么 in 之前的东西可以删除，包括 in</li>
</ul>
<p>例如上面闭包，还可以写成下面的形式：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其实这些格式，你在开发中只需要掌握一种即可，或者你只需要记住闭包的定义，然后敲回车，系统会为你补齐格式；</p>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><blockquote>
<p>关于闭包中的 self 问题 </p>
</blockquote>
<p>在Swift开发中，有一个原则就是能不写self就不写self，但是在闭包中必须写上self；   </p>
<p>这是因为闭包是用来保存一段代码，而且系统也不知道这段代码具体的调用时间，所以为了保证闭包中的对象不被释放，需要 self 进行一次强引用；这其实和Block中的原理差不多。   </p>
<p>所以以后看到self基本上都和闭包有关系。（这也是闭包中循环引用来源的原因）</p>
<p>下面我举一个简单的关于闭包循环引用的例子：      </p>
<p>你定义了两个控制器：OneController和TwoController，OneController只是负责push出TwoController,我们在TwoController中进行一些关于闭包的操作，然后在pop返回的时候查看该控制器是否被销毁了，来验证闭包是否发生了循环引用问题；<br>在TwoController中我们只需要简单写一些代码即可：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个闭包的属性 </span><br><span class="line">var finished: (() -&gt; ())?</span><br><span class="line">// 定义一个函数，参数为闭包</span><br><span class="line"> func loadData(finished: () -&gt; ()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"调用了"</span>)</span><br><span class="line">        self.finished = finished</span><br><span class="line">        finished();</span><br><span class="line">    &#125;</span><br><span class="line">// 函数调用</span><br><span class="line">loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"回调了"</span>)</span><br><span class="line">            // 这句又强引用self，导致循环引用</span><br><span class="line">            self.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;</span><br><span class="line">// 判断是否被销毁了</span><br><span class="line">deinit &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"控制器被销毁了"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行以上代码，并且从TwoController返回到OneController时，TwoController的deinit方法没有被调用，表明TwoController没有被销毁，闭包存在了循环引用的问题；     </p>
<p>这是因为：控制器通过闭包属性引用闭包，而闭包中又强引用着self(控制器),所以导致了循环引用的问题；        </p>
<blockquote>
<p>OC中关于循环引用的解决方案</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Swift中关于循环引用的解决方案</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak var weakSelf = self</span><br></pre></td></tr></table></figure>
<p>那么原先代码中只需要把self改成weakSelf即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 由于weakSelf为可选类型，这里必须保证有值，所以加上！号</span><br><span class="line">weakSelf!.view.backgroundColor = UIColor.redColor()</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><blockquote>
<p>关于定义闭包属性的问题      </p>
</blockquote>
<p>在Swift中，如果在某个类中定义一个属性，那么这个属性必须要初始化，否者会报错，如果暂时不想初始化，那么可以在后面写上一个 ? 号       </p>
<p>但是在定义闭包的属性时，一定要注意，以下这种写法是最常见的一种错误写法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 当前写法代表闭包的返回值可以是nil，而不是初始化的闭包 */</span><br><span class="line">var finished: () -&gt; ()?</span><br><span class="line"></span><br><span class="line">/** 正确写法：需要在整个闭包的后面加问号 */</span><br><span class="line">var finished: (() -&gt; ())?</span><br></pre></td></tr></table></figure>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：      </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/corderguo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/corderguo&lt;/a&gt;&lt;br&gt;本文地址: &lt;a
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>离屏渲染探究</title>
    <link href="http://yoursite.com/2015/11/28/iOS-offScreen/"/>
    <id>http://yoursite.com/2015/11/28/iOS-offScreen/</id>
    <published>2015-11-28T02:02:04.000Z</published>
    <updated>2016-07-11T10:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文地址: <a href="http://coderperson.com/2015/11/28/iOS-offScreen/" target="_blank" rel="external">http://coderperson.com/2015/11/28/iOS-offScreen/</a><br>欢迎转载，请注明出处，谢谢。    </p>
</blockquote>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>
<ul>
<li>On-Screen Rendering    </li>
</ul>
<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>
<ul>
<li>Off-Screen Rendering        </li>
</ul>
<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>GPU渲染机制：</p>
<p>CPU 计算好显示内容提交到 GPU，GPU<br>渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync<br>信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。</p>
<p>屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>
<h2 id="性能优劣"><a href="#性能优劣" class="headerlink" title="性能优劣"></a>性能优劣</h2><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<ul>
<li><p>创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>
</li>
<li><p>上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>
</li>
</ul>
<p>注意：触发离屏渲染后，上面两步会发生在每一帧，如果在界面的滚动过程中有大量的离屏渲染发生时会严重影响帧率。</p>
<h2 id="另一种特殊的“离屏渲染”"><a href="#另一种特殊的“离屏渲染”" class="headerlink" title="另一种特殊的“离屏渲染”"></a>另一种特殊的“离屏渲染”</h2><p>按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。</p>
<p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<h2 id="离屏渲染的触发机制"><a href="#离屏渲染的触发机制" class="headerlink" title="离屏渲染的触发机制"></a>离屏渲染的触发机制</h2><ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
<li>复杂形状设置圆角等</li>
<li>渐变</li>
</ul>
<p>其中shouldRasterize（光栅化）是比较特别的一种：<br>光栅化概念：将图转化为一个个栅格组成的图象。<br>光栅化特点：每个元素对应帧缓冲区中的一像素。</p>
<p>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。</p>
<p>相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。</p>
<p>当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。</p>
<p>如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。</p>
<blockquote>
<p>注意：   </p>
</blockquote>
<p>对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费</p>
<p>例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。</p>
<h2 id="官方优化"><a href="#官方优化" class="headerlink" title="官方优化"></a>官方优化</h2><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染</p>
<p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p>
<p>这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>UIImage加载图片方式一般有两种:</p>
<p>A：imagedNamed初始化</p>
<p>B：imageWithContentsOfFile初始化<br>二者不同之处在于,imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象.</p>
<p>而imageWithContentsOfFile则仅只加载图片,不缓存.</p>
<p>大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.</p>
<p>使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显.</p>
<h2 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h2><ol>
<li>当我们需要圆角效果时，可以使用一张中间透明图片蒙上去</li>
<li>使用ShadowPath指定layer阴影效果路径</li>
<li>使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit）</li>
<li>设置layer的opaque值为YES，减少复杂图层合成</li>
<li>尽量使用不包含透明（alpha）通道的图片资源</li>
<li>尽量设置layer的大小值为整形值</li>
<li>直接让美工把图片切成圆角进行显示，这是效率最高的一种方案</li>
<li>很多情况下用户上传图片进行显示，可以让服务端处理圆角</li>
<li>使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当项目中需要离屏渲染的地方不多时，性能的影响并不是很大，基本也能保持在60fps左右，但<br>是一旦超过一定数目的圆角，滑动起来就会有明显的卡顿现象。所以，没必要为了不影响体验的情况下强行进行优化，这样做效果并不是很明显。只有当需要优化的时候采取一定的优化方案，才能得到最大的收益。            </p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文地址: &lt;a href=&quot;http://coderperson.com/2015/11/28/iOS-offScreen/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coderperson.com/2015/
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS零散知识点汇总</title>
    <link href="http://yoursite.com/2015/09/04/iOS-interview/"/>
    <id>http://yoursite.com/2015/09/04/iOS-interview/</id>
    <published>2015-09-04T04:02:04.000Z</published>
    <updated>2016-09-12T15:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runtime怎么添加属性、方法等"><a href="#runtime怎么添加属性、方法等" class="headerlink" title="runtime怎么添加属性、方法等"></a>runtime怎么添加属性、方法等</h3><ul>
<li>ivar表示成员变量</li>
<li>class_addIvar</li>
<li>class_addMethod</li>
<li>class_addProperty</li>
<li>class_addProtocol</li>
<li>class_replaceProperty</li>
</ul>
<h3 id="是否可以把比较耗时的操作放在NSNotificationCenter中"><a href="#是否可以把比较耗时的操作放在NSNotificationCenter中" class="headerlink" title="是否可以把比较耗时的操作放在NSNotificationCenter中"></a>是否可以把比较耗时的操作放在NSNotificationCenter中</h3><ul>
<li>首先必须<code>明确通知在哪个线程中发出</code>，那么处理接受到通知的方法也在这个线程中调用</li>
<li>如果在<code>异步</code>线程发的通知，那么<code>可以</code>执行比较耗时的操作；</li>
<li>如果在<code>主线程</code>发的通知，那么就<code>不可以</code>执行比较耗时的操作</li>
</ul>
<h3 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h3><ul>
<li>首先要搞清楚weak属性的特点</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span>策略表明该属性定义了一种“非拥有关系” (nonowning relationship)。</span><br><span class="line">为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同<span class="keyword">assign</span>类似;</span><br><span class="line">然而在属性所指的对象遭到摧毁时，属性值也会清空(<span class="literal">nil</span> <span class="keyword">out</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>那么runtime如何实现weak变量的自动置nil？</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime对注册的类，会进行布局，会将 <span class="keyword">weak</span> 对象放入一个 hash 表中。</span><br><span class="line">用 <span class="keyword">weak</span> 指向的对象内存地址作为 key，当此对象的引用计数为<span class="number">0</span>的时候会调用对象的 dealloc 方法，</span><br><span class="line">假设 <span class="keyword">weak</span> 指向的对象内存地址是a，那么就会以a为key，在这个 <span class="keyword">weak</span> hash表中搜索，找到所有以a为key的 <span class="keyword">weak</span> 对象，从而设置为 <span class="literal">nil</span>。</span><br></pre></td></tr></table></figure>
<h3 id="weak属性需要在dealloc中置nil么"><a href="#weak属性需要在dealloc中置nil么" class="headerlink" title="weak属性需要在dealloc中置nil么"></a>weak属性需要在dealloc中置nil么</h3><ul>
<li>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</li>
<li>即便是编译器不帮我们做这些，weak也不需要在dealloc中置nil</li>
<li>在属性所指的对象遭到摧毁时，属性值也会清空</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟下weak的setter方法，大致如下</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"object"</span>, object, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    [object cyl_runAtDealloc:^&#123;</span><br><span class="line">        _object = <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个Objective-C对象如何进行内存布局？（考虑有父类的情况）"><a href="#一个Objective-C对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="一个Objective-C对象如何进行内存布局？（考虑有父类的情况）"></a>一个Objective-C对象如何进行内存布局？（考虑有父类的情况）</h3><ul>
<li>所有<code>父类的</code>成员变量和<code>自己的</code>成员变量都会存放在该对象所对应的存储空间中</li>
<li>父类的方法和自己的方法都会缓存在类对象的方法缓存中，类方法是缓存在元类对象中</li>
<li>每一个对象内部都有一个<code>isa指针</code>,指向他的<code>类对象</code>,类对象中存放着本对象的如下信息<ul>
<li>对象方法列表</li>
<li>成员变量的列表</li>
<li>属性列表</li>
</ul>
</li>
<li>每个 Objective-C 对象都有相同的结构，如下图所示</li>
</ul>
<table>
<thead>
<tr>
<th>Objective-C 对象的结构图</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISA指针</td>
</tr>
<tr>
<td>根类(NSObject)的实例变量</td>
</tr>
<tr>
<td>倒数第二层父类的实例变量</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>父类的实例变量</td>
</tr>
<tr>
<td>类的实例变量</td>
</tr>
</tbody>
</table>
<ul>
<li>根类对象就是NSObject，它的super class指针指向nil</li>
<li>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是<code>类方法</code>列表，<code>根元类的isa指针指向自己，superclass指针指向NSObject类</code></li>
</ul>
<h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h3><ul>
<li>每一个对象内部都有一个isa指针，这个指针是指向它的真实类型</li>
<li>根据这个指针就能知道将来调用哪个类的方法</li>
</ul>
<h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>答案：都输出 Son</li>
<li><p>这个题目主要是考察关于objc中对 self 和 super 的理解：</p>
<ul>
<li>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 本质是一个<code>编译器标示符</code>，和 self 是指向的同一个消息接受者</li>
<li>当使用 self 调用方法时，会从<code>当前类</code>的方法列表中开始找，<code>如果没有</code>，就从<code>父类中再找</code>；</li>
<li>而当使用 super时，则从父类的方法列表中开始找。然后调用父类的这个方法</li>
<li><p>调用[self class] 时，会转化成 objc_msgSend函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 [super class]时，会转化成 objc_msgSendSuper函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __unsafe_unretained <span class="keyword">id</span> receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self</p>
</li>
<li>第二个成员是记录当前类的父类是什么，告诉程序从父类中开始找方法，找到方法后，最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son</li>
<li><p>objc Runtime开源代码对- (Class)class方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(Class)class &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><ul>
<li>每一个类对象中都一个对象方法列表（对象方法缓存）</li>
<li>类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）</li>
<li>方法列表中每个方法结构体中记录着方法的<code>名称</code>,<code>方法实现</code>,以及<code>参数类型</code>，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</li>
<li>当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找</li>
<li>当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</li>
</ul>
<h3 id="objc中的类方法和实例方法有什么本质区别和联系"><a href="#objc中的类方法和实例方法有什么本质区别和联系" class="headerlink" title="objc中的类方法和实例方法有什么本质区别和联系"></a>objc中的类方法和实例方法有什么本质区别和联系</h3><ul>
<li>类方法：<ul>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中<code>不能</code>访问成员变量</li>
<li>类方法中<code>不能</code>直接调用对象方法</li>
<li>类方法是存储在元类对象的方法缓存中</li>
</ul>
</li>
<li>实例方法：<ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中<code>可以调用类方法(通过类名)</code></li>
<li>实例方法是存放在类对象的方法缓存中</li>
</ul>
</li>
</ul>
<h3 id="使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>使用<code>runtime Associate</code>方法关联的对象，需要在主对象dealloc的时候释放么？</h3><ul>
<li>无论在MRC下还是ARC下<code>均不需要</code></li>
<li>被关联的对象在生命周期内要比对象本身释放的<code>晚很多</code>，它们会在被 NSObject -dealloc 调用的 <code>object_dispose()</code>方法中释放</li>
<li>补充：对象的内存销毁时间表，分四个步骤</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用 -release ：引用计数变为零</span><br><span class="line"> * 对象正在被销毁，生命周期即将结束.</span><br><span class="line"> * 不能再有新的 __<span class="keyword">weak</span> 弱引用，否则将指向 <span class="literal">nil</span>.</span><br><span class="line"> * 调用 [<span class="keyword">self</span> dealloc]</span><br><span class="line"><span class="number">2.</span> 父类调用 -dealloc</span><br><span class="line"> * 继承关系中最直接继承的父类再调用 -dealloc</span><br><span class="line"> * 如果是 MRC 代码 则会手动释放实例变量们（iVars）</span><br><span class="line"> * 继承关系中每一层的父类 都再调用 -dealloc</span><br><span class="line"><span class="number">3.</span> <span class="built_in">NSObject</span> 调 -dealloc</span><br><span class="line"> * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法</span><br><span class="line"><span class="number">4.</span> 调用 object_dispose()</span><br><span class="line"> * 为 C++ 的实例变量们（iVars）调用 destructors</span><br><span class="line"> * 为 ARC 状态下的 实例变量们（iVars） 调用 -release</span><br><span class="line"> * 解除所有使用 runtime Associate方法关联的对象</span><br><span class="line"> * 解除所有 __<span class="keyword">weak</span> 引用</span><br><span class="line"> * 调用 free()</span><br></pre></td></tr></table></figure>
<h3 id="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>能否向编译后得到的类中增加<code>实例变量</code>？能否向运行时创建的类中添加<code>实例变量</code>？为什么？</h3><ul>
<li><code>不能</code>向编译后得到的类中增加<code>实例变量</code>；</li>
<li><code>能</code>向运行时创建的类中添加<code>实例变量</code>；</li>
<li>分析如下：<ul>
<li>因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list 实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime 会调用class_setIvarLayout 或 class_setWeakIvarLayout来处理strong weak引用，所以<code>不能</code>向存在的类中添加<code>实例变量</code></li>
<li>运行时创建的类是<code>可以</code>添加<code>实例变量</code>，调用 class_addIvar函数，但是得在调用objc_allocateClassPair<code>之后</code>，objc_registerClassPair<code>之前</code>，原因同上。</li>
</ul>
</li>
</ul>
<h3 id="runloop和线程有什么关系？"><a href="#runloop和线程有什么关系？" class="headerlink" title="runloop和线程有什么关系？"></a>runloop和线程有什么关系？</h3><ul>
<li>每条线程都有<code>唯一</code>的一个RunLoop对象与之对应的</li>
<li>主线程的RunLoop是<code>自动创建并启动</code></li>
<li>子线程的RunLoop需要<code>手动创建</code></li>
<li><p>子线程的RunLoop创建步骤如下：</p>
<ul>
<li>在子线程中调用[NSRunLoop currentRunLoop]创建RunLoop对象（<code>懒加载，只创建一次</code>）</li>
<li><p>获得RunLoop对象后要调用<code>run</code>方法来启动一个运行循环</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动RunLoop</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure>
</li>
<li><p>RunLoop的其他启动方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：指定运行模式</span></span><br><span class="line"><span class="comment">// 第二个参数：指定RunLoop的过期时间，即：到了这个时间后RunLoop就失效了</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:kCFRunLoopDefaultMode beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>### runloop的mode作用是什么？
</code></pre><ul>
<li>用来控制一些特殊操作只能在指定模式下运行，一般可以通过指定操作的运行mode来控制执行时机，以提高用户体验</li>
<li>系统默认注册了5个Mode<ul>
<li><code>kCFRunLoopDefaultMode</code>：App的<code>默认Mode</code>，<code>通常主线程</code>是在这个Mode下运行，对应OC中的：<code>NSDefaultRunLoopMode</code></li>
<li><code>UITrackingRunLoopMode</code>：<code>界面跟踪</code> Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li><code>kCFRunLoopCommonModes</code>:这是一个<code>标记</code>Mode，不是一种真正的Mode，事件可以运行在所有标有common modes标记的模式中，对应OC中的<code>NSRunLoopCommonModes</code>，带有common modes标记的模式有：UITrackingRunLoopMode和kCFRunLoopDefaultMode</li>
<li>UIInitializationRunLoopMode：在<code>启动</code> App时进入的第一个 Mode，<code>启动完成后就不再使用</code></li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部Mode，通常用不到</li>
</ul>
</li>
</ul>
<h3 id="以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="以+scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>以+scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><ul>
<li>这里强调一点：在主线程中以+scheduledTimerWithTimeInterval…的方式触发的timer默认是运行在<code>NSDefaultRunLoopMode</code>模式下的，当滑动页面上的列表时，进入了<code>UITrackingRunLoopMode</code>模式，这时候timer就会停止</li>
<li><p>可以修改timer的运行模式为<code>NSRunLoopCommonModes</code>，这样定时器就可以一直运行了</p>
</li>
<li><p>以下是我的笔记补充：</p>
<ul>
<li>在<code>子线程</code>中通过<code>scheduledTimerWithTimeInterval:...方法</code>来构建NSTimer<ul>
<li>方法内部已经创建NSTimer对象，并加入到RunLoop中，运行模式为NSDefaultRunLoopMode</li>
<li>由于Mode有timer对象，所以RunLoop就开始监听定时器事件了，从而开始进入运行循环</li>
<li>这个方法<code>仅仅</code>是创建RunLoop对象，并<code>不会</code>主动启动RunLoop，需要再<code>调用run方法</code>来启动</li>
</ul>
</li>
<li><p>如果在<code>主线程</code>中通过<code>scheduledTimerWithTimeInterval:...方法</code>来构建NSTimer，就不需要主动启动RunLoop对象，因为主线程的RunLoop对象在程序运行起来就已经被启动了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userInfo参数：用来给NSTimer的userInfo属性赋值，userInfo是只读的，只能在构建NSTimer对象时赋值</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="string">@"guoxianzhuang"</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// scheduledTimer...方法创建出来NSTimer虽然已经指定了默认模式，但是【允许你修改模式】</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="comment">// 【仅在子线程】需要手动启动RunLoop对象，进入运行循环</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="猜想runloop内部是如何实现的？"><a href="#猜想runloop内部是如何实现的？" class="headerlink" title="猜想runloop内部是如何实现的？"></a>猜想runloop内部是如何实现的？</h3><ul>
<li>从字面意思看：运行循环、跑圈；</li>
<li><strong><code>本质：</code></strong>内部就是<code>do-while循环</code>，在这个循环内部不断地处理各种事件(任务)，比如：Source、Timer、Observer；</li>
<li>每条线程都有<code>唯一</code>一个RunLoop对象与之对应，主线程的RunLoop默认已经启动，子线程的RunLoop需要<code>手动启动</code>；</li>
<li>每次RunLoop启动时，<code>只能</code>指定其中一个 Mode，这个Mode被称作 CurrentMode，如果需要切换Mode，只能<code>退出</code>Loop，再<code>重新指定</code>一个Mode进入，这样做主要是为了隔离不同Mode中的Source、Timer、Observer，让其互不影响；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runtime怎么添加属性、方法等&quot;&gt;&lt;a href=&quot;#runtime怎么添加属性、方法等&quot; class=&quot;headerlink&quot; title=&quot;runtime怎么添加属性、方法等&quot;&gt;&lt;/a&gt;runtime怎么添加属性、方法等&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ivar
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
</feed>
