<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客</title>
  <subtitle>菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-25T11:52:13.248Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年度总结</title>
    <link href="http://yoursite.com/2019/01/10/life-2018/"/>
    <id>http://yoursite.com/2019/01/10/life-2018/</id>
    <published>2019-01-10T09:59:10.000Z</published>
    <updated>2019-01-25T11:52:13.248Z</updated>
    
    <content type="html"><![CDATA[<p>转眼2018年已经过去了，年龄越大时间过的越快。这一年是有趣的一年，平平淡淡的湖面下，活跃着自己一颗跳动的心。</p>
<p>今年是深入投资的一年，虽然投资的结果比较惨淡，但是对应的给自己带来的收获却是千金难买的。</p>
<p>之前一直在玩的基金今年也没玩了，于是就定投了部分，放在那里不看了，引起不了自己的兴趣。</p>
<p>17年是比特币爆火的一年，自己涉足这块的时候已经是在山顶开始漫漫熊途了。17年底只是轻仓试玩。18年年初已经开始重金杀入了。从波段到杠杠，以一个小菜鸟的身份玩的不亦乐乎。虚拟货币的暴涨暴跌也反应在了自己的心态上，完全没有自己的交易模式和交易理念。那个时候仿佛着魔了一般，走着路经常看着行情，被对象说了好多次，惭愧惭愧。</p>
<p>对应的中国股市，2018也是一熊到底。那个时候学习网上很多人的价值投资，都是以巴菲特为例子，但是很多人都误解了价值投资的定义，在中国股市搞价值投资，无异于小时候玩过的挖地雷游戏，动不动就是一个雷。长生生物，乐视，中兴通讯，康得新等等等等，让“价值投资”的人轻轻松松倾家荡产。</p>
<p>每种投资模式在不同的阶段和在不同性格的人身上都会发挥很重要的作用，只是这种方式目前还不适合我而已。</p>
<p>从价值投资到投机到波段到潜伏到超短，这一路下来磕磕绊绊，黑灯瞎火的摸索，短短几个字承载了自己太多的心血。</p>
<p>悲伤，迷茫，痛苦，绝望，希望，喜悦，既然选择了这里，这里的一切都是对你的磨练。</p>
<p>功夫不负有心人。这一年对交易对投资有了更深入的认识，也总算是找到了自己的交易模式和原则。</p>
<p><strong>投资</strong>不仅仅是指交易，而是一种生活态度和看待问题的方式。这是我的一点拙见。</p>
<p>有点扯远了~</p>
<p>工作上，今年一直在做自己最喜欢的证券软件的开发，而且产品形式和特点非常有趣，非常棒。自己工作的内容刚好是自己特别爱好的事情，这是一件多么幸运的事情啊。感恩！</p>
<p>而且工作中也遇到了很多非常厉害的同事，从他们身上也学到了很多。</p>
<p>年中的时候学习了<code>python</code> ，后来耽搁了，已经快还回去了。接下来要好好学习学习。</p>
<p>生活上，可能自己变懒了吧，参加朋友的聚会越来越少了。天气暖和的时候，晚上还和同事一块打打球，进入冬天后就没怎么运动了。重点是：女朋友把我从120斤的小伙养成了140来斤的中年大叔~~。</p>
<p>和喜欢的人一起牵手迎接来了2018，又一起迎来了2019，这种感觉，真好。</p>
<p>展望2019：</p>
<p>要坚持锻炼身体。</p>
<p>努力提高技术能力。</p>
<p>规划两次远途旅游，读万卷书也要行万里路。</p>
<p>2019，充满未知充满忐忑充满挑战充满希望的又一年又来了。</p>
<p>恩，已经来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼2018年已经过去了，年龄越大时间过的越快。这一年是有趣的一年，平平淡淡的湖面下，活跃着自己一颗跳动的心。&lt;/p&gt;
&lt;p&gt;今年是深入投资的一年，虽然投资的结果比较惨淡，但是对应的给自己带来的收获却是千金难买的。&lt;/p&gt;
&lt;p&gt;之前一直在玩的基金今年也没玩了，于是就定投了
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计</title>
    <link href="http://yoursite.com/2018/12/25/iOS-OOD/"/>
    <id>http://yoursite.com/2018/12/25/iOS-OOD/</id>
    <published>2018-12-25T13:52:50.000Z</published>
    <updated>2019-01-21T08:16:10.254Z</updated>
    
    <content type="html"><![CDATA[<p>最近要在团队内部分享一场面向对象的分享会，做了部分内容整理。      </p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>1.在OO设计中，属性和行为都包含在一个对象中；而在过程式程序设计中，属性和行为是分开的，它把程序的内容分为数据和操作数据的操作两部分，这种编程方式的核心问题是数据结构和算法的开发和优化。</p>
<blockquote>
<p>也就是说，在结构化设计中，数据和过程通常是分离的，有时数据时全局的，多个函数都可以访问全局数据，说明对数据的访问是非受控而且不可预测的，这给测试和调试带来了很多困难。而对象技术可以解决这些问题，它将数据和行为合并到一个完备的包中。</p>
</blockquote>
<p>2.面向过程是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物（对象）在解决整个问题步骤中的行为。</p>
<p>例如五子棋系统的开发：</p>
<p><img src="https://github.com/corderguo/gxz/blob/master/wuzhiqi.jpg?raw=true" alt="五子棋"></p>
<blockquote>
<p>面向过程的设计思路就是首先分析问题的步骤：</p>
<ol>
<li>开始游戏</li>
<li>黑子先走</li>
<li>绘制画面</li>
<li>判定输赢</li>
<li>轮到白子</li>
<li>绘制画面</li>
<li>判定输赢</li>
<li>返回步骤2</li>
<li>输出最后结果</li>
</ol>
<p>把上面每个步骤分别用函数实现，问题就解决了。</p>
<p>而面向对象的设计原则是从另外的思路来解决问题。整个五子棋可以分为：</p>
<ol>
<li>黑白双方（玩家对象），这两方的行为是一模一样的</li>
<li>棋盘系统(对象)，负责绘制画面</li>
<li>规则系统(对象)，负责判定诸如犯规、输赢等。</li>
</ol>
<p>玩家对象负责接受用户输入，并告知棋盘对象棋子布局的变化，棋盘系统对象接收到棋子的变化负责在屏幕上显示出变化，同时利用规则系统对象来对棋局进行判定。</p>
</blockquote>
<p>可以看出，面向对象是以<strong>功能</strong>来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图功能的统一。</p>
<p>功能上的统一保证了面向对象的可扩展性。</p>
<blockquote>
<p>比如要加入悔棋的功能，在面向过程的设计中，从输入到判定到显示这一连串的步骤都要改动，甚至整体上要进行大规模的改动。假如是面向对象设计的话，只用改动棋盘对象就行了，棋盘对象保存了黑白双方的棋谱，简单的回溯就可以了，而其他地方则不用改动，改动的只是局部。</p>
</blockquote>
<p>到这里可以很明显的看出面向对象和面向过程的区别了。</p>
<p><strong><em>面向过程向面向对象的演进：</em></strong></p>
<p>在结构化编程中，人们发现把某种数据结构和用于操纵它的各种操纵绑定到一起会非常方便，如果对抽象数据类型进一步的抽象，会发现这种数据类型的实例会成为一个具体的东西、事物、对象，这就引发了人们对编程过程中怎么看待处理问题的一次大的改变。经过不断的发展，人们处理问题的思考的方式不再是怎样的数据结构描述问题，而是直接考虑各个对象之间的关系。这就出现了现在的面向对象开发。</p>
<p>====================================================================</p>
<h3 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h3><p>面向对象三大核心要素：<strong>封装、继承、多态</strong>。</p>
<p><strong>封装</strong></p>
<p>通过把属性和方法合并到一个实体中，这在OO术语称为<strong>封装</strong>。可以再不影响使用的情况下改变类的内部实现。同时限制对某些属性或方法的访问，保护类内部数据。</p>
<blockquote>
<p>比如<code>Math</code>对象中有两个整数<code>intA</code> 和<code>intB</code>，同时有一个<code>sum()</code>方法将这两个整数相加求和，通过封装处理，限制其它对象对<code>Math</code>对象中数据的访问，这样的好处是你无须知道两个数的和是如何计算的。采用这种设计方法，我们可以改变<code>Math</code>对象计算两个数的和的方法，而不需要修改调用者的逻辑。你想要的只是两个数的和，并不关心它是如何计算的。</p>
</blockquote>
<p><strong>接口</strong></p>
<p><strong>接口</strong>是对象间通信的基本途径。在面向对象设计中，要尽可能多地隐藏数据。</p>
<p>public方法和属性才属于接口。</p>
<p>设计类是要遵循最小接口原则：</p>
<ol>
<li>只有在用户需要的时候才增加接口。</li>
<li>只为用户提供他们确实需要的东西，这意味着类的接口尽可能少。</li>
<li>从用户角度设计类，而不要从信息系统的角度进行设计。应该从易于用户使用的角度考虑。</li>
<li>确保设计类时与将真正使用这个类的人（不只是开发人员）反复考虑过需求和设计。</li>
</ol>
<p>设计接口的时候要使用<strong>抽象思维</strong>：OO程序设计的主要优点之一是类可以重用。一般地，可重用类的接口往往更抽象而不是更具体。具体接口通常比较特定，而抽象的接口更为一般。（通常如此）。</p>
<p>所以我们在设计接口的时候，要想充分利用OO带来的好处，我们就需要设计高度抽象的用户接口。</p>
<blockquote>
<p>例如：创建了一个出租车对象，有一个<em>载我去机场</em> 的接口比诸如<em>左转、右转、启动、停车</em> 等单独的接口更好用。</p>
</blockquote>
<p>对属性的访问加以控制，一旦出现问题，就不必操心去跟踪可能改变该属性的每一段代码，它只会在一个地方改变（即设置方法中）。从安全性的角度看，也不希望无控制的代码修改或获取敏感数据。</p>
<p><strong>构造函数</strong>(如果一个方法与所在类同名，而且没有提供任何返回类型，则这个方法就是一个特殊的方法。oc是以init开头)</p>
<p>通常把构造函数作为类的入口点，构造函数非常适合完成初始化和准备工作。其中初始化属性是构造函数完成的一个常见功能，能确保应用处于一种稳定的状态。</p>
<p>一般经验是，总是应该提供一个构造函数，即使你不打算在其中做任何事情。可以先提供一个构造函数，其中不包含任何内容，等以后补充。使用编译器提供的默认构造函数尽管从技术上没什么问题，但是最好清楚地知道你的代码到底是怎样的。比如一个属性默认初始化为0，当这个属性用作除法运算时，就会出现不稳定的情况。</p>
<p><strong>类名</strong></p>
<p>类名相当重要，类名可以描述类本身，它提供了这个类做什么以及它与更大系统如何交互的有关信息。见名知意才是比较好的类名设计。</p>
<h3 id="类设计指导原则"><a href="#类设计指导原则" class="headerlink" title="类设计指导原则"></a>类设计指导原则</h3><ol>
<li><p>真实世界系统建模。</p>
<blockquote>
<p>面向对象程序设计的主要目标之一就是类似于人们真正的思维方式对真实世界的系统建模。这种思想的妙处在于，类能够对真实对象以及这些对象与其他真实对象如何交互进行建模。比如<code>Cat</code>和<code>Dog</code>类都是对真实世界的实体建模。</p>
</blockquote>
</li>
<li><p>明确最小公共接口，并隐藏实现。</p>
<blockquote>
<p>为用户提供简洁和有用的功能。并对用户隐藏实现细节。</p>
</blockquote>
</li>
<li><p>设计健壮的构造函数。</p>
</li>
<li><p>在类中设计错误处理。</p>
<blockquote>
<p>每个系统都会遇到不可遇见的问题。设计类时，开发人员应该要预计可能出现的错误，并包含一些代码，从而在真正遇到这种错误时处理这些情况。</p>
<p>一般经验是，应用绝对不能崩溃。遇到错误时，系统应当自行修正并继续，或者妥善地退出，不要丢失任何对用户重要的数据。</p>
</blockquote>
</li>
<li><p>设计时充分考虑重用。</p>
<blockquote>
<p>对象可以在不同系统中重用，因此编写代码时应当充分考虑重用。设计类时应当做周全的考虑，尽可能想到所有可能性。</p>
</blockquote>
</li>
<li><p>设计时充分考虑可扩展性。</p>
<blockquote>
<p>比如在设计<code>Person</code> 类的时候，应当只包含一个人特定的数据和行为。这样其他类派生该类时，继承其适当的数据和行为，而不会夹杂其它不属于该类的数据或行为。</p>
<ol>
<li><p>抽出不可移植的代码</p>
<ul>
<li>指的是将这些不可移植的代码单独放在一个类中，或者至少单独放在一个方法中（一个可以覆盖的方法）。</li>
</ul>
</li>
<li><p>让作用域尽可能的小</p>
<ul>
<li>这与抽象和将实现隐藏的概念是紧密相关的。这种思想是尽可能将属性和行为置于局部。采用这种方式，维护、测试和扩展类就会容易得的。</li>
</ul>
</li>
<li><p>类应当对自己负责</p>
<ul>
<li><p>所有的对象都应当尽可能的自行负责自己的行为。举个例子：</p>
<p>假如有个<code>Shape</code>类，有一个<code>print</code> 打印形状的接口，如果你想打印圆形该如何处理呢。这里可以利用多态把<code>Circle</code> 类归到 <code>Shape</code> 类中，<code>Shape</code> 知道应该如何自行打印。如果再扩展其它形状也就很好扩展。（多态是一种非常好的解耦合方式）</p>
<p><img src="https://github.com/corderguo/gxz/blob/master/uml_shape.png?raw=true" alt=""></p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>设计时充分考虑可维护性</p>
<blockquote>
<p>设计类的过程要求你将代码组织到多个可管理的部分中。单独的代码段往往比更大的代码更可维护。为了提高可维护性，一定要减少相互依赖的代码，降低类的耦合度。</p>
</blockquote>
</li>
</ol>
<p><strong>多态</strong> </p>
<p>不同类的对象对同一消息作出不同的响应就叫多态。也可以简单理解为：父类指针指向子类对象。多态是面向对象的重要特征，可以帮助我们消除类之间的耦合关系。</p>
<p>Shape的例子</p>
<h3 id="利用对象设计好的系统"><a href="#利用对象设计好的系统" class="headerlink" title="利用对象设计好的系统"></a>利用对象设计好的系统</h3><p>一个可靠的OO设计往往包括以下步骤：</p>
<ol>
<li>完成适当的分析</li>
<li>建立一份描述系统的工作陈述</li>
<li>从这个工作陈述中收集需求</li>
<li>开发一个用户界面原型</li>
<li>明确类</li>
<li>确定各个类的职责</li>
<li>确定各个类如何相互交互</li>
<li>创建一个高层模型来描述要构建的系统</li>
</ol>
<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>继承和组合都是实现重用的机制。要想重用原先构建的类，只能通过继承和组合这两种途径。</p>
<p><strong>继承</strong></p>
<p><strong>继承</strong> 是从其他类继承属性和行为。这种情况下，存在一种真正的父/子关系。（is-a）</p>
<p>OO程序设计中很强大的一个特性是代码重用，继承不仅有利于代码重用，还可以实现更好的整体设计。OO程序设计中主要的设计问题之一就是抽取不同类的共性，而继承就会发挥很好的作用。</p>
<p><img src="/Users/guoxianzhuang/Desktop/mammal.png" alt="uml1"></p>
<p><code>Dog</code>和<code>Cat</code>的代码都包含表示眼睛颜色的属性，可以利用继承找出他们的共性，相同的特性上移到<code>Mammal</code>类中，这种情况下<code>Dog</code> 和 <code>Cat</code> 都继承自 <code>Mammal</code> 类。</p>
<p>这样带来的显著的好处：我们编写 <code>Dog</code> 和 <code>Cat</code> 类时不需要重新编写父类已有的方法，假如要修改 <code>Mammal</code>  中的方法，就不需要再在 <code>Dog</code> 和 <code>Cat</code> 类中修改了。   而且 <code>Dog</code> 和 <code>Cat</code> 都是 <code>Mammal</code> 也符合我们的认知，并且以后扩展不同种的狗或猫都可以分别继承 <code>Dog</code> 和 <code>Cat</code> 。这样逐步向下建立继承树时对象会越来越具体。<em>继承的思想就是通过抽出共性实现从一般化到特殊化(具体化)</em> 。</p>
<p>在<em>EffectiveC C++</em> 中给出了一个例子，来说明使用继承完成设计时遭遇的一个难题。考虑为鸟建立一个类。鸟的突出特征就是鸟能飞，所以创建了一个包含 <code>fly</code> 方法的 <code>Bird</code> 类。这个时候应该发现问题，企鹅和鸵鸟怎么办，他们都是鸟，但是不能飞。可以局部覆盖这种行为，但是这个方法名仍然是 <code>fly</code> ,对于一个不会飞的鸟，有一个 <code>fly</code> 方法显然是不合理的。</p>
<p>其实我认为这里并不是继承的缺陷，而是抽出共性的过程出现了问题，可以创建两个类，分别对应能飞的鸟和不能飞的鸟即可。</p>
<p><strong><em>继承同时也是面向对象的另一个重要特征——多态 的实现的基础。</em></strong></p>
<p><strong><em>设计决策</em></strong></p>
<p>理论上讲，应该尽可能多地抽出共性。尽管尽可能多地抽取共性可以尽量接近实际生活，但也许并不能尽可能贴切地表示你的模型。抽取得越多，系统就会越复杂（在大规模系统中，反复这种决策，复杂性会飞速增加）。这里就带来了一个难题：你想要一个更精确的模型还是一个不太复杂的系统，这里就要根据自己的具体情况作出选择。</p>
<p>有些情况下，你的设计中，模型的更准确所带来的好处比不上它所增加的复杂性。</p>
<p>设计的根本目标是构建一个灵活的系统，但不要增加太大的复杂性使系统自己不堪重负。</p>
<p>比如：你是一位动物管理员，只是养一些寻常的鸟类，并且以后也没有计划进购那些笨重的鸟类，那么在设计的时候，<code>Bird</code> 中就可以有它们共同的行为 <code>fly</code>。</p>
<p><strong><em>继承会削弱封装</em></strong></p>
<p>封装在OO中是非常重要的，这是OO中的基本概念。通过封装，类隐藏了不需要其它类知道的所有细节。（这句可以不要）</p>
<p>继承关系的类与其它类仍然是强封装，但是超类和子类之间的封装被削弱了。如果子类从超类继承了一个实现，然后超类修改这个实现，那么超类的修改可能会对整个类层产生涟漪影响。</p>
<p>为了减少这种情况所产生的风险，使用继承时一定要坚持严格的 <code>is-a</code> 条件，这很重要。如果子类确实是超类的一种特殊化，那么父类的修改会是一种自然的、可预见的方式影响子类。其实好与坏只是看运用方式是否得当。</p>
<p><strong>组合</strong></p>
<p><strong>组合</strong> 是指使用其他对象来构建对象。这是一种组装，不存在父/子关系。(has-a)</p>
<blockquote>
<p> 例如，汽车有一个（has-a）发动机。发动机和汽车是不同的对象。这就构成了一种组合关系。</p>
</blockquote>
<p>使用组合的原因是，可以通过结合不太复杂的部分来构建复杂系统。这是人们解决问题的常用方法。</p>
<blockquote>
<p>比如，我们看到一辆车，我们会说“这里有一辆车”，而不会说“这里有一个包括一个方向盘，4个轮子和一个发动机等的大家伙”。</p>
</blockquote>
<p>使用组合的另一个主要优点是系统和子系统可以独立构建，更重要的是，可以独立地测试和维护。当今的软件系统越来越复杂，要让大型软件系统正常地工作而且易于维护，它们必须分解为较小的、更可管理的部分。而组合则可以做到这些。</p>
<p>而且使用组件的另一个好处是，你可以使用其他开发人员构建的组件，方便自己的开发。</p>
<p><img src="https://github.com/corderguo/gxz/blob/master/yinxiang.jpg?raw=true" alt="yinxiang"></p>
<blockquote>
<p>比如音响系统，单独的部件坏了可以重新换一个部件即可继续使用，而如果这个系统是个集成系统（也就是说该系统完全是一个大黑箱系统），不是基于组件构成，这个情况下，你需要把整个系统拿去修理，这样做不仅复杂，费用高，同时你也将无法使用其他并没有损坏的部分。</p>
</blockquote>
<p>诺贝尔奖得主Herbert Simon对稳定系统提出以下观点：</p>
<ol>
<li>稳定的复杂系统通常采用一种层次结构的形式，其中各个系统都是由更简单的子系统构成，而各个子系统则是由更简单的下一级子系统构成。</li>
<li>稳定的复杂系统几乎都是可以分解的。</li>
<li>稳定的复杂系统几乎总是只由几个不同类型的子系统组成，并以不同的结合方式组织。</li>
<li>能正常工作的稳定系统几乎总是由能正常工作的简单系统发展而来。</li>
</ol>
<p>这也说明的<strong>组合</strong>的重要性。</p>
<p>使用组合时，要避免建立非常依赖其他对象的对象，也即是<strong><em>避免依赖性</em></strong>。</p>
<p>使用太多组合也会导致更大的模型复杂性。这和继承中模型复杂性的问题类似。</p>
<blockquote>
<p>假设汽车由一个发动机、一个音响、和一个车门组成。发动机又包含活塞和火花塞。音响包含收音机和CD播放器。车门包含一个把手。再往下一个层次，收音机还需要一个调谐开关，车门把手包含一把锁等。多层次详细的组合树也会导致模型复杂性的问题。</p>
</blockquote>
<p><strong>小结</strong></p>
<p>很多知名的OO设计人员指出，应该尽可能的地使用组合，而只在必要的情况下才使用继承。 尽管更多的情况下使用组合比使用继承更合适，但是继承和组合都是很好的设计方式，需要应用到适当的上下文环境中。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要在团队内部分享一场面向对象的分享会，做了部分内容整理。      &lt;/p&gt;
&lt;h3 id=&quot;面向对象和面向过程的区别&quot;&gt;&lt;a href=&quot;#面向对象和面向过程的区别&quot; class=&quot;headerlink&quot; title=&quot;面向对象和面向过程的区别&quot;&gt;&lt;/a&gt;面向对象和面
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用Fastlane实现自动化打包</title>
    <link href="http://yoursite.com/2018/10/09/fastlane_study/"/>
    <id>http://yoursite.com/2018/10/09/fastlane_study/</id>
    <published>2018-10-09T05:59:20.000Z</published>
    <updated>2018-10-09T06:33:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="http://coderperson.com/2018/09/29/iOS-auto_packaging/" target="_blank" rel="external">文章</a>讲解了利用python封装脚本进行自动化打包，这两天又看了看github上很火的自动化打包工具<a href="https://github.com/fastlane/fastlane" target="_blank" rel="external">Fastlane</a>。</p>
<p>Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 官方文档看<a href="https://docs.fastlane.tools/" target="_blank" rel="external">这里</a>。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>安装Xcode命令行工具:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<ul>
<li>查看ruby版本，要求2.0及以上版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br><span class="line"></span><br><span class="line">ruby的镜像文件路径改为https://gems.ruby-china.org/</span><br><span class="line"></span><br><span class="line">gem sources --remove https://ruby.taobao.org/</span><br><span class="line"></span><br><span class="line">gem sources --add https://rubygems.org</span><br><span class="line"></span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<ul>
<li>安装：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install fastlane</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>切换项目目录到包含xxx.xcodeproj的项目目录下输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure>
<p>输出：        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[15:21:56]: What would you like to use fastlane for?</span><br><span class="line">1. 📸  Automate screenshots</span><br><span class="line">2. 👩‍✈️  Automate beta distribution to TestFlight</span><br><span class="line">3. 🚀  Automate App Store distribution</span><br><span class="line">4. 🛠  Manual setup - manually setup your project to automate your tasks</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<p>这四个选项的意思是:        </p>
<blockquote>
<p>1.自动截屏。这个功能能帮我们自动截取APP中的截图，并添加手机边框（如果需要的话），我们这里不选择这个选项，因为我们的项目已经有图片了，不需要这里截屏。</p>
<p>2.自动发布beta版本用于TestFlight，如果大家有对TestFlight不了解的，可以参考王巍写的这篇文章</p>
<p>3.自动的App Store发布包。我们的目标是要提交审核到APP Store，按道理应该选这个，但这里我们先不选，因为选择了以后会需要输入用户名密码，以及下载meta信息，需要花费一定时间，这些数据我们可以后期进行配置。</p>
<p>4.手动设置。</p>
</blockquote>
<p>选择第四个后一路回车即可（等待时间略长），结束后会看到生成了fastlane目录，该目录包含Appfile和Fastfile；同时还生成了两个文件Gemfile和Gemfile.lock，是和fastlane文件夹在同一个目录。</p>
<h3 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h3><p>Appfile用来存放app_identifier，apple_id和team_id。文件生成的时候会定义好格式，按格式填写即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_identifier(&quot;[[xxxx]]&quot;) # The bundle identifier of your app</span><br><span class="line">apple_id(&quot;[[xxxx]]&quot;) # Your Apple email address</span><br></pre></td></tr></table></figure>
<p>你也可以为每个lane提供不同的 app_identifier, apple_id 和 team_id，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for_lane :inhouse do</span><br><span class="line">  app_identifier &quot;xxxx&quot;</span><br><span class="line">  apple_id &quot;xxxx&quot;</span><br><span class="line">  team_id &quot;xxxx&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里就是为Fastfile中定义的inhouse这个lane设置单独的信息。</p>
<h3 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h3><p>Fastfile管理你所创建的 lane 。</p>
<blockquote>
<ul>
<li>scan 自动化测试工具，很好的封装了 Unit Test    </li>
<li>sigh 针对于 iOS 项目开发证书和 Provision file 的下载工具    </li>
<li>match 同步团队每个人的证书和 Provision file 的超赞工具    </li>
<li>gym 针对于 iOS 编译打包生成 ipa 文件    </li>
<li>deliver 用于上传应用的二进制代码，应用截屏和元数据到 App Store    </li>
<li>snapshot 可以自动化iOS应用在每个设备上的本地化截屏过程    </li>
</ul>
</blockquote>
<p>这里我们主要用<code>gym</code>来打包。</p>
<p>Fastlane内部的工具不是新写的，而是调用mac本身的命令，只不过是实现了自动化而已。比如gym工具只是xcodebuild工具的一个封装，如果你会xcodebuild，那gym对你来说小菜一碟。xcodebuild的使用可以看<a href="http://coderperson.com/2018/09/29/iOS-auto_packaging/" target="_blank" rel="external">这篇文章</a>。</p>
<p>找了一个比较全的格式，可以参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 指定 fastlane 最小版本</span><br><span class="line">fastlane_version &quot;2.20.0&quot;</span><br><span class="line"></span><br><span class="line"># 指定当前平台，可以设置为 ios 、android、mac</span><br><span class="line">default_platform :ios</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line"></span><br><span class="line"># 在执行每一个 lane 之前都先执行这个代码</span><br><span class="line">  before_all do</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line"># 定义一个创建测试包的 lane</span><br><span class="line"># 我们调用的命令就是调用 fastlane 的 lane</span><br><span class="line">  lane :buildDebugApp do |op|</span><br><span class="line">      # 根据输入的版本设置项目 version number （我们初始化 fastlane 的时候是在 .xcworkspace 目录下， 而我们的项目中 ，.xcworkspace 和 .xcodeproj 不在同一级目录，这里的“increment_version_number”需要检测 .xcodeproj 项目文件，所以需要指定该文件的目录）</span><br><span class="line">    increment_version_number(&#123;xcodeproj: &apos;./HomeMate2_Trunk/HomeMate.xcodeproj&apos;, version_number: op[:version]&#125;)</span><br><span class="line"></span><br><span class="line">    # 根据输入的版本设置项目 build number （同上，也是需要指定 .xcodeproj 的目录）</span><br><span class="line">    increment_build_number(&#123;xcodeproj: &apos;./HomeMate2_Trunk/HomeMate.xcodeproj&apos;, build_number: op[:version]&#125;)</span><br><span class="line"></span><br><span class="line">    # 最重要的打包命令</span><br><span class="line">    gym(</span><br><span class="line">              export_method: &apos;ad-hoc&apos;,        # 打包的方式，可设置为 appstore(默认)，enterprise</span><br><span class="line">                     scheme: &quot;HomeMate&quot;,    # 指定需要打那个 scheme 的包</span><br><span class="line">                  workspace: &quot;HMWorkSpac.xcworkspace&quot;,    # 指定打包的项目文件</span><br><span class="line">                output_name: &quot;HomeMate.ipa&quot;,      # 打包输出名称</span><br><span class="line">                     silent: true,    # 隐藏不必要信息</span><br><span class="line">                      clean: true,    # 打包前是否 clean 项目</span><br><span class="line">              configuration: &quot;Debug&quot;,    # 配置为 debug 版本</span><br><span class="line">              buildlog_path: &quot;./fastlanelog&quot;,    # 日志输出目录</span><br><span class="line">       codesigning_identity: &quot;iPhone Developer: Hailiang He (xxxxxxxxxx)&quot;,       # 代码签名证书</span><br><span class="line">           output_directory: &quot;/Users/xxx/Desktop&quot;     # ipa输出目录</span><br><span class="line">     )</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 在执行每一个 lane 之后执行该功能</span><br><span class="line">  after_all do |lane|</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # 在执行每一个 lane 出错的时候执行该功能</span><br><span class="line">  error do |lane, exception|</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>上面的代码块包含了日常打包常用的功能，可以参考。</p>
<p>我这边测试打包的时候，写了一个最简单版本的Appfile和Fastfile文件，理解了这个最简单版本，在这个基础上继续增加功能即可，<code>非常便于理解</code>。</p>
<p>Appfile文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_identifier(&quot;[[xxx]]&quot;) # The bundle identifier of your app</span><br><span class="line">apple_id(&quot;[[xxx]]&quot;) # Your Apple email address</span><br></pre></td></tr></table></figure>
<p>Fastfile文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">  desc &quot;Description of what the lane does&quot;</span><br><span class="line">  lane :custom_lane do</span><br><span class="line">    # add actions here: https://docs.fastlane.tools/actions</span><br><span class="line">    gym(scheme: &quot;xxx&quot;,</span><br><span class="line">      export_method:&quot;ad-hoc&quot;,</span><br><span class="line">      output_directory:&quot;./build&quot;, # 打包后的 ipa 文件存放的目录</span><br><span class="line">      output_name:&quot;xxx.ipa&quot;  # ipa 文件名</span><br><span class="line">   )</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>export_method对应的打包类型：app-store、ad-hoc、development、enterprise。</p>
<p>编辑好以上内容，打开终端执行下面的命令，即可看到在当前目录下生成一个build文件夹，ipa包就在该文件夹中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane custom_lane</span><br></pre></td></tr></table></figure>
<p>如果lane中设置了可以接收版本号,则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane custom_lane version:1.1.0</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;http://coderperson.com/2018/09/29/iOS-auto_packaging/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;讲解了利用python封装脚本进行自动化打包，这两天又看了看git
    
    </summary>
    
      <category term="Ruby" scheme="http://yoursite.com/categories/Ruby/"/>
    
    
      <category term="Ruby" scheme="http://yoursite.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>利用python实现自动化打包</title>
    <link href="http://yoursite.com/2018/09/29/iOS-auto_packaging/"/>
    <id>http://yoursite.com/2018/09/29/iOS-auto_packaging/</id>
    <published>2018-09-29T11:12:59.000Z</published>
    <updated>2018-10-09T06:32:52.769Z</updated>
    
    <content type="html"><![CDATA[<p>频繁的手动打包是一项耗时耗力的工程，而且是一项重复性的劳动，因此实现打包的自动化是非常必要的。通过自动化打包可以实现一键打包，并上传到fir或蒲公英等第三方平台。</p>
<h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h2><p>当我们通过<code>Archive</code>手动打包的时候，<code>Xcode</code>本身是通过调用<code>xcodebuild</code>命令来实现打包的过程。</p>
<p><code>xcodebuild</code>是苹果提供的用于打包项目或者工程的命令，可以通过<code>man xcodebuild</code>命令查看它的介绍。</p>
<blockquote>
<p>NAME        </p>
<p>xcodebuild – build Xcode projects and workspaces</p>
<p>DESCRIPTION</p>
<p>xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.</p>
<p>Usage</p>
<p>To build an Xcode project, run xcodebuild from the directory containing your project (i.e. the<br>     directory containing the name.xcodeproj package). If you have multiple projects in the this<br>     directory you will need to use -project to indicate which project should be built.  By default,<br>     xcodebuild builds the first target listed in the project, with the default build configuration.<br>     The order of the targets is a property of the project and is the same for all users of the<br>     project.<br>To build an Xcode workspace, you must pass both the -workspace and -scheme options to define the<br>     build.  The parameters of the scheme will control which targets are built and how they are built,<br>     although you may pass other options to xcodebuild to override some parameters of the scheme.<br>     There are also several options that display info about the installed version of Xcode or about projects or workspaces in the local directory, but which do not initiate an action.  These<br>     include -list, -showBuildSettings, -showdestinations, -showsdks, -usage, and -version.</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>需要在包含 <code>name.xcodeproj</code> 的目录下执行 <code>xcodebuild</code> 命令，且如果该目录下有多个 projects，那么需要使用 <code>-project</code> 指定需要 build 的项目。</li>
<li>在不指定 <code>build</code> 的 <code>target</code> 的时候，默认情况下会 build project 下的<code>第一个</code>target</li>
<li>当 build workspace 时，需要同时指定 <code>-workspace</code> 和 <code>-scheme</code> 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。</li>
<li>有一些诸如 <code>-list, -showBuildSettings, -showsdks</code> 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。</li>
</ul>
<p>那么，xcodebuild 究竟如何使用呢？ 继续看文档:</p>
<p>&gt;</p>
<blockquote>
<p>SYNOPSIS</p>
<p>xcodebuild [-project name.xcodeproj][[-target targetname] … | -alltargets]<br>                [-configuration configurationname][-sdk [sdkfullpath | sdkname]] [action …]<br>                [buildsetting=value …] [-userdefault=value …]</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …]<br>                [-destination-timeout value] [-configuration configurationname]<br>                [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …]<br>                [-userdefault=value …]</p>
<p>xcodebuild -workspace name.xcworkspace -scheme schemename<br>                [[-destination destinationspecifier] …][-destination-timeout value]<br>                [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …]<br>                [buildsetting=value …] [-userdefault=value …]</p>
<p>xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]</p>
<p>xcodebuild -showsdks</p>
<p>xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath<br>                -exportOptionsPlist path</p>
<p>等等</p>
</blockquote>
<p>挑几个常用的形式介绍一下：</p>
<ul>
<li><code>xcodebuild -showsdks</code>: 列出 Xcode 所有可用的 SDKs。</li>
<li><code>xcodebuild -showBuildSettings</code>: 查看当前工程 build setting 的配置参数。</li>
<li><code>xcodebuild [-project name.xcodeproj] [[-target targetname] ... | -alltargets] build</code>: 会 build 指定 project，其中 -target 和 -configuration 参数可以使用 xcodebuild -list 获得，-sdk 参数可由 xcodebuild -showsdks 获得。</li>
<li><code>xcodebuild -workspace name.xcworkspace -scheme schemename build</code>:build 指定 workspace，当我们使用 CocoaPods 来管理第三方库时，会生成 xcworkspace 文件，这样就会用到这种打包方式。</li>
</ul>
<h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><p><code>开始打包</code>—-&gt;<code>archive文件</code>—-&gt;<code>ipa包</code></p>
<h4 id="生成archive文件"><a href="#生成archive文件" class="headerlink" title="生成archive文件"></a>生成archive文件</h4><p>首先看一下生成<code>archive文件</code>的命令：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcodebuild archive -workspace 项目名称.xcworkspace </span><br><span class="line">                   -scheme 项目名称 </span><br><span class="line">                   -configuration 构建配置 </span><br><span class="line">                   -archivePath archive包存储路径 </span><br><span class="line">                    CODE_SIGN_IDENTITY=证书 </span><br><span class="line">                    PROVISIONING_PROFILE=描述文件UUID</span><br></pre></td></tr></table></figure>
<ul>
<li>workspace 这个就是项目名</li>
<li>scheme 可以通过xcodebuild -list获取</li>
<li>configration 一些参数，也可以通过xcodebuild -list获取，一般使用Debug、Release</li>
<li>archivePath archive后的路径</li>
<li>CODE_SIGN_IDENTITY 证书的Inentity</li>
<li>PROVISIONING_PROFILE 描述文件UUID</li>
</ul>
<p>如果使用Xcode的自动管理证书功能，则<code>CODE_SIGN_IDENTITY</code>和<code>CODE_SIGN_IDENTITY</code>参数不需要添加。</p>
<h4 id="生成ipa文件"><a href="#生成ipa文件" class="headerlink" title="生成ipa文件"></a>生成ipa文件</h4><p>同样看一下生成ipa文件的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcodebuild -exportArchive -archivePath archive文件的地址.xcarchive </span><br><span class="line">                          -exportPath 导出的文件夹地址 </span><br><span class="line">                          -exportOptionsPlist exprotOptionsPlist.plist </span><br><span class="line">                          CODE_SIGN_IDENTITY=证书 </span><br><span class="line">                          PROVISIONING_PROFILE=描述文件UUID</span><br></pre></td></tr></table></figure>
<p>官方解释：</p>
<p>&gt;</p>
<blockquote>
<p>Exports the archive MyMobileApp.xcarchive to the path ExportDestination using the<br>              options specified in export.plist.</p>
</blockquote>
<p>同样，如果你不需要的指定证书和Provisioning文件，可以把上面的两个参数去掉，它会根据你的Xcode配置去匹配。</p>
<p><code>exportOptionsPlist</code>这个参数，对应一个plist文件,用来配置一些打包时需要配置的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">    &lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UA21BCDJHK3&lt;/string&gt; //TeamID</span><br><span class="line">        &lt;key&gt;method&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;ad-hoc&lt;/string&gt; //ad-hoc打包</span><br><span class="line">        &lt;key&gt; compileBitcode&lt;/key&gt; //是否编译bitcode</span><br><span class="line">        &lt;false/&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p><code>exportOptionsPlist.plist</code>可配置的字段，可以使用<code>xcodebuild --help</code>命令查看。</p>
<p>至此你已经能通过命令生成ipa包了。</p>
<h2 id="上传第三方平台"><a href="#上传第三方平台" class="headerlink" title="上传第三方平台"></a>上传第三方平台</h2><p>一般第三方平台都会开放上传app包的API，这里以咱们使用的<code>fir</code>平台为例：</p>
<p>查看<code>fir</code>的文档，可以在<code>文档</code>中看到<code>发布应用</code>的选项卡，其中有获取上传凭证的API：</p>
<p>&gt;</p>
<blockquote>
<p>POST <a href="http://api.fir.im/apps" target="_blank" rel="external">http://api.fir.im/apps</a></p>
</blockquote>
<p>上传文件的API:</p>
<p>&gt;</p>
<blockquote>
<p>POST upload_url</p>
</blockquote>
<p>然后按文档格式，配置指定的参数即可。</p>
<p>然后利用<code>python</code>将刚才生产的ipa包，上传到fir平台即可。</p>
<h2 id="上传到AppStore"><a href="#上传到AppStore" class="headerlink" title="上传到AppStore"></a>上传到AppStore</h2><p>利用<code>altool</code>: Application Loader命令行工具可以验证并上传应用程序的二进制文件到AppStore。</p>
<h2 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h2><p>综合以上过程，利用<code>python</code>实现脚本工具，完成一键打包并上传fir。</p>
<p>工具代码如下,可以在此基础代码的基础上增加更多功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Release Debug</span><br><span class="line">CONFIGURATION = &quot;Debug&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def desktopPath():</span><br><span class="line">    return os.path.join(os.path.expanduser(&quot;~&quot;), &apos;Desktop&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#清除临时文件</span><br><span class="line">def cleanArchiveFile(archivePath):</span><br><span class="line">	cleanCmd = &quot;rm -r %s&quot; %(archivePath)</span><br><span class="line">	os.system(cleanCmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#上传到第三方平台</span><br><span class="line">def uploadIpaToPlatform(ipaPath):</span><br><span class="line"></span><br><span class="line">    #需要的参数</span><br><span class="line">    upload_url = &quot;xxxx&quot;</span><br><span class="line">    bundle_id = &quot;xxxx&quot;</span><br><span class="line">    api_token = &quot;xxxx&quot;</span><br><span class="line"></span><br><span class="line">    #获取上传凭证（上传地址）</span><br><span class="line">    data = &#123;&apos;type&apos;: &apos;ios&apos;, &apos;bundle_id&apos;: bundle_id,</span><br><span class="line">        &apos;api_token&apos;: api_token&#125;</span><br><span class="line"></span><br><span class="line">    response = requests.post(url = upload_url, data = data)</span><br><span class="line">    json = response.json()</span><br><span class="line">    binaryDict = (json[&quot;cert&quot;][&quot;binary&quot;])</span><br><span class="line"></span><br><span class="line">    print &apos;====&apos; + ipaPath + &apos;=====&apos; + binaryDict[&apos;upload_url&apos;]</span><br><span class="line"></span><br><span class="line">    f = open(ipaPath, &apos;rb&apos;)</span><br><span class="line">    file_binary = &#123;&apos;file&apos;: f&#125;</span><br><span class="line">    param = &#123;&quot;key&quot;:binaryDict[&apos;key&apos;],&quot;token&quot;:binaryDict[&apos;token&apos;]&#125;</span><br><span class="line">    #上传ipa    </span><br><span class="line">    req = requests.post(url=binaryDict[&apos;upload_url&apos;],files=file_binary,data=param,verify=False)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#build过程</span><br><span class="line">def xcbuild():</span><br><span class="line"></span><br><span class="line">	#初始化</span><br><span class="line">	#工程名字</span><br><span class="line">	workspace = &quot;test.xcworkspace&quot;</span><br><span class="line">	scheme = &quot;test&quot;</span><br><span class="line"></span><br><span class="line">	# exportOptions.plist文件路径；根据自己的实际情况改变</span><br><span class="line">	plistPath = &apos;./../../build/exportOptions.plist&apos;</span><br><span class="line"></span><br><span class="line">	#桌面路径</span><br><span class="line">	deskPath = desktopPath()</span><br><span class="line"></span><br><span class="line">	#archive文件导出路径</span><br><span class="line">	archivePath = deskPath + &apos;/&apos; + scheme + &apos;.xcarchive&apos;</span><br><span class="line"></span><br><span class="line">	#导出ipa文件所在文件名</span><br><span class="line">	currentT = time.strftime(&apos;%Y-%m-%d-%H-%M-%S&apos;,time.localtime(time.time()))</span><br><span class="line">	ipaDirName = scheme + currentT</span><br><span class="line"></span><br><span class="line">	#ipa文件路径</span><br><span class="line">	ipaPath = deskPath + &apos;/&apos; + ipaDirName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	# 生成archive文件的命令</span><br><span class="line">	archiveCmd = &quot;xcodebuild archive -workspace %s -scheme %s -configuration %s -archivePath %s&quot; %(workspace,scheme,CONFIGURATION,archivePath)</span><br><span class="line">	#python执行命令</span><br><span class="line">	os.system(archiveCmd)</span><br><span class="line">	#生成.ipa包的命令</span><br><span class="line">	exportCmd = &quot;xcodebuild -exportArchive -archivePath %s -exportOptionsPlist %s -exportPath %s&quot; %(archivePath,plistPath,ipaPath)</span><br><span class="line">	os.system(exportCmd)</span><br><span class="line"></span><br><span class="line">	#上传fir</span><br><span class="line">	uploadIpaToPlatform(ipaPath + &apos;/&apos; + scheme + &apos;.ipa&apos;)</span><br><span class="line"></span><br><span class="line">	#清除临时文件</span><br><span class="line">	cleanArchiveFile(archivePath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">	#判断输入的参数</span><br><span class="line">	if len(sys.argv) &gt; 1:</span><br><span class="line">		config = sys.argv[1]</span><br><span class="line">		global CONFIGURATION</span><br><span class="line">		if sys.argv[1]==&apos;Release&apos; or sys.argv[1]==&apos;RELEASE&apos;:</span><br><span class="line">			CONFIGURATION = &apos;Release&apos;</span><br><span class="line">		elif sys.argv[1]==&apos;Debug&apos; or sys.argv[1]==&apos;DEBUG&apos;:</span><br><span class="line">			CONFIGURATION = &apos;Debug&apos;</span><br><span class="line"></span><br><span class="line">	#build过程</span><br><span class="line">	xcbuild()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>
<p>为了不污染项目，该脚本和plist文件并没有放到项目工程目录中，而是把py文件设置成了全局可用，<code>exportOptionsPlist.plist</code>文件放到单独的目录，在脚本文件中引用即可。</p>
<p>使用的时候只需在工程目录敲命令:</p>
<p>如果打<code>Debug</code>包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build.py</span><br></pre></td></tr></table></figure>
<p>如果打<code>Release</code>包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build.py Release</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;频繁的手动打包是一项耗时耗力的工程，而且是一项重复性的劳动，因此实现打包的自动化是非常必要的。通过自动化打包可以实现一键打包，并上传到fir或蒲公英等第三方平台。&lt;/p&gt;
&lt;h2 id=&quot;xcodebuild&quot;&gt;&lt;a href=&quot;#xcodebuild&quot; class=&quot;he
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="http://yoursite.com/2018/09/21/acm-dijkstra/"/>
    <id>http://yoursite.com/2018/09/21/acm-dijkstra/</id>
    <published>2018-09-21T11:12:59.000Z</published>
    <updated>2018-10-02T08:57:54.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>假设一个开车的人希望找出从新疆到北京的可能的最短路线。他有一张中国公路地图，该公路图上标出了每一对相邻的公路交叉之间的距离，他应该如何找出这一最短路线呢？</p>
<p> 一种可能的方法就是枚举出所有从新疆到北京之间的路线，依然存在着数以百万计的行车路线，而其中绝大多数是不值得考虑的。</p>
<p>现实中很多抽象的例子都可以转化成类似这样的问题，这类问题统一称为求<code>最短路径</code>的问题。</p>
<h2 id="最短路径的解决算法"><a href="#最短路径的解决算法" class="headerlink" title="最短路径的解决算法"></a>最短路径的解决算法</h2><ul>
<li>Floyd<br>求多源、无负权边的最短路。用矩阵记录图。时效性较差，时间复杂度<code>O(V^3)</code>。</li>
<li>Dijkstra<br>求单源、无负权的最短路。时效性较好，时间复杂度<code>O(V^2)</code>。</li>
<li>Bellman-Ford<br>求单源最短路，可以判断有无负权回路。通过不断构建以源点为根的最短路径树，不断扩展。</li>
<li>SPFA<br>可以用于存在负数边权的图，算法时间效率是不稳定的，即它对于不同的图所需要的时间有很大的差别。<code>SPFA</code>算法是在<code>Bellman-Ford</code>算法的基础上进行优化而来。</li>
</ul>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h5 id="定义概览"><a href="#定义概览" class="headerlink" title="定义概览"></a>定义概览</h5><p><code>Dijkstra</code>(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。<code>Dijkstra</code>算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。</p>
<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p><code>算法思想</code>：设<code>G=(V,E)</code>是一个带权有向图，把图中顶点集合<code>V</code>分成两组，第一组为已求出最短路径的顶点集合（用<code>S</code>表示，初始时<code>S</code>中只有一个源点，以后每求得一条最短路径 , 就将加入到集合<code>S</code>中，直到全部顶点都加入到<code>S</code>中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用<code>U</code>表示），按最短路径长度的递增次序依次把第二组的顶点加入<code>S</code>中。在加入的过程中，总保持从源点<code>v</code>到<code>S</code>中各顶点的最短路径长度不大于从源点<code>v</code>到<code>U</code>中任何顶点的最短路径长度。此外，每个顶点对应一个距离，<code>S</code>中的顶点的距离就是从<code>v</code>到此顶点的最短路径长度，<code>U</code>中的顶点的距离，是从<code>v</code>到此顶点只包括<code>S</code>中的顶点为中间顶点的当前最短路径长度。</p>
<p><code>算法步骤</code>：</p>
<ol>
<li><p>初始时，<code>S</code>只包含源点，即<code>S＝{v}</code>，<code>v</code>的距离为<code>0</code>。<code>U</code>包含除<code>v</code>外的其他顶点，即:<code>U={其余顶点}</code>，若<code>v</code>与<code>U</code>中顶点<code>u</code>有边，则<code>&lt;u,v&gt;</code>正常有权值，若<code>u</code>不是<code>v</code>的出边邻接点，则<code>&lt;u,v&gt;</code>权值为<code>∞</code>。</p>
</li>
<li><p>从U中选取一个距离<code>v</code>最小的顶点<code>k</code>，把<code>k</code>，加入<code>S</code>中（该选定的距离就是<code>v</code>到<code>k</code>的最短路径长度）。</p>
</li>
<li><p>以<code>k</code>为新考虑的中间点，修改<code>U</code>中各顶点的距离；若从源点<code>v</code>到顶点<code>u</code>的距离（经过顶点<code>k</code>）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值为顶点<code>k</code>的距离加上<code>&lt;k,u&gt;</code>边上的权。</p>
</li>
<li><p>重复步骤 <code>2</code> 和 <code>3</code> 直到所有顶点都包含在 <code>S</code> 中。</p>
</li>
</ol>
<p><code>Tip</code>:<br>通常在编码过程中，以一个二维数组<code>map[][]</code>来表示整张图，以一个一维数组<code>dist[]</code>来表示源点到各个顶点的当前最短路径，以一个一维数组<code>set[]</code>来标识当前顶点是否已经被并入到集合<code>S</code>中，即当前顶点的最短路径已经求出。</p>
<p><code>执行动画</code>:</p>
<p><img src="https://corderguo.github.io/images/dijkstra.gif" alt="dijkstra_img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>由上述讲解可以写出如下Dijkstra算法代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 图的存储在 MGraph  g.n为顶点数量 g.edges[][]为边的权值</span><br><span class="line">// v为源点</span><br><span class="line">// dist[] 保存源点到各个顶点的当前最短路径</span><br><span class="line">void Dijkstra(MGraph g, int v, int dist[]) &#123;</span><br><span class="line">    int set[maxSize];</span><br><span class="line">    int min,i,j,u;</span><br><span class="line">    // 初始化</span><br><span class="line">    for(i = 0;i&lt;g.n;i++) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    set[v] = 1;</span><br><span class="line">    </span><br><span class="line">    for(i = 0;i &lt; g.n; i++ ) &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        // 这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的</span><br><span class="line">        for (j = 0;j&lt; g.n;j++) &#123;</span><br><span class="line">            if(set[h] == 0 &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        // 以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测</span><br><span class="line">        for (j = 0;j &lt; g.n;j++) &#123;</span><br><span class="line">            if (set[j]==0&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[u]+g.edges[u][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例如经典的题目<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="external">HDU1874</a>。</p>
<p><code>问题描述</code>：            </p>
<p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。<br>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p>
<p><code>Input</code>:    </p>
<p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。            </p>
<p><code>Output</code>:            </p>
<p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p>
<p><code>解析</code>：</p>
<p>这是典型的求解最短路径的问题，可以把城镇转换成图中的点，道路转换成图中的有权边，然后根据构造出的这张图，求解源点到各个点的最短路径即可。</p>
<p><code>代码</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#define MAX_INT 10000</span><br><span class="line">//</span><br><span class="line">int set[202];</span><br><span class="line">int map[202][202];</span><br><span class="line">int dis[202];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Dijkstra(int start , int n) &#123;</span><br><span class="line">    </span><br><span class="line">    // 初始化</span><br><span class="line">    for (int i = 0; i&lt;n; i ++) &#123;</span><br><span class="line">        dis[i] = map[start][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    set[start] = 1;</span><br><span class="line">    </span><br><span class="line">    for (int j = 0 ; j &lt; n; j ++) &#123;</span><br><span class="line">        </span><br><span class="line">        // 找当前最短路径</span><br><span class="line">        int temp = MAX_INT;</span><br><span class="line">        int u = start;</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            if (set[i] == 0 &amp;&amp; dis[i] &lt; temp) &#123;</span><br><span class="line">                temp = dis[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        </span><br><span class="line">        // 以u为中间点更新最短路径</span><br><span class="line">        for (int i = 0 ; i &lt; n; i ++) &#123;</span><br><span class="line">            if (set[i] == 0 &amp;&amp; dis[u] + map[u][i] &lt; dis[i]) &#123;</span><br><span class="line">                dis[i] = dis[u] + map[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m) != EOF) &#123;</span><br><span class="line">        // 图的初始化</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    map[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    map[i][j] = MAX_INT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (m--) &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            if (c &lt; map[a][b]) &#123;</span><br><span class="line">                map[a][b] = map[b][a] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int start , end;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;start,&amp;end);</span><br><span class="line">        Dijkstra(start, n);</span><br><span class="line">        if (dis[end] == MAX_INT) &#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,dis[end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个变形题目，可以当做练习：</p>
<p><a href="http://acm.hdu.edu.cn/diy/contest_show.php?cid=34192" target="_blank" rel="external">练习题</a></p>
<p>password:123</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>经过以上步骤，我们已经求出了源点到各个顶点的最短路径的值，如果此时需要知道该最短路径所上所经过的点，该如何解决呢？</p>
<p>此时我们可以用一个一维数组<code>path[]</code>来保存最短路径上所经过的订单。<br>比如：<code>path[Vi]</code>中保存从源点到<code>Vi</code>的最短路径上<code>Vi</code>的前一个顶点，假设最短路径上的顶点序列为<code>V0,V1,V2,V3,...,Vi-1,Vi</code> 则<code>path[Vi]=Vi-1</code>。</p>
<p><code>path[]</code>测初态为：假设<code>V0</code>为源点，如果<code>V0</code>到<code>Vi</code>有边，则<code>path[Vi]=V0</code>,否则<code>path[Vi]=-1</code>。<br>在上面的步骤中，每一次更新最短路径的值的时候，同时更新<code>path[]</code>的值，直到所有的顶点的最短路径更新完毕，<code>path[]</code>中也就保存了每个最短路径所经历的顶点，这是一个<code>树形结构</code>。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>在上面的代码上做一些修改,增加了<code>path[]</code>数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 图的存储在 MGraph  g.n为顶点数量 g.edges[][]为边的权值</span><br><span class="line">// v为源点</span><br><span class="line">// dist[] 保存源点到各个顶点的当前最短路径</span><br><span class="line">// path[] 保存从源点到`Vi`的最短路径上`Vi`的前一个顶点</span><br><span class="line">void Dijkstra(MGraph g, int v, int dist[], int path[]) &#123;</span><br><span class="line">    int set[maxSize];</span><br><span class="line">    int min,i,j,u;</span><br><span class="line">    // 初始化</span><br><span class="line">    for(i = 0;i&lt;g.n;i++) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];</span><br><span class="line">        set[i] = 0;</span><br><span class="line">        // path[] 初始化</span><br><span class="line">        if (g.edges[v][i] &lt; INF) &#123;</span><br><span class="line">        	path[i] = v;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	path[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set[v] = 1;</span><br><span class="line">    path[v] = -1;</span><br><span class="line">    </span><br><span class="line">    for(i = 0;i &lt; g.n; i++ ) &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        // 这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的</span><br><span class="line">        for (j = 0;j&lt; g.n;j++) &#123;</span><br><span class="line">            if(set[h] == 0 &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set[u] = 1;</span><br><span class="line">        // 以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测</span><br><span class="line">        for (j = 0;j &lt; g.n;j++) &#123;</span><br><span class="line">            if (set[j]==0&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[u]+g.edges[u][j];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;假设一个开车的人希望找出从新疆到北京的可能的最短路线。他有一张中国公路地图，该公路图上标出了每一对相邻的公路交叉之间的距离，他应该如何找出这
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向之动态调试</title>
    <link href="http://yoursite.com/2018/06/06/iOS-hacking-lldb/"/>
    <id>http://yoursite.com/2018/06/06/iOS-hacking-lldb/</id>
    <published>2018-06-06T04:02:04.000Z</published>
    <updated>2018-06-06T07:45:42.282Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。</p>
<h2 id="Xcode的动态调试原理"><a href="#Xcode的动态调试原理" class="headerlink" title="Xcode的动态调试原理"></a>Xcode的动态调试原理</h2><p>首先了解一下 <code>Xcode</code> 编译和调试器的发展。<code>Xcode</code> 中的编译器发展历程：<code>GCC</code> -&gt; <code>LLVM</code>,调试器的发展历程：<code>GDB</code> -&gt; <code>LLDB</code> 。</p>
<p><code>Xcode</code> 调试安装到手机上的应用的原理：<code>Xcode</code> 通过 <code>LLDB</code> 调试器把调试指令发送到手机上的 <code>debugserver</code>, <code>debugserver</code> 再与相应的 <code>APP</code> 进行交互，达到调试的效果。</p>
<p><code>debugserver</code> 一开始是存放在Mac的Xcode里面,路径： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms</span><br><span class="line">/iPhoneOS.platform/DeviceSupport</span><br><span class="line">/<span class="number">9.1</span>/DeveloperDiskImage.dmg</span><br><span class="line">/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
<p>当 <code>Xcode</code> 识别到手机设备时，<code>Xcode</code> 会自动将 <code>debugserver</code> 安装到手机上。</p>
<p><code>Xcode</code> 调试的局限性：一般情况下，只能调试通过 <code>Xcode</code> 安装的APP，无法调试其它APP。</p>
<h3 id="给debugserver赋予权限"><a href="#给debugserver赋予权限" class="headerlink" title="给debugserver赋予权限"></a>给debugserver赋予权限</h3><p>默认情况下 <code>/Developer/usr/bin/debugserver</code> 缺少一定的权限，只能调试通过Xcode安装的App，如果希望调试其它App，需要对 <code>debugserver</code> 重新签名，签上可以调试其它App的权限。</p>
<p>需要的两个权限为：<code>get-task-allow</code> 和 <code>task_for_pid-allow</code></p>
<p>iPhone上的 <code>/Developer</code> 目录是只读的，无法直接对 <code>/Developer/usr/bin/debugserver</code> 文件签名，需要先把 <code>debugserver</code> 复制到Mac。</p>
<p>通过 <code>ldid</code> 命令导出文件以前的签名权限:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -e debugserver &gt; debugserver.entitlements</span><br></pre></td></tr></table></figure>
<p><code>debugserver.entitlements</code> 这个文件其实是个 <code>plist</code> 文件，在这个文件中加上上面提到的两个权限后，再通过 <code>ldid</code> 命令对文件重新签名。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldid -Sdebugserver.entitlements debugserver</span><br></pre></td></tr></table></figure>
<p>然后将已经签好权限的 <code>debugserver</code> 放到 <code>/usr/bin</code> 目录，便于找到 <code>debugserver</code> 指令。</p>
<h3 id="debugserver附加到某个APP进程"><a href="#debugserver附加到某个APP进程" class="headerlink" title="debugserver附加到某个APP进程"></a>debugserver附加到某个APP进程</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ debugserver *:端口号 -a 进程</span><br></pre></td></tr></table></figure>
<ul>
<li>*:端口号：使用iPhone的某个端口启动debugserver服务（不是保留端口）</li>
<li>-a进程：输入APP的进程信息（进程ID或者进程名称）</li>
</ul>
<h3 id="Mac远程连接iPhone上的debugserver服务"><a href="#Mac远程连接iPhone上的debugserver服务" class="headerlink" title="Mac远程连接iPhone上的debugserver服务"></a>Mac远程连接iPhone上的debugserver服务</h3><p>启动LLDB：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端输入</span></span><br><span class="line">$ lldb</span><br></pre></td></tr></table></figure>
<p>连接debugserver服务</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process connect connect:<span class="comment">//手机IP地址:debugserver服务端口号</span></span><br></pre></td></tr></table></figure>
<p>使用LLDB的c命令让程序先继续运行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
<p>到此，就可以远程调试别人的App了。</p>
<h3 id="常用的LLDB指令"><a href="#常用的LLDB指令" class="headerlink" title="常用的LLDB指令"></a>常用的LLDB指令</h3><ul>
<li>给ViewController的test方法设置断点</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -n <span class="string">"-[ViewController test]"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看指令用户使用 <code>help</code> 指令： <code>help breakpoint</code> 等。</li>
<li>打印线程的堆栈信息： <code>thread backtrace</code></li>
</ul>
<p>很多命令不在这里赘述，请参考：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">http://lldb.llvm.org/lldb-gdb.html</a></p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>获取 <code>ASLR</code> 的偏移量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure>
<p>打印结果的第二列前面的地址就是我们需要的 <code>ASLR</code> 的偏移量offset。</p>
<p>假如我们想给某个类中的test方法添加断点，那么通过 <code>Hooper</code> 工具找到该方法的第一个内存地址,假如为0x010101，然后地址加上我们得到的 <code>ASLR</code> 的偏移量就是该方法的实际地址。然后通过该地址给方法下断点。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -o <span class="number">0x010101</span>+offset</span><br></pre></td></tr></table></figure>
<p>到此就给该方法添加了断点，之后当程序调用该方法的时候，会停在该断点出。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>练习 <code>lldb</code> 的各种指令时，推荐先在 <code>Xcode</code> 上练习各种用法，因为会有提示和直观的输出结果，更容易我们理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候想更了解别人App的调用流程，就需要在App运行的时候进行动态调试。动态调试指的是将程序运行起来，通过下断点、打印等方式，查看参数、返回值、函数调用流程等。&lt;/p&gt;
&lt;h2 id=&quot;Xcode的动态调试原理&quot;&gt;&lt;a href=&quot;#Xcode的动态调试原理&quot; class
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向之logify跟踪方法调用</title>
    <link href="http://yoursite.com/2018/06/05/iOS-logify/"/>
    <id>http://yoursite.com/2018/06/05/iOS-logify/</id>
    <published>2018-06-05T04:02:04.000Z</published>
    <updated>2018-06-08T03:04:38.653Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章的介绍，我们将App的头文件使用 <code>class-dump</code> 导出后，然后利用 <code>theos</code> 创建逆向的工程，编写 <code>hook</code> 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪个方法我们不好定位，这时候就用到了 <code>logify</code> 来跟踪函数调用，从而定位到我们需要的函数。</p>
<p><code>logify</code> 是 <code>theos</code> 的一个组件，<code>logify</code> 可以将一个头文件快速转换成已经包含打印信息的xm文件。当然如果某个类中的方法很少，你完全可以自己手动添加 <code>NSLog</code> 的打印信息，但是某个文件中的方法很多的时候，收到给每个方法添加日志信息，会浪费很多很多时间，<code>logify</code> 便是一个不错的工具。</p>
<p>我们以微信的聊天界面为例，假如在当前界面我收到红包消息的时候，我想确定是响应了哪个方法，方便分析抢红包的后续操作。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>我们利用 <code>Reveal</code> 确定出了群聊界面的控制器名称为 <code>BaseMsgContentViewController</code> 并且利用 <code>class-dump</code> 将头文件导出，这个类中的方法特别多，接下来我们利用 <code>logify</code> 把该文件快速转换成已经包含打印信息的xm文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出已添加日志信息的xm文件</span></span><br><span class="line">logify.pl BaseMsgContentViewController.h &gt; Tweak.xm</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>theos</code>工程，用我们刚才生成的 <code>Tweak</code> 替换刚才创建的 <code>theos</code> 项目的<code>Tweak.xm</code>。然后重新编译打包安装。</p>
<h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p><code>logify.pl</code> 生产的xm文件，有很多时候是编译不通过的，需要进行一些处理。</p>
<ul>
<li>删除 <code>__weak</code></li>
<li>删除 <code>inout</code></li>
<li>删除协议 ,或者在头部声明一下协议，<code>@protocol XXXDelegate</code></li>
<li>删除 <code>HBLogDebug(@&quot; = 0x%x&quot;, (unsigned int)r)</code></li>
<li>替换类名为 <code>void *</code> ，比如将 <code>XXPerson *</code> 替换为 <code>void *</code> 因为都是指针类型。或者在头部声明一下，<code>@class XXPerson</code></li>
</ul>
<p>根据自己编译的时候报的具体错误，进行适当的修改即可。</p>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><code>theos</code> 工程重新打包安装成功后，重新打开微信的聊天界面，然后打开 <code>Xcode -&gt; Window -&gt; Devices and Simulators</code> 即可跟踪方法的调用。</p>
<p><code>Xcode9.0</code> 之后该方法已经不方便查看了，使用 <code>syslog</code> 来实时查看日志。</p>
<p>在手机上安装两个插件：</p>
<ul>
<li>syslogd to/var/log/syslog : 记录log        </li>
<li>Core Utilities : 使用 <code>tail</code> 命令    </li>
</ul>
<p>在 <code>theos</code> 构建的逆向工程的 <code>Makefile</code> 文件中添加</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>比如查看微信的日志：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog | grep WeChat</span><br></pre></td></tr></table></figure>
<p>好了，接下来就可以根据实时查看微信的日志了，分析方法调用逻辑就一目了然了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据上一篇文章的介绍，我们将App的头文件使用 &lt;code&gt;class-dump&lt;/code&gt; 导出后，然后利用 &lt;code&gt;theos&lt;/code&gt; 创建逆向的工程，编写 &lt;code&gt;hook&lt;/code&gt; 的代码，从而达到修改某些功能的目的。但是有时候某些功能具体调用哪
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向解密</title>
    <link href="http://yoursite.com/2018/06/04/iOS-hacking/"/>
    <id>http://yoursite.com/2018/06/04/iOS-hacking/</id>
    <published>2018-06-04T04:02:04.000Z</published>
    <updated>2018-06-06T06:31:58.350Z</updated>
    
    <content type="html"><![CDATA[<p>学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。</p>
<h2 id="Mac远程登录iPhone"><a href="#Mac远程登录iPhone" class="headerlink" title="Mac远程登录iPhone"></a>Mac远程登录iPhone</h2><p>iOS和Mac OS X都是基于Darwin（苹果的一个基于Unix的开源系统内核），所以iOS中同样支持终端的命令行操作。    </p>
<p>在逆向工程中，我们经常会通过命令行来操纵iPhone。为了能够让Mac终端中的命令行能作用在iPhone上，我们得让Mac和iPhone建立连接。连接有两种方式：<code>wifi连接</code>和<code>usb连接</code>。</p>
<blockquote>
<p>先在越狱软件上安装ssh插件OpenSSH ,命令行下和应用交互的插件Cycript        </p>
<p>让越狱手机和mac电脑在同一个局域网下(为了能够通过ssh服务从mac电脑访问手机)</p>
<p>在mac的命令行终端 通过ssh服务登录手机 输入<code>ssh root@手机ip</code>。默认情况下的root密码是alpine。root密码可以自己修改。        </p>
<p>然后在手机上运行程序，在mac终端上利用ps -A 查看手机当前运行的进程，找到进程id后便可以利用cycript进行一些列操作。例如：进入当前运行着的微信进程的cycript状态<code>cycript -p WeChat</code></p>
</blockquote>
<p>采用<code>wifi连接</code>有时候会出现卡顿延迟的现象，所以我通常采用<code>usb连接</code>。</p>
<blockquote>
<p>Mac上有个服务程序usbmuxd（它会开机自动启动），可以将Mac的数据通过USB传输到iPhone        </p>
<p> 我使用了两个脚本进行登录：    </p>
<ul>
<li><p><code>python ~/iOS/tcprelay.py -t 22:10010</code>进行端口的映射</p>
</li>
<li><p><code>ssh -p 10010 root@localhost</code> usb的登录</p>
</li>
</ul>
</blockquote>
<h2 id="Cycript的使用"><a href="#Cycript的使用" class="headerlink" title="Cycript的使用"></a>Cycript的使用</h2><p>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物，可以用来探索、修改、调试正在运行的Mac\iOS APP。官网：<a href="http://www.cycript.org/" target="_blank" rel="external">http://www.cycript.org</a></p>
<p>比如一些简单的使用：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信进程</span></span><br><span class="line">cycript -p WeChat</span><br><span class="line"><span class="comment">// 获得沙盒路径</span></span><br><span class="line"><span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 打印当前页面view的层级</span></span><br><span class="line"><span class="built_in">UIApp</span>.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure>
<p>主要搭配<code>Reveal</code>使用，从<code>Reveal</code>中获得某个界面或者<code>view</code>所属的类或控制器，然后拿到该类或控制器利用cycript进行调试。比如，知道了一个<code>view</code>对应的类为<code>testView</code>,想把该<code>view</code>从当前界面移除，达到不显示的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[testView removeFromSuperview];</span><br></pre></td></tr></table></figure>
<h2 id="代码Hook分析"><a href="#代码Hook分析" class="headerlink" title="代码Hook分析"></a>代码Hook分析</h2><p>如果要逆向App的某个功能少不了代码的分析。</p>
<ol>
<li><p>通过上面的分析，找到某个<code>view</code>对应的类后，就需要导出该类对应的头文件进行具体的分析了。        </p>
</li>
<li><p>首先找到App的二进制文件（Mach-O类型），（使用iFunBox把该文件导出到Mac上）然后使用class-dump工具导出其中的所有头文件，这些头文件中可以看到其中的属性和方法。<code>class-dump  -H  Mach-O文件路径  -o  头文件存放目录</code></p>
</li>
<li><p>如果要查看<code>Mach-O</code>文件完整信息，建议用<code>MachOView</code>。<code>otool -l</code>打印所有的 <code>Load Commands</code>，建议搭配<code>grep</code>进行正则过滤。<code>otool -L</code> 可以查看使用的库文件。</p>
</li>
<li><p>头文件分析完毕后，就可以利用<code>theos</code>进行越越代码的开发了，编译生成Tweak插件(<code>deb</code>格式)。</p>
<blockquote>
<p>利用<code>nic.pl</code>指令，选择<code>iphone/tweak</code>，创建一个tweak工程。</p>
<p>在这个tweak工程中编辑<code>Tweak.xm</code>文件，编写自己的越狱代码。</p>
<p>开发完成后利用<code>make package</code>打包和<code>make install</code>安装到手机。重启应用，你会发现对应的功能已经根据hook的代码改变了。</p>
<p>原理：iOS在越狱后，会默认安装一个名叫<code>mobilesubstrate</code>的动态库，它的作用是提供一个系统级的入侵管道，所有的<code>tweak</code>都可以依赖它来进行开发。在目标程序启动时根据规则把指定目录的第三方的动态库加载进去，第三方的动态库也就是我们写的破解程序，从而达到修改内存中代码逻辑的目的。</p>
</blockquote>
</li>
<li><p>有时候想看某个类中的某个方法的实现以及调用逻辑，就需要用到<code>Hopper Disassembler</code>工具。</p>
</li>
</ol>
<h3 id="theos的常用语法"><a href="#theos的常用语法" class="headerlink" title="theos的常用语法"></a>theos的常用语法</h3><ul>
<li><p>%hook ,%end : hook一个类的开始和结束</p>
</li>
<li><p>%log：打印方法调用详情</p>
</li>
<li><p>HBDebugLog：跟NSLog类似</p>
</li>
<li><p>%new：添加一个新的方法的时候使用</p>
</li>
<li><p>%orig：函数原来的代码逻辑</p>
</li>
<li><p>%ctor：在加载动态库时调用</p>
</li>
<li><p>logify.pl：可以将一个头文件快速转换成已经包含打印信息的xm文件</p>
</li>
<li><p>如果有额外的资源文件（比如图片），放到项目的layout文件夹中，对应着手机的根路径/</p>
</li>
</ul>
<h2 id="砸壳-脱壳"><a href="#砸壳-脱壳" class="headerlink" title="砸壳(脱壳)"></a>砸壳(脱壳)</h2><p>如果使用越狱手机直接从<code>pp助手</code>下载下来的部分应用免去了我们自己脱壳的过程。但是如果是从App Store下载下来的应用，App Store已经为该应用进行了加密，再使用<code>class-dump</code>是无法导出头文件的，这是时候就需要对APP进行脱壳操作了。</p>
<p>脱壳工具有两种，<code>Clutch</code> 和 <code>dumpdecrypted</code></p>
<p><code>Clutch</code> :     </p>
<blockquote>
<p>在Mac终端登陆到iPhone后，利用Clutch脱壳</p>
<p><code>Clutch -i</code>    列举手机中已安装的应用中加密的应用。</p>
<p><code>Clutch -d  应用bundleid</code> 对加密的应用脱壳，脱壳成功后会生产新的<code>Match-O</code>文件。对这个新的文件进行<code>class-dump</code>操作即可。</p>
</blockquote>
<p>有时候使用<code>Clutch</code>脱壳，会出现失败的情况，比如脱壳微信的时候就会出现错误。这个时候就需要使用<code>dumpdecrypted</code>：    </p>
<blockquote>
<p>终端进入<code>dumpdecrypted.dylib</code>所在的目录 <code>var/root</code></p>
<p>使用环境变量 <code>DYLD_INSERT_LIBRARIES</code> 将 <code>dylib</code> 注入到需要脱壳的可执行文件（可执行文件路径可以通过<code>ps -A</code>查看获取）</p>
<p>执行命令 <code>DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 可执行文件路径</code> 即可完成脱壳操作。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解以上逆向的流程后，你可以实现一些有趣的功能，比如:视频客户端去广告，修改微信运动步数，防止微信消息测回，微信自动抢红包等功能。同时，也会在自己客户端的开发过程中更注重信息的安全保护。研究逆向，一定要善于利用各种工具，并且做好不断失败的准备，愈挫愈勇，终会成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习和了解逆向工程，可以帮助我们分析竞品和自己喜欢的APP的开发架构和某些功能的大体实现思路，也可以自己手动对其它APP大刀阔斧进行二次加工，满足自己的需求。 学习iOS逆向一段时间了，这里简单做个总结，揭开iOS逆向的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;Mac远程登录iP
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>半梦半醒之间</title>
    <link href="http://yoursite.com/2017/07/15/life-alone/"/>
    <id>http://yoursite.com/2017/07/15/life-alone/</id>
    <published>2017-07-15T13:48:10.000Z</published>
    <updated>2017-07-15T14:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>我大清早起，<br>站在人家屋角上哑哑的啼，<br>人家讨厌我，<br>说我不吉利，<br>我不能呢呢喃喃的讨人家欢喜。        </p>
<pre><code>----胡适《乌鸦》
</code></pre><p>昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦鸣，再也无法入眠。        </p>
<p>微风拂来，撩动水波流淌，夜色安谧，远远的，这条无人问津充斥着人们欢娱后残余下的瓶瓶罐罐被迫散发着恶息的溪流，却在这座城市中勾勒出最为灿烂的一副景画，灯火延绵、十里金粉，周围楼宇檐牙鳞次栉比地伸展绵延开去，使得这一方水土宛若盘踞于地面的金龙，孕育出这座城市繁华的景象，也倒映着一个夜行人的孤寂与萧条。我捡起一块沾满泥土的石块，投向了水中落寞的身影，摇曳的月光仿佛在嘲笑一个无家可归的人，我笑着摇了摇头，拍了拍手上的尘土，愈行愈远。        </p>
<p>一念花开，一念花落，这山长水远的人世，终究是要自己走下去。            </p>
<p>世上最痛苦的事，不是生老病死，而是生命的旅程虽短，却充斥着永恒的孤寂；世上最痛苦的事，不是永恒的孤寂，而是明明看见温暖与生机，我却无能为力；世上最痛苦的事，不是我无能为力，而是当一切都触手可及，我却不愿伸出手去。后来我才知道，原来这便是生活。        </p>
<p>《这个杀手不太冷》里，马蒂尔德问里昂：生活是否永远艰辛，还是只有童年如此。里昂说：永远如此。所以我们才拼了命的读书学习，也不过是为了把自己变成更好的人，以便遇到更好的人，避开这种庸俗。        </p>
<p>罗曼·罗兰说：这世界上只有一种真正的英雄主义，就是在看清生活的真相之后，依然热爱生活。        </p>
<p>这便是真英雄吧！        </p>
<p>我想起了网上的一个场景，久久不能忘怀。那应该是一个风和日丽的午后，暖暖的阳光掠过湖水，带起一阵美丽的涟漪。我歪歪斜斜的靠在斑驳、苍老的石灰墙上，目光慵懒而且游移不定，我看见一只狗眯着眼睛淌着涎水安详的打着盹，一只花白母鸡和一只脊背上一撮毛剥掉了的大红公鸡在无聊的刨土。一辆破旧的板车，它的两只胳膊已经断了，它的下半身由于长期处于积水塘里而生出了苔藓。这时候，一阵稍微大一点的风夹杂着竹叶与竹叶摩擦的声音拂面而来，那一瞬间，我幼小的心灵就产生了怅然若失的感觉，一种莫名的、强大的、浓重的忧伤像冬天的大雾一样裹住了我。我像是被整个世界离弃了一般，全世界的人都离我而去了，只剩下我一个人独自咀嚼着孤独的滋味。人呢？人都哪里去了？我的目光再一次停留在那破旧的板车上，想象着自己总有一天会像那辆板车一样落魄、潦倒，心里就愈发沉重起来，我竟然不知不觉为那辆板车也为自己洒下了一行童年时忧伤的泪水。        </p>
<p>我抬头望向天空，原来天真的是空的！这一刻，深深的为自己的渺小与无能而感到不知所措。        </p>
<p>我抚摸着这半截老墙，不禁感叹：你刚建造的时候人们反对你，阻碍了人与人之间的距离，当人们习惯的时候又开始依赖你，把你建的又宽又高，直到最后人们渐渐的忽略了你的存在，就这样我们每个人都被你封闭在了自己的围墙里，慢慢地、一丝丝、一缕缕渗透到我们的一寸寸肌肤里，原来面对面的两个人，中间却有两座厚重的壁垒，横亘在彼此之间。我们都小心翼翼的蜷缩在自己构建的城堡里，偷窥着外面的世界，形单影只，不外如是。        </p>
<p>这一路，半梦半醒间，走走停停，却又无比的惬意和轻松。或许这就是张爱玲说的：我们都是寂寞惯了的人。        </p>
<p>于是执笔研墨，写下了这一纸寂寞。            </p>
<hr>
<p>这是一篇无病呻吟的文章，纯属是一次风格的练习尝试。大家还是应该看些正能量的文章，比如我之前写的：<a href="http://coderperson.com/2015/05/26/byeyouth/" target="_blank" rel="external">《再见-百度空间》</a>。        </p>
<p>晚安！        </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我大清早起，&lt;br&gt;站在人家屋角上哑哑的啼，&lt;br&gt;人家讨厌我，&lt;br&gt;说我不吉利，&lt;br&gt;我不能呢呢喃喃的讨人家欢喜。        &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;----胡适《乌鸦》
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;昨夜电闪雷鸣，又是一方风雨。半梦半醒间，听到了一声鸦
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结</title>
    <link href="http://yoursite.com/2017/01/02/life-2016summary/"/>
    <id>http://yoursite.com/2017/01/02/life-2016summary/</id>
    <published>2017-01-02T09:59:10.000Z</published>
    <updated>2017-01-02T10:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。</p>
<p>回首2016年，这一年是自己心态改变最大的一年，做事和考虑问题的方式和以前有了很大的不同。</p>
<p>这一年，由于工作原因和几个好朋友分开住了，所幸离得不是很远，每个星期都能聚聚，一起谈谈理想，扯扯人生，很幸运有这帮志同道合的朋友。</p>
<p>关于运动，今年坚持的还不错，从年初开始直到进入冬天，每周末至少会去奥森跑10公里或者去干部学院打一下午篮球。今年夏天还办了一张游泳卡，学会了游泳，游完泳后再去打篮球，也是累的不行。可惜进入冬天后，运动的次数明显是减少了，身体状态也不如以前了，引以为鉴。</p>
<p>今年冬天我更换了工作，这件事情对我的触动很大。我在这个项目上付出了很多，但是由于种种原因提出了离职，所幸的是后来我加入了一个很棒的团队，同时也在做一款伟大的产品。于是不爱加班的我开启了疯狂加班模式，理由很简单，我很看好这款产品。用老大的一句话就是：为了世界和平。</p>
<p>关于生活，仍然是一人吃饱全家不饿的状态。一个人过的很随便，直到周边朋友开始买车买房了，才给自己敲响了警钟，2017年该攒首付钱了。</p>
<p>关于读书，这块很惭愧，今年读的书比较少，2017年一定要多读书。日记也有半年没有写了，2017一定要坚持下来。</p>
<p>关于爱情，这块没有，略~~        </p>
<p>2016留下了很多遗憾，做错了很多事，总归是不断成长的。</p>
<p>展望2017，只有一个目标：努力提高自己！</p>
<p>再见，2016！<br>你好，2017！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在撸代码的时候，点了一下时间上的日历，日期已经变成2017年了，心弦莫名的被触动，那个意犹未尽的2016就这样再也回不来了。也许再过一段时间，你就忘了曾经的那个2016年自己走过的街道、流过汗水、做过的事情、遇见的人，想抓却又抓不住。&lt;/p&gt;
&lt;p&gt;回首2016年，这一
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://yoursite.com/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>访问坏内存Bug定位解决</title>
    <link href="http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/"/>
    <id>http://yoursite.com/2016/10/24/bugs-EXC_BREAKPOINT/</id>
    <published>2016-10-24T06:39:05.000Z</published>
    <updated>2016-10-24T06:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。</p>
<p>当对项目中的某一模块进行操作的时候遇到的错误是<code>EXC_BREAKPOINT (code=1, subcode=…)</code>而且没有任何错误log的打印。添加了<code>全局断点</code>还是没有定位到出错代码的位置，这时候就需要对xcode进行一些设置了。        </p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/EXC_BRECKPOINT.png" alt="EXC_BRECKPOINT.png"></p>
<p>xcode开启<code>僵尸模式</code>,如果遇到<code>The target process has no stack logs. Run it with the MallocStackLogging env</code>这种问题那么可以设置下<code>MallocStackLoggingNoCompact</code>为YES。</p>
<p><img src="http://oet7ffdgt.bkt.clouddn.com/malloc1.jpg" alt="zombie"></p>
<p>这个时候再对出问题的模块进行操作，会打印出<code>[testViewController retain]message sent to deallocated instance</code>的错误提示，这要就定位到了出问题的大体位置了,并且也知道了是坏内存访问的问题。</p>
<p>但是这个控制器中的代码有上千行，这个时候如何定位呢，既然是内存问题，这里就用到了内存调试工具<code>Zombies</code>了。<br>打开该工具，运行项目，当出现<code>message sent to deallocated instance</code>时候，工具会提示<code>An Objective-C message was sent to a deallocated object(zombie) at address:0x8b3b200</code>，点击提示，工具会提示可能存在内存问题的地方，然后自己看一下定位的具体代码，就能发现出现问题的地方了。    </p>
<p><img src="http://i.stack.imgur.com/qbfcb.png" alt=""></p>
<p><img src="http://i.stack.imgur.com/wpolZ.png" alt="">        </p>
<p>到这里你就应该定位到出问题代码的位置了，合理的利用调试工具，用助于我们高效率的开发。</p>
<blockquote>
<p>今天是1024，程序员的节日，祝大家节日快乐。</p>
</blockquote>
<p>参考资料在<a href="http://stackoverflow.com/questions/11170614/viewcontroller-respondstoselector-message-sent-to-deallocated-instance-crash" target="_blank" rel="external">这里</a>，欢迎大家转载，请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你刚接手一个项目的时候（对代码的内部结构还不清楚），如果出现一些莫名其妙的内存问题，而且也没有错误的log日志，这种问题有时候是比较难定位的，根本就不知道代码哪里出现了问题，今天刚好遇到了一个这样的问题，顺便总结一下。&lt;/p&gt;
&lt;p&gt;当对项目中的某一模块进行操作的时候遇到
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发实战</title>
    <link href="http://yoursite.com/2016/10/10/wx-progects/"/>
    <id>http://yoursite.com/2016/10/10/wx-progects/</id>
    <published>2016-10-10T03:10:55.000Z</published>
    <updated>2016-10-11T02:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信小程序做了几个小项目，感觉和以前学的ReactNavative开发有很多相似之处。</p>
<ul>
<li>骚客计算器</li>
</ul>
<p>用微信小程序搭建的简易计算器，一些计算逻辑可能还有一些问题，不过这不是重点，主要是通过这个项目练练手。里面涉及到的一些知识点：数据绑定、页面渲染、逻辑结构、事件响应、页面跳转等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-calculator.jpg" width="25%" height="25%"><br><br></center>



<ul>
<li>骚客天气</li>
</ul>
<p>用微信小程序搭建的简易天气界面，可以看到当天和未来三天的天气情况。里面涉及到的一些知识点：位置接口、网络通信、百度地图API、天气API、方法封装调用，Flex布局、模板处理、引用、列表渲染等。        </p>
<center><br><br><img src="http://oet7ffdgt.bkt.clouddn.com/wx-weather.jpg" width="25%" height="25%"><br><br></center>        


<p>后续还会写一些简单的小应用。        </p>
<p>这些项目统一放在github上：<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">戳这里</a>，以后用微信小程序写的一些应用我也会统一放到<a href="https://github.com/corderguo/WX_Projects" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆前夕，微信小程序开放了局部封测，各种自媒体疯狂的炒作，正真的热的不行。我甚至看到了一个公众号宣传要做小程序的培训，而且还只是一小时的课程，开口就两千大洋，当时我都想喷饭了，这是欺负那些没有编程经验的人的吧。趁着国庆有时间学习了一下微信小程序的API，参考一些资料，用微信
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="wx" scheme="http://yoursite.com/tags/wx/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天框架的搭建</title>
    <link href="http://yoursite.com/2016/09/28/iOS-weChat/"/>
    <id>http://yoursite.com/2016/09/28/iOS-weChat/</id>
    <published>2016-09-28T13:52:50.000Z</published>
    <updated>2019-01-21T07:45:55.847Z</updated>
    
    <content type="html"><![CDATA[<p><code>XZ_WeChat</code>高仿微信聊天框架的搭建，工程地址：<a href="https://github.com/corderguo/XZ_WeChat" target="_blank" rel="external">https://github.com/corderguo/XZ_WeChat</a>        </p>
<p>效果图展示：            </p>
<p><img src="https://img-blog.csdn.net/20160928230616321" alt="1"><br><img src="https://img-blog.csdn.net/20160928230519993" alt="2">        </p>
<p>做了两年IM相关工作了，去年是集成环信的SDK实现的IM功能，今年公司拥有自己的长连接服务器，于是从头自己定协议然后一步步实现了IM的整体功能，基本把微信IM有关的内容都实现了。最近开始整理过去的一些知识，于是先从聊天框架下手，整理出这个简易的聊天框架，方便大家学习交流。</p>
<p>该框架摘除了本地缓存的功能（这部分内容太多了），预留好缓存的方法，使得该框架尽可能的简洁实用，方便大家学习，我也会逐渐把该框架完善起来。    </p>
<p>由于作者的电脑环境被折腾坏了，不能安装cocoapods来管理一些用到的三方，所以直接导入进了该框架，这一点大家不要学习。</p>
<p>该框架目前支持的消息类型：文本消息（包含表情），图片消息，语音消息，视频消息，文件消息(pdf,word,excel,ppt,png,html等格式)。</p>
<p>如果你想展示文件消息，你需要把文件拷贝到沙盒的<code>/Library/Caches/Chat/File</code>目录下,由于我以前是从PC端发送文件到手机端进行的展示，所以目前只能你手动拷贝了。</p>
<p>项目中展示的视频已经转成了<code>mp4</code>类型，而且也经过了压缩，语音也转换成了<code>amr</code>格式，节省流量的同时，可以和安卓端兼容。</p>
<p>你能从该框架学习到什么：        </p>
<ul>
<li>聊天框架的搭建</li>
<li>表情键盘的实现</li>
<li>语音相关的知识</li>
<li>视频相关的知识</li>
<li>文件相关的功能</li>
<li>转场动画相关的知识</li>
<li>数据模型和尺寸模型分离</li>
<li>你能清楚的了解到在实战项目中IM的实现    </li>
</ul>
<p>目前该框架这是初步，我还有好多功能没有加入进去，后续会慢慢加入，包括：        </p>
<ul>
<li>消息的转发、拷贝、撤回</li>
<li>文章的分享</li>
<li>订阅号的功能</li>
<li>红包的功能</li>
<li>本地缓存的功能(其实很多功能都要基于数据库的，我把数据库去除掉后，很多功能就一块去除了)</li>
<li>草稿箱的功能</li>
<li>等等等还有好多好多</li>
</ul>
<hr>
<p><strong>更新日志</strong>：            </p>
<p>10月8日：添加了消息的拷贝、删除、撤回功能，由于转发功能需要用到数据库所以我只添加了转发的UI,等添加了数据库后再完善。<code>注意</code>这里的只有自己的消息并且是发送成功的消息才可以撤回，我这里限制的是<code>5分钟</code>内的消息可以撤回,超过规定时间不允许撤回。            </p>
<p>10月12日：添加了系统消息，当消息撤回的时候聊天界面上提示一条<code>你撤回了一条消息</code>的提示。当多人聊天的时候，如果一方撤回了一条消息，系统应该给你发送一条指令，根据这条指令你识别出是哪一条消息被撤回了，然后删除这条消息，并且插入一条<code>谁谁撤回了一条消息</code>。</p>
<p>10月12日：适配xcode8.0，解决bug，如果用xcode8.0的模拟器访问相册时崩溃，则换成真机即可，我也是在升级到xcode8.0后遇到的问题，问题如下：            </p>
<pre><code class="objc">objc[<span class="number">6777</span>]: Class PLBuildVersion is implemented 
<span class="keyword">in</span> both /Applications/Xcode.        
app/Contents/Developer/Platforms/iPhoneSimulator.            
platform/Developer/SDKs/iPhoneSimulator.            
sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.
framework/AssetsLibraryServices (<span class="number">0x1227c3910</span>) and        
/Applications/Xcode.app/Contents/Developer/Platforms
/iPhoneSimulator.platform/Developer/SDKs
/iPhoneSimulator.    
sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.
framework/PhotoLibraryServices (<span class="number">0x1225ed210</span>).                 
One of the two will be used. Which one is undefined.
</code></pre>
<p>奇怪的是我原项目中没有遇到该问题，而抽出来的这个聊天框架却遇到了问题，我猜想是我项目中使用了cocoapods来管理三方，而该聊天框架中我是直接导入的，稍后我会集成cocoapods，尝试问题的解决。大家若有解决方法可以给我留言，大家共同提高。</p>
<p>如果你在学习过程中有什么问题可以和我留言，大家共同提高。如果该框架能帮助到你，欢迎star，你的关注是我最大的动力，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;XZ_WeChat&lt;/code&gt;高仿微信聊天框架的搭建，工程地址：&lt;a href=&quot;https://github.com/corderguo/XZ_WeChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WeChat" scheme="http://yoursite.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>iOS之安全加密</title>
    <link href="http://yoursite.com/2016/09/02/iOS-security-encrypt/"/>
    <id>http://yoursite.com/2016/09/02/iOS-security-encrypt/</id>
    <published>2016-09-02T02:12:15.000Z</published>
    <updated>2016-09-20T08:42:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><hr>
<p>在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用<code>POST</code>请求提交用户的这些隐私数据。因为<code>GET</code>请求的所有参数都直接暴露在<code>URL</code>中。同时请求的<code>URL</code>一般会记录在服务器的访问日志中，服务器的访问日志是黑客攻击的重点对象之一。</p>
<p>仅仅用<code>POST</code>请求提交用户的隐私数据，还是不能完全解决数据安全的问题，我们可以利用软件（比如Charles）设置代理服务器，拦截查看手机的请求数据。因此：提交用户的隐私数据时，一定不要明文提交，要加密处理后再提交。</p>
<p>另外，我们也不应该在本地保存用户的隐私数据的<code>明文</code>。</p>
<h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><hr>
<p>常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES。</p>
<p>针对上述加密算法，我把目前流行的几种加密方式做下分类：</p>
<ul>
<li><p>哈希（散列）函数</p>
<ul>
<li>MD5（Message Digest Algorithm 5，译为“消息摘要算法第5版”）</li>
<li>SHA1</li>
<li>SHA256            </li>
</ul>
</li>
<li><p>对称加密算法</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES(高级密码标准，美国国家安全局使用的)</li>
</ul>
</li>
<li><p>非对称加密算法</p>
<ul>
<li>RSA</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点说一下散列函数的特点：    </p>
</blockquote>
<ul>
<li>算法是公开的;</li>
<li>对相同的数据加密，得到的结果是一样的;</li>
<li>对不同的数据加密，得到的结果是定长的。例如:MD5对不同的数据进行加密，得到的结果都是32个字符长度的字符串;</li>
<li>信息摘要，信息”指纹”，是用来做数据识别的！比如:搜索;</li>
<li>不能反算的,即是不可逆的。</li>
</ul>
<p>利用这些特点，我们在项目中的应用:    </p>
<p><code>加密密码</code>：服务器并不需要知道用户真实的密码！        </p>
<p><code>搜索</code>：比如你要搜索“张老师 杨老师 苍老师”和“苍老师 张老师 杨老师”，其实这两个要搜索的内容所表达的意思是一样的，但是我们应该如何判断呢。我们可以对搜索的每个关键字进行散列，得到三个相对应的结果，按位相加结果如果是一样的，那搜索的内容就是一样的！<br>张老师            1bdf605991920db11cbdf8508204c4eb<br>杨老师             2d97fbce49977313c2aae15ea77fec0f<br>苍老师             692e92669c0ca340eff4fdcef32896ee</p>
<p><code>版权</code>: 版权保护，文件识别。例如可以对文件内容进行MD5，然后可以根据该MD5串判断文件内容是否被修改过。我以前做IM的文件上传功能就是这样判断的，如果文件内容的MD5相同，表示该文件已经在服务器存在了，就不用再次上传了。</p>
<p>由于<code>MD5</code>加密算法具有较好的安全性，而且免费，因此该加密算法被广泛使用。不过遗憾的是该加密算法已经被暴力破解了,<a href="http://www.cmd5.com" target="_blank" rel="external">http://www.cmd5.com</a>该网站记录超过24万亿条，共占用160T硬盘 的密码数据，通过对海量数据的搜索得到的结果！    </p>
<p>不过我们可以通过提升MD5加密的安全性，加大被破解的难度。    </p>
<p><code>1</code>. 加“盐”（佐料）。<br><code>2</code>. HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符。</p>
<h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><hr>
<p>RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙：使用publicKey可以对数据进行加密，使用Key才能对数据进行解密。    </p>
<p>特点：单方向传输<br>用公钥加密的数据，只有私钥能解开（可用于加密）；<br>同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍）；</p>
<p>公钥与私钥：            </p>
<p>1.权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。<br>2.私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。<br>3.公钥好比安全性极高的挂号信箱地址，公开。        </p>
<p>举例：若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤：        </p>
<ol>
<li>甲用乙的公钥对合同加密。        </li>
<li>密文从甲发送到乙。        </li>
<li>乙收到密文，并用自己的私钥对其解密。        </li>
<li>解密正确，经阅读，乙用自己的私钥对合同进行签署。        </li>
<li>乙用甲的公钥对已经签署的合同进行加密。            </li>
<li>乙将密文发给甲。        </li>
<li>甲用自己的私钥将已签署合同解密。        </li>
<li>解密正确，确认签署。        </li>
</ol>
<p>从以上步骤，我们知道：            </p>
<ol>
<li>用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。        </li>
<li>如果某份密文被解开，那么肯定是密文的目标信息主体解开的。        </li>
<li>私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。        </li>
</ol>
<h3 id="Base64补充"><a href="#Base64补充" class="headerlink" title="Base64补充"></a>Base64补充</h3><hr>
<p>1.Base64简单说明：<br>描述：Base64可以成为密码学的基石，非常重要。<br>特点：可以将任意的二进制数据进行Base64编码<br>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。<br>65字符：A~Z a~z 0~9 + / =<br>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。        </p>
<p>2.命令行进行Base64编码和解码：<br>编码：base64 123.png -o 123.txt<br>解码：base64 123.txt -o test.png -D        </p>
<p>3.Base64编码原理：<br>1)将所有字符转化为<code>ASCII</code>码；<br>2)将ASCII码转化为<code>8</code>位二进制；<br>3)将二进制<code>3</code>个归成一组(不足<code>3</code>个在后边补<code>0</code>)共<code>24</code>位，再拆分成<code>4</code>组，每组<code>6</code>位；<br>4)统一在<code>6</code>位二进制前补两个<code>0</code>凑足<code>8</code>位；<br>5)将补<code>0</code>后的二进制转为十进制；<br>6)从Base64编码表获取十进制对应的Base64编码；    </p>
<p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个<code>24bit</code>的缓冲区中，先来的byte占高位。<br>    b.数据不足<code>3byte</code>的话，于缓冲区中剩下的bit用0补足。然后，每次取出<code>6</code>个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加<code>1</code>个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加<code>2</code>个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。        </p>
<p> 4.在项目中的应用：        </p>
<p>1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持<br>2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。</p>
<p>代码实现：    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64EncodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先把字符串转换为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对base64编码后的字符串进行解码</span></span><br><span class="line">    -(<span class="built_in">NSString</span> *)base64DecodeString:(<span class="built_in">NSString</span> *)string</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//2.把二进制数据转换为字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终端测试命令：            </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n A | base64			</span><br><span class="line">$ <span class="built_in">echo</span> -n QQ== |base64 -D</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据安全&quot;&gt;&lt;a href=&quot;#数据安全&quot; class=&quot;headerlink&quot; title=&quot;数据安全&quot;&gt;&lt;/a&gt;数据安全&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在项目中当我们提交用户的隐私数据时，比如:登陆密码、银行账号等，一定要使用&lt;code&gt;POST&lt;/code&gt;请求提
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>关于委托代理的优化</title>
    <link href="http://yoursite.com/2016/08/20/iOS-delegate_optimized/"/>
    <id>http://yoursite.com/2016/08/20/iOS-delegate_optimized/</id>
    <published>2016-08-20T02:02:04.000Z</published>
    <updated>2016-09-06T06:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><hr>
<p>对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对象间的的通信，该模式的主旨是：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以发生相关事件时通知委托对象。</p>
<p>通常delegate对象中的方法名也一定要起得恰当才行。方法名应该准确描述当前发生的事件以及delegate对象为何要获知此事件。在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样，delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。若没有此信息，则委托对象在同一时间只能执行一套逻辑，这么做不太好。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><hr>
<p>在实现委托模式时，如果协议中的方法是可选得，那么就会写出一大批类似下面的代码来：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_delegate respondsToSelector:@selector(someClassDidSomething:)])</span><br><span class="line">&#123;</span><br><span class="line">	[_delegate someClassDidSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易用代码查出某个委托对象是否能响应特定的选择子，可是如果频繁执行此操作的话，那么除了第一次检测的结果有用之外，后续的检测可能都是多余的。如果委托对象本身没变，那么不太可能会突然响应某个原来不能响应的选择子，也不太会突然无法响应某个原来可以响应的选择子。鉴于此，我们可以把委托对象能否响应某个协议方法这一信息缓存起来，以优化程序效率。</p>
<p>将方法响应能力缓存起来的最佳途径是使用“位段”数据类型，我们可以把结构体中的字段占用的二进制位个数设为一个字节，从而用0和1表示方法是否被响应。</p>
<p>下面举个例子：</p>
<p>在“class-continuation分类”中新增实例变量，这个新增的实例变量是个结构体，用来缓存方法的响应与否。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	unsigned int didReceiveData     : 1;</span><br><span class="line">	unsigned int didFailWithError   : 1;</span><br><span class="line">&#125; _delegateFlags;</span><br></pre></td></tr></table></figure>
<p>这个结构体用来缓存委托对象是否能响应特定的选择子。实现缓存功能所用的代码可以写在delegate属性所对应的设置方法里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)<span class="built_in">set</span>Delegate:(id&lt;GXZNetWorkFetcher&gt;)delegate &#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData   = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</span><br><span class="line">	_delegateFlags.didFailWithError = </span><br><span class="line">		[delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，每次调用delegate的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标志：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(_delegateFlags.didReceiveData) &#123;</span><br><span class="line">	[_dlegate networkFetcher:self didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相关方法要调用很多次时，值得进行这种优化。而是否需要优化，则应依照具体代码来定。这就需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。如果频繁的通过数据源协议从数据源中获取多份相互独立的数据，那么这项优化技术极有可能就会提高程序效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;委托模式&quot;&gt;&lt;a href=&quot;#委托模式&quot; class=&quot;headerlink&quot; title=&quot;委托模式&quot;&gt;&lt;/a&gt;委托模式&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;对象之间经常相互通信，而通信方式有很多。Object-C开发者广泛使用的一种名叫“委托模式”的编程设计模式来实现对
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS使用AVAudioPlayer遇到的奇葩问题</title>
    <link href="http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/"/>
    <id>http://yoursite.com/2016/08/10/bugs-AvAudioPlayer/</id>
    <published>2016-08-10T13:16:15.000Z</published>
    <updated>2016-08-18T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工<br>具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    </p>
</blockquote>
<p>我开始播放音频的播放代码如下：    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br><span class="line">    self.player.numberOfLoops = 0;</span><br><span class="line">    [self.player prepareToPlay];</span><br><span class="line">    self.player.delegate = self;</span><br><span class="line">    [self.player play];</span><br></pre></td></tr></table></figure>
<p>结果开始播放语音的时候，程序始终停在初始化这句：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:recorderPath] error:nil];</span><br></pre></td></tr></table></figure>
<p>在这里你可以手动在Xcode上使程序强制运行过去，这样程序可以正常运行了，没有任何影响，这就奇了怪了。于是我在<font color="green">stackoverflow</font>上找到了一个解决方案:<br><img src="http://upload-images.jianshu.io/upload_images/1389022-a81ead68cba8f0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片">    </p>
<p>原来是我在XCode中设置了全局断点，导致audio无法播放，（但是我这里就有疑问了，同一个工具类为什么我播放IM中录音时没有问题，到这里就有问题了呢？）于是我把全局断点去掉后，程序果断正常运行了。        </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>以后遇到异常终止的情况（<strong>注意</strong>不是出错，可以手动使程序继续正常运行），可以尝试移除全局断点的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做IM中文件发送的功能，其中涉及到了发送音频格式的文件，于是我使用了我之前封装的播放音频的工具类，这个工&lt;br&gt;具类是用来播放IM的语音的，但是我在播放文件中的语言时却遇到了一个奇葩问题。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bugs" scheme="http://yoursite.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>沉痛悼念CSDN博主、年仅26岁的音视频专家雷霄骅</title>
    <link href="http://yoursite.com/2016/08/04/meidia-person/"/>
    <id>http://yoursite.com/2016/08/04/meidia-person/</id>
    <published>2016-08-04T04:30:07.000Z</published>
    <updated>2016-08-04T05:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160804134857626" alt=""></p>
<p>CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7月17日凌晨猝死在学校主楼五层，并于7月23号安葬。据相关报道称，事发前雷霄骅一直泡在实验室忙碌，怀疑其是劳累过度导致猝死。        </p>
<p>CSDN失去了一位亲密的友人，我们失去了一位深受网友爱戴的“雷大神”博主。最初当大家看到这则新闻时，除了不敢相信一再确认外，剩下的只有心痛。众多网友也自发地在多个平台表达了自己的悼念之情。<br><img src="http://img.blog.csdn.net/20160804085950156" alt=""></p>
<p>逝者的博客地址：<a href="http://blog.csdn.net/leixiaohua1020" target="_blank" rel="external">http://blog.csdn.net/leixiaohua1020</a>,我很久以前就关注了雷神的博客，雷神的文章让我学到了很多东西。        </p>
<p>霄骅的博客为很多人所知，在他的博客上，有这样一段自我介绍「主要从事与广播电视有关的视音频技术的研究。包括视音频质量评价，视音频编解码，流媒体，媒资检索等。」截止笔者发稿，这一刻CSDN上霄骅的博客数据为：    </p>
<ul>
<li>访问：4354295次</li>
<li>积分：43750</li>
<li>等级：8</li>
<li><p>排名：第52名</p>
</li>
<li><p>原创：375篇</p>
</li>
<li><p>转载：159篇</p>
</li>
<li>译文：28篇</li>
<li>评论：4985条    </li>
</ul>
<p>从此，这些数据将会灰色定格！<br>我们感谢霄骅做出的巨大贡献！而认识雷霄骅，还可以从他的相关专栏和开源项目中做更深入了解：<br>专栏:        </p>
<blockquote>
<p>FFmpeg（135篇）    </p>
<ul>
<li>开源多媒体项目源代码分析（91篇）        </li>
<li>视频质量评价（41篇）</li>
</ul>
</blockquote>
<p>开源项目列表 :            </p>
<blockquote>
<ul>
<li>[SourceForge]：<a href="https://sourceforge.net/u/leixiaohua1020/wiki/" target="_blank" rel="external">https://sourceforge.net/u/leixiaohua1020/wiki/</a><br>[Github]：<a href="http://leixiaohua1020.github.io/" target="_blank" rel="external">http://leixiaohua1020.github.io/</a></li>
<li>TIandSI：本工具用于计算视频的时间信息（TI，也称为时间复杂度），以及空间信息（SI，也称为空间复杂度），以上两个指标取自于ITU-R BT.1788标准。</li>
<li>VideoEye：一个开源的视频分析的软件。本软件可以播放和分析视频数据。它支持多种视频流输入方式：HTTP，RTMP，RTSP以及文件等等。该软件可以实时分析视频流并能以图形化的方式呈现其分析结果。目前该软件还处于完善阶段。</li>
</ul>
</blockquote>
<p>CSDN博客运营人员回忆：“一直以来，与霄骅的接触都在QQ上，第一次见面，是在CSDN老友记的活动上。在我的印象中，他是低调、内敛的男孩，他的笑容很真实，也能打动人，很真诚、乐于帮助别人的一位博客专家。”而霄骅也写了篇小短文做记录，表示不虚此行。        </p>
<p>霄骅在14年5月31日正式成为博客专家，他擅长的技术当时在CSDN上内容还不算很多，所以系列更新一下子吸引了很多人来浏览和讨论。他的博客帮助了很多人，除了在博客上回复大家的问题，以及还有自己的技术交流群，旨在为视音频技术同行方便交流提供一个平台。无论是实验室、电视台、互联网视频、安防、播放器、媒体中心等都可以加入讨论。他认为多交流可以更快的进步~        </p>
<p>乐于分享技术的他，在视音频技术做出了巨大贡献的他，当之无愧地连续两年获得CSDN年度博客之星称号。        </p>
<p>就在今年上半年，CSDN曾邀请霄骅成为其签约作者，当时霄骅提到最近要忙着写毕业设计，工作人员一直在等他忙完这阵子。结果，这个噩耗无情地到来。        </p>
<p>斯人已去，对于霄骅博文出书以及家人号召成立基金会事宜，CSDN表示都会全力支持协助。我们在沉痛悼念霄骅的同时，也呼吁所有技术开发者们，一定要照顾好自己的身体，远离病痛折磨！    </p>
<p>希望天堂里霄骅一切安好！    </p>
<p>希望从事IT行业的人员都要注重身体的健康！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160804134857626&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSDN的老朋友、连续两届CSDN博客之星、微软MVP、博客排名52位、在中国传媒大学通信与信息系统专业攻读博士的雷霄骅，于2016年7
    
    </summary>
    
      <category term="资讯" scheme="http://yoursite.com/categories/%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="media" scheme="http://yoursite.com/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发各种权限问题(相机、录音等)</title>
    <link href="http://yoursite.com/2016/08/02/iOS-authorization/"/>
    <id>http://yoursite.com/2016/08/02/iOS-authorization/</id>
    <published>2016-08-02T09:13:02.000Z</published>
    <updated>2016-08-02T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，直接去调用了，这样会出现问题。        </p>
<h3 id="麦克风权限"><a href="#麦克风权限" class="headerlink" title="麦克风权限"></a>麦克风权限</h3><hr>
<p>我在项目中开发IM的录音功能的时候，没有判断当前APP是否拥有响应的权限，导致录制失败（录制出来是0kb，长度也是0毫秒）。为此我在工具类中，添加了麦克风权限的判断方法，当用户去录音的时候，如果检测到没有响应的麦克风权限，则提示用户到手机的设置页面打开麦克风的权限，当用权限的时候直接录制就可以了。   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecord</span><br><span class="line">&#123;</span><br><span class="line">    __block BOOL bCanRecord = YES;</span><br><span class="line">    <span class="keyword">if</span> ([[[UIDevice currentDevice] systemVersion] compare:@<span class="string">"7.0"</span>] != NSOrderedAscending)</span><br><span class="line">    &#123;</span><br><span class="line">        AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">        <span class="keyword">if</span> ([audioSession respondsToSelector:@selector(requestRecordPermission:)]) &#123;</span><br><span class="line">            [audioSession performSelector:@selector(requestRecordPermission:) withObject:^(BOOL granted) &#123;</span><br><span class="line">                bCanRecord = granted;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> bCanRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相机权限"><a href="#相机权限" class="headerlink" title="相机权限"></a>相机权限</h3><hr>
<p>同样在开发IM的小视屏(和微信小视屏一样)功能的时候也遇到了同样的问题，在没有判断相机权限的前提下，我手动关掉了APP的相机访问权限，则我录制视频的时候的预览页黑乎乎一片，什么也没有，同样没办法录制，这给用户的体验非常差，所以当我们调用系统资源的时候，一定要先判断是否拥有相应的权限。以下是我的判断相机权限的代码：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canRecordViedo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *mediaType = AVMediaTypeVideo;</span><br><span class="line">    AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType];</span><br><span class="line">    <span class="keyword">if</span> (authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相册权限"><a href="#相册权限" class="headerlink" title="相册权限"></a>相册权限</h3><hr>
<p>其实该权限不去判断也可以，因为当你没有相册权限而去调用本机相册的时候，系统默认会pop出一个提示的页面，提示用户，没有相册权限，去手机的设置页面设置该权限。系统的这个页面还是可以的（不丑），所以我就用了系统的提示页面了。但是我还是在工具类中实现了相册权限的判断，方便以后归类。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)albumAuthority</span><br><span class="line">&#123;</span><br><span class="line">    ALAuthorizationStatus author = [ALAssetsLibrary authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (author == kCLAuthorizationStatusRestricted || author ==kCLAuthorizationStatusDenied)&#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h3><hr>
<p>当用户用到定位的功能的时候，也涉及到权限的问题，我顺便也实现了该功能权限的判断：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)locationAuthority</span><br><span class="line">&#123;</span><br><span class="line">    CLAuthorizationStatus status = [CLLocationManager authorizationStatus];</span><br><span class="line">    <span class="keyword">if</span> (kCLAuthorizationStatusDenied == status || kCLAuthorizationStatusRestricted == status) &#123;</span><br><span class="line">        <span class="built_in">return</span> NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>当我们调用系统资源的时候，一定要先判断是否拥有相应的权限，做到代码的严谨性。        </p>
<h3 id="号外"><a href="#号外" class="headerlink" title="号外"></a>号外</h3><hr>
<p>扫码关注下面二维码，干货不断：<br><img src="http://img.blog.csdn.net/20160623095054012" alt="二维码"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在iOS开发中我们经常会调用系统相机和麦克风，但是这些权限都是用户可以控制的，当APP没有权限调用这些手机资源，但是我们没有判断，
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中关于死锁的一点总结</title>
    <link href="http://yoursite.com/2016/07/23/iOS-gcd-deadlock/"/>
    <id>http://yoursite.com/2016/07/23/iOS-gcd-deadlock/</id>
    <published>2016-07-23T04:02:04.000Z</published>
    <updated>2016-09-12T10:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><hr>
<p>所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。        </p>
<p>例如：     </p>
<p>死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。    </p>
<h3 id="GCD导致死锁的例子"><a href="#GCD导致死锁的例子" class="headerlink" title="GCD导致死锁的例子"></a>GCD导致死锁的例子</h3><hr>
<p>比如下面的这个会产生死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以自己先分析一下该程序产生死锁的原因。    </p>
<p>我们首先要搞清楚<code>同步&amp;异步</code> <code>串行&amp;并发</code>这两组基本概念：    </p>
<blockquote>
<p>同步执行：比如dispatch_sync，这个函数会把一个block加入到指定的队列中，而且会一直等到执行完blcok，这个函数才返回。因此在block执行完之前，调用dispatch_sync方法的线程是阻塞的。        </p>
<p>异步执行：一般使用dispatch_async，这个函数也会把一个block加入到指定的队列中，但是和同步执行不同的是，这个函数把block加入队列后不等block的执行就立刻返回了。</p>
</blockquote>
<p>接下来是”串行和并行”：        </p>
<blockquote>
<p>串行队列：比如dispatch_get_main_queue,这个队列中所有任务，一定按照先来后到的顺序执行。不仅如此，还可以保证在执行某个任务时，在它前面进入队列的所有任务肯定执行完了。对于每一个不同的串行队列，系统会为这个队列建立唯一的线程来执行代码。            </p>
<p>并发队列：比如dispatch_get_global_queue,这个队列中的任务也是按照先来后到的顺序开始执行，注意是开始，但是它们的执行结束时间是不确定的，取决于每个任务的耗时。对于n个并发队列，GCD不会创建对应的n个线程而是进行适当的优化。</p>
</blockquote>
<p>理解清楚上面的两组概念后我们再来分析上面例子产生死锁的原因：        </p>
<p>该程序中在主线程中同步执行<code>dispatch_sync(queue,block)</code>任务，而该任务又被分发到了主线程<code>dispatch_get_main_queue()</code>中，这就产生了问题。程序在执行<code>dispatch_sync(queue,block)</code>时，会阻塞调用线程（在这里是主线程），等待block中的任务执行完后再返回阻塞线程继续进行执行，但是block中的任务在执行的时候又需要在主线程中执行，而现在主线程被阻塞，所以就会产生两者相互等待的情况，死锁就形成了。    </p>
<p>下面对比着总结一下<code>dispatch_sync</code>和<code>dispatch_async</code>的执行流程：        </p>
<p>（1）dispatch_sync的执行流程：</p>
<ul>
<li>将block添加到queue队列中</li>
<li>阻塞调用线程，等待block（）执行结束，回调到调用线程。</li>
</ul>
<p>（2）dispatch_async的执行流程：    </p>
<ul>
<li>将block添加到queue队列中</li>
<li>直接回到调用线程（不阻塞调用线程）,异步执行。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>下面我总结一下关于死锁的一些注意事项：    </p>
<ul>
<li>异步执行一定不会产生死锁，因为异步的执行，block会立刻返回，不会阻塞线程。所以在我们开发过程中如果遇到死锁的问题，很大可能是同步执行的原因，这样可以帮助我们快速定位。</li>
<li>不要把block任务同步派发到调用gcd所在线程的关联队列中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。   
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods更新遇redefinition问题及其它问题汇总</title>
    <link href="http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/"/>
    <id>http://yoursite.com/2016/07/11/iOS-cocoaPods-bugs/</id>
    <published>2016-07-11T08:20:30.000Z</published>
    <updated>2016-07-11T10:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。</p>
<h2 id="1、问题环境"><a href="#1、问题环境" class="headerlink" title="1、问题环境"></a>1、问题环境</h2><p>升级时所使用的命令为：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>升级后用”pod –version”查看版本号是0.39.0，升级前的版本我没记错的话应该是0.37.2.</p>
<h2 id="2、Redefinition问题"><a href="#2、Redefinition问题" class="headerlink" title="2、Redefinition问题"></a>2、Redefinition问题</h2><p>升级后遇到的最大的问题就是这个Redefinition问题了，具体情况是我的工作项目中需要增加一个新的pod引用，pod update后编译报出一大堆Redefinition问题，涉及到AFNetworking，SDWebImage等常用库，而以前都好好的，百思不得其解。        </p>
<p><a href="&quot;Redefinition of module X&quot; errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue">“Redefinition of module X” errors in 0.38.1 · Issue #3886 · CocoaPods/CocoaPods 这个Github issue</a>提到了这个问题，但我并不得要领。        </p>
<p>为了这个问题我把Pods文件夹、Podfild.lock文件删除重新更新，甚至把CocoaPods降级到0.38.2以及0.37.2版本都没有解决，然后这个过程中又遇到了其它的问题，问题怎么解决的后面再说。</p>
<p>静下心来再查看这个问题，发现错误日志里还是提供了一些关键要素，能显示重复定义在哪里。因为我一般情况下都是看默认显示在Xcode左侧栏里的错误日志列表就解决，很少展开日志详细信息。这次的关键要素就是在日志详细信息中，然后就发现了一些规律：以AFNetworking为例，我在pch文件中是这样引用的：#import &lt;AFNetworking/AFNetworking.h&gt;，然后在其它文件也做了这样的引用：#import “AFNetworking.h”。这两个引用同时存在就造成了Redefinition，去掉后者的引用方式就可以解决AFNetworking的Redefinition问题了。        </p>
<p>正常情况下肯定是用尖括号那种引用方式，但是由于历史原因，项目中使用后者那种引用方式也有不少，以前也从来没出问题，不知道现在为什么一下子就全部暴露出来了。这一改就要改不少，没办法就只能一个一个改了。        </p>
<blockquote>
<p>后记：根据最新回复，是必须得使用#import &lt; AFNetworking\/AFNetworking.h &gt;这种形式的头文件引用了，应该是检查更严格了。            </p>
</blockquote>
<p><em>我在这里遇到的问题是SDWebImage的Redefinition问题，是在pch中导入了#import &lt; SDWebImage\/UIImageView+WebCache.h &gt;，但是在其他的类中又导入了#import “UIImageView+WebCache.h”，从而引起了Redefinition问题</em>        </p>
<h2 id="3、undefined-method-project’-for-lt-Pod-Installer问题"><a href="#3、undefined-method-project’-for-lt-Pod-Installer问题" class="headerlink" title="3、undefined method `project’ for #&lt;Pod::Installer问题"></a>3、undefined method `project’ for #&lt;Pod::Installer问题</h2><p>旧版本的Podfile在升级Cocoapods后pod install就会遇到这个问题，根据这篇文章，是因为Cocoapods升级到0.38或0.39版本后installer_representation.project.targets.each中的project改名了，变成了pods_project，好在给了一个0.37——0.39都通用的办法，比如原来的Podfile是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line">post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">    installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">        target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">            config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">            config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>升级后就要改成：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, <span class="string">'7.0'</span></span><br><span class="line">pod <span class="string">'Reveal-iOS-SDK'</span>, :configurations =&gt; [<span class="string">'Debug'</span>]</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"><span class="keyword">if</span> defined? installer_representation.pods_project</span><br><span class="line">    post_install <span class="keyword">do</span> |installer_representation|</span><br><span class="line">        installer_representation.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">            target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">                config.build_settings[<span class="string">'ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'VALID_ARCHS'</span>] = <span class="string">'armv7 arm64'</span></span><br><span class="line">                config.build_settings[<span class="string">'ONLY_ACTIVE_ARCH'</span>] = <span class="string">'NO'</span></span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="4、DVTAssertions-ASSERTION-FAILURE问题"><a href="#4、DVTAssertions-ASSERTION-FAILURE问题" class="headerlink" title="4、DVTAssertions: ASSERTION FAILURE问题"></a>4、DVTAssertions: ASSERTION FAILURE问题</h2><p>这是CocoaPods降级到0.37.2后pod install遇到的问题，记忆中当初好像就是因为这个问题而升级到0.39.0版本的。        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[MT] DVTAssertions: ASSERTION FAILURE <span class="keyword">in</span> /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-8227/IDEFoundation/Initialization/IDEInitialization.m:590</span><br><span class="line">Details: Assertion failed: _initializationCompletedSuccessfully</span><br><span class="line">Function: BOOL IDEIsInitializedForUserInteraction()</span><br><span class="line">Thread: &#123;number = 1, name = main&#125;</span><br><span class="line">Hints: None</span><br><span class="line">Backtrace:</span><br><span class="line">0 0x000000010462aa5c -DVTAssertionHandler handleFailureInFunction:fileName:lineNumber:assertionSignature:messageFormat:arguments:</span><br><span class="line">1 0x000000010462a1e9 _DVTAssertionHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">2 0x000000010462a455 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">3 0x000000010462a3b7 _DVTAssertionFailureHandler (<span class="keyword">in</span> DVTFoundation)</span><br><span class="line">4 0x0000000107191f5c IDEIsInitializedForUserInteraction (<span class="keyword">in</span> IDEFoundation)</span><br><span class="line">5 0x0000000109da8eb9 +PBXProject projectWithFile:errorHandler:<span class="built_in">read</span>Only:</span><br><span class="line">6 0x0000000109daaa3e +PBXProject projectWithFile:errorHandler:</span><br><span class="line">7 0x00007fff8bc68f44 ffi_call_unix64 (<span class="keyword">in</span> libffi.dylib)</span><br><span class="line">Abort <span class="built_in">trap</span>: 6</span><br></pre></td></tr></table></figure>
<p>网上大部分的帖子都说升级CocoaPods，比如这个<a href="https://github.com/CocoaPods/CocoaPods/issues/4209" target="_blank" rel="external">帖子</a>，然而具体问题具体分析好不好，我这个是降级时遇到的问题。</p>
<p>这个问题应该就是与Xcode版本有关了，实际就是与Developer的路径有关。我的Mac上同时存在有Xcode6.1.1版本与Xcode7.0版本，后者是默认的Xcode版本。</p>
<p>当CocoaPods为0.37.2版本时，对应的Developer路径应该是Xcode6.1.1版本的路径，因为这个之前一直都配合使用好好的。那么，就需要用到xcode-select问题了。通过xcode-select -p命令可以查看当前Developer路径，用xcode-select -s可以指定新的Developer路径。</p>
<p>我是这样指定的：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select <span class="_">-s</span> /Applications/Xcode6.1.1.app/Contents/Developer</span><br></pre></td></tr></table></figure>
<p>然后这个问题就不复存在了。注意当有必要使用CocoaPods 0.39.0版本时，必须得切换回来，要不然还是会遇到这个问题        </p>
<h2 id="5、CocoaPods多版本共存问题"><a href="#5、CocoaPods多版本共存问题" class="headerlink" title="5、CocoaPods多版本共存问题"></a>5、CocoaPods多版本共存问题</h2><p>本来我是想降级的，结果CocoaPods好像默认就是多版本共存了，比如我原来本来是0.37.2版本，用了本文开头的升级命令升级后，虽然用pod –version看是0.39.0版本，但是0.37.2版本并没有删除。这个可以用下面的命令查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem list --local | grep cocoapods</span><br></pre></td></tr></table></figure>
<p>如果你的只有一个版本，你可以再安装一个CocoaPods 0.38.2版本或者其它版本试试。比如安装0.38.2版本的命令就是：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 0.38.2</span><br></pre></td></tr></table></figure>
<p>说是共存了，但到底是怎么共存使用呢？就比如说我的CocoaPods默认版本是0.39.0，有一个项目要用0.37.2版本的CocoaPods该怎么用呢？        </p>
<p><a href="http://stackoverflow.com/questions/28130938/how-to-switch-cocoapods-or-other-gem-version-on-command-line/28140522#28140522" target="_blank" rel="external">这里</a>有人提供了这样的一个方法，但我没有细研究，也没实践，需要用到rbenv：        </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rbenv global 2.1.0</span><br><span class="line">gem install cocoapods -v 0.34.4</span><br><span class="line">rbenv global 2.0.0-p0</span><br><span class="line">gem install cocoapods -v 0.33.1</span><br></pre></td></tr></table></figure>
<p>步骤:        </p>
<ul>
<li>在项目根目录下创建Gemfile，指定CocoaPods版本    </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">'~&gt; 0.37.2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行bundle install命令</li>
</ul>
<p>****************这是华丽丽的分割线o(╯□╰)o******************</p>
<p>我是在原<a href="http://www.jianshu.com/p/ee32eef74ba9" target="_blank" rel="external">文章</a>的基础上做了些许改动,总结了自己遇到的一些问题。</p>
<hr>
<p>我们都是热爱移动开发的程序猿，加入我们，共同提高：              </p>
<p><img src="http://img.blog.csdn.net/20160623095054012" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近下载了网上的一份开源代码，pod更新时出错，根据网上别人的解答是项目太新用了Xcode7与iOS9 SDK，需要对CocoaPods进行了升级，没想到这一升级造成了一系列的问题，费了老鼻子劲才把这些问题都一一解决，就在这里记录一下吧，希望对需要的人有所帮助。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
